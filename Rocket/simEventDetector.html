<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MAPLEAF.Rocket.simEventDetector API documentation</title>
<meta name="description" content="Generalized event detector (Apogee, motor burnout etc...) for a single vehicle.
Used to trigger stage separations and recovery system deployments." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/Rocket/simEventDetector.html">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.Rocket.simEventDetector</code></h1>
</header>
<section id="section-intro">
<p>Generalized event detector (Apogee, motor burnout etc&hellip;) for a single vehicle.<br>
Used to trigger stage separations and recovery system deployments.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Created by: Henry Stoldt
# April 2020

&#39;&#39;&#39;
Generalized event detector (Apogee, motor burnout etc...) for a single vehicle.  
Used to trigger stage separations and recovery system deployments.
&#39;&#39;&#39;

from enum import Enum
from typing import Tuple

__all__ = [ &#34;EventTypes&#34;, &#34;SimEventDetector&#34; ]

class EventTypes(Enum):
    Apogee = &#34;apogee&#34;
    AscendingThroughAltitude = &#34;ascendingThroughAltitude&#34;
    DescendingThroughAltitude = &#34;descendingThroughAltitude&#34;
    MotorBurnout = &#34;motorBurnout&#34;
    TimeReached = &#34;timeReached&#34;

class SimEventDetector():
    &#39;&#39;&#39;
        Each sim event detector detects events on a single rocket 
    &#39;&#39;&#39;

    def __init__(self, rocket):
        self.rocket = rocket

        self.callbackFunctions = []
        self.conditionsEvalFunctions = []
        self.conditionValues = []
        self.triggerDelays = []

    def subscribeToEvent(self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0):
        &#39;&#39;&#39;
            Inputs:
                eventType:          &#34;apogee&#34;, &#34;ascendingThroughAltitude&#34;, &#34;descendingThroughAltitude&#34;, &#39;motorBurnout&#34; or &#34;timeReached&#34;
                    Can pass in a member of the EventType Enum defined above, if desired
                callbackfunction:   function to call when the desired event occurs. Must have no arguments
                eventTriggerValue:  None, or a trigger parameter for the eventType - an altitude or a time
                triggerDelay:       (numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met

            Note:
                Motor Burnout always triggers at the burnout time of the LOWEST stage&#39;s motor!
        &#39;&#39;&#39;
        # Define map between eventType strings and checker functions
        stringToEvalFnMap = {
            EventTypes.Apogee.value:                    self._isAfterApogee,
            EventTypes.AscendingThroughAltitude.value:  self._isAboveAltitude,
            EventTypes.DescendingThroughAltitude.value: self._isBelowAltitude,
            EventTypes.MotorBurnout.value:              self._isBottomStageMotorBurnedOut,
            EventTypes.TimeReached.value:               self._timeReached
        }

        # Make sure eventType is a string
        if not isinstance(eventType, str):
            eventType = eventType.value # If for example EventType.Apogee is passed in, EventType.Apogee.value retrieves &#34;apogee&#34; from the EventType enum
        
        self.callbackFunctions.append(callbackFunction)
        self.conditionValues.append(eventTriggerValue)
        self.conditionsEvalFunctions.append(stringToEvalFnMap[eventType])
        self.triggerDelays.append(triggerDelay)

    def triggerEvents(self) -&gt; Tuple[float, bool]:
        &#39;&#39;&#39; Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
            Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
                These return values are used to influence time step adaptation to accurately resolve discrete event timing
        &#39;&#39;&#39;
        # Save indices of conditions that have been triggered, will now be removed
        indicesToRemove = []
        
        estimatedTimeToNextEvent = 1e10
        nextEventTimeDeterministic = False
        
        # Precomputed to pass to sub-functions (required for altitude conditions)
        ENUState = self.rocket.environment.convertStateToENUFrame(self.rocket.rigidBody.state)

        # Check each callback condition
        for i in range(len(self.callbackFunctions)):
            # If a conditions has come true
            eventOccurred, timeToOccurrence, timeDeterministic = self.conditionsEvalFunctions[i](self.conditionValues[i], ENUState)

            # Get info about the next event to occur
            if timeToOccurrence &lt; estimatedTimeToNextEvent and not eventOccurred:
                estimatedTimeToNextEvent = timeToOccurrence
                nextEventTimeDeterministic = timeDeterministic

            if eventOccurred:
                if self.triggerDelays[i] == 0:
                    # Call its function
                    # TODO: Print message to simulation log saying that the event has been triggered
                    self.callbackFunctions[i]()
                else:
                    # Schedule the event to happen in triggerDelay seconds
                    triggerTime = self.rocket.rigidBody.time + self.triggerDelays[i]
                    self.subscribeToEvent(EventTypes.TimeReached, self.callbackFunctions[i], triggerTime)

                # And mark it for deletion
                indicesToRemove.append(i)

        # Delete all of the events that were triggered - working in reverse to ensure the indices of the items aren&#39;t changed before we delete them
        for i in range(len(indicesToRemove)):
            delI = len(indicesToRemove)-1-i
            indexToRemove = indicesToRemove[delI]
            
            del self.callbackFunctions[indexToRemove]
            del self.conditionValues[indexToRemove]
            del self.conditionsEvalFunctions[indexToRemove]
            del self.triggerDelays[indexToRemove]

        
        # Save velocity and time for next timestep (if we&#39;re trying to detect apogee)
            # Doing this here to avoid problems calling the apogee function multiple times in a single time step
        self.lastVelocity = ENUState.velocity
        self.lastTime = self.rocket.rigidBody.time

        return estimatedTimeToNextEvent, nextEventTimeDeterministic
    
    ### Event evaluation functions - each is expected to have a single parameter, return True/False ###
    def _isAfterApogee(self, _, ENUState):
        # Time &gt; 1.0 condition here to avoid setting off events if sliding slightly down before engine lights
        eventOccurred = ENUState.velocity.Z &lt;= 0 and self.rocket.rigidBody.time &gt; 1.0

        timeToOccurrence = 1e10
        try:
            accel = (ENUState.velocity.Z - self.lastVelocity.Z) / (self.rocket.rigidBody.time - self.lastTime)
            if accel &lt; 0 and ENUState.velocity.Z &gt; 0:
                timeToOccurrence = -ENUState.velocity.Z / accel
        except (AttributeError, ZeroDivisionError):
            pass # Haven&#39;t saved a velocity/time yet / calling function twice in a single time step

        return eventOccurred, timeToOccurrence, False

    def _isAboveAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &gt;= altitude and ENUState.velocity.Z &gt; 0

        if ENUState.velocity.Z &gt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBelowAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &lt;= altitude and ENUState.velocity.Z &lt; 0

        if ENUState.velocity.Z &lt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBottomStageMotorBurnedOut(self, _, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= self.rocket.stages[-1].engineShutOffTime
        timeToOccurrence = self.rocket.stages[-1].engineShutOffTime - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True

    def _timeReached(self, time, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= time
        timeToOccurrence = time - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes"><code class="flex name class">
<span>class <span class="ident">EventTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventTypes(Enum):
    Apogee = &#34;apogee&#34;
    AscendingThroughAltitude = &#34;ascendingThroughAltitude&#34;
    DescendingThroughAltitude = &#34;descendingThroughAltitude&#34;
    MotorBurnout = &#34;motorBurnout&#34;
    TimeReached = &#34;timeReached&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes.Apogee"><code class="name">var <span class="ident">Apogee</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes.AscendingThroughAltitude"><code class="name">var <span class="ident">AscendingThroughAltitude</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes.DescendingThroughAltitude"><code class="name">var <span class="ident">DescendingThroughAltitude</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes.MotorBurnout"><code class="name">var <span class="ident">MotorBurnout</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.EventTypes.TimeReached"><code class="name">var <span class="ident">TimeReached</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.SimEventDetector"><code class="flex name class">
<span>class <span class="ident">SimEventDetector</span></span>
<span>(</span><span>rocket)</span>
</code></dt>
<dd>
<div class="desc"><p>Each sim event detector detects events on a single rocket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimEventDetector():
    &#39;&#39;&#39;
        Each sim event detector detects events on a single rocket 
    &#39;&#39;&#39;

    def __init__(self, rocket):
        self.rocket = rocket

        self.callbackFunctions = []
        self.conditionsEvalFunctions = []
        self.conditionValues = []
        self.triggerDelays = []

    def subscribeToEvent(self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0):
        &#39;&#39;&#39;
            Inputs:
                eventType:          &#34;apogee&#34;, &#34;ascendingThroughAltitude&#34;, &#34;descendingThroughAltitude&#34;, &#39;motorBurnout&#34; or &#34;timeReached&#34;
                    Can pass in a member of the EventType Enum defined above, if desired
                callbackfunction:   function to call when the desired event occurs. Must have no arguments
                eventTriggerValue:  None, or a trigger parameter for the eventType - an altitude or a time
                triggerDelay:       (numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met

            Note:
                Motor Burnout always triggers at the burnout time of the LOWEST stage&#39;s motor!
        &#39;&#39;&#39;
        # Define map between eventType strings and checker functions
        stringToEvalFnMap = {
            EventTypes.Apogee.value:                    self._isAfterApogee,
            EventTypes.AscendingThroughAltitude.value:  self._isAboveAltitude,
            EventTypes.DescendingThroughAltitude.value: self._isBelowAltitude,
            EventTypes.MotorBurnout.value:              self._isBottomStageMotorBurnedOut,
            EventTypes.TimeReached.value:               self._timeReached
        }

        # Make sure eventType is a string
        if not isinstance(eventType, str):
            eventType = eventType.value # If for example EventType.Apogee is passed in, EventType.Apogee.value retrieves &#34;apogee&#34; from the EventType enum
        
        self.callbackFunctions.append(callbackFunction)
        self.conditionValues.append(eventTriggerValue)
        self.conditionsEvalFunctions.append(stringToEvalFnMap[eventType])
        self.triggerDelays.append(triggerDelay)

    def triggerEvents(self) -&gt; Tuple[float, bool]:
        &#39;&#39;&#39; Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
            Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
                These return values are used to influence time step adaptation to accurately resolve discrete event timing
        &#39;&#39;&#39;
        # Save indices of conditions that have been triggered, will now be removed
        indicesToRemove = []
        
        estimatedTimeToNextEvent = 1e10
        nextEventTimeDeterministic = False
        
        # Precomputed to pass to sub-functions (required for altitude conditions)
        ENUState = self.rocket.environment.convertStateToENUFrame(self.rocket.rigidBody.state)

        # Check each callback condition
        for i in range(len(self.callbackFunctions)):
            # If a conditions has come true
            eventOccurred, timeToOccurrence, timeDeterministic = self.conditionsEvalFunctions[i](self.conditionValues[i], ENUState)

            # Get info about the next event to occur
            if timeToOccurrence &lt; estimatedTimeToNextEvent and not eventOccurred:
                estimatedTimeToNextEvent = timeToOccurrence
                nextEventTimeDeterministic = timeDeterministic

            if eventOccurred:
                if self.triggerDelays[i] == 0:
                    # Call its function
                    # TODO: Print message to simulation log saying that the event has been triggered
                    self.callbackFunctions[i]()
                else:
                    # Schedule the event to happen in triggerDelay seconds
                    triggerTime = self.rocket.rigidBody.time + self.triggerDelays[i]
                    self.subscribeToEvent(EventTypes.TimeReached, self.callbackFunctions[i], triggerTime)

                # And mark it for deletion
                indicesToRemove.append(i)

        # Delete all of the events that were triggered - working in reverse to ensure the indices of the items aren&#39;t changed before we delete them
        for i in range(len(indicesToRemove)):
            delI = len(indicesToRemove)-1-i
            indexToRemove = indicesToRemove[delI]
            
            del self.callbackFunctions[indexToRemove]
            del self.conditionValues[indexToRemove]
            del self.conditionsEvalFunctions[indexToRemove]
            del self.triggerDelays[indexToRemove]

        
        # Save velocity and time for next timestep (if we&#39;re trying to detect apogee)
            # Doing this here to avoid problems calling the apogee function multiple times in a single time step
        self.lastVelocity = ENUState.velocity
        self.lastTime = self.rocket.rigidBody.time

        return estimatedTimeToNextEvent, nextEventTimeDeterministic
    
    ### Event evaluation functions - each is expected to have a single parameter, return True/False ###
    def _isAfterApogee(self, _, ENUState):
        # Time &gt; 1.0 condition here to avoid setting off events if sliding slightly down before engine lights
        eventOccurred = ENUState.velocity.Z &lt;= 0 and self.rocket.rigidBody.time &gt; 1.0

        timeToOccurrence = 1e10
        try:
            accel = (ENUState.velocity.Z - self.lastVelocity.Z) / (self.rocket.rigidBody.time - self.lastTime)
            if accel &lt; 0 and ENUState.velocity.Z &gt; 0:
                timeToOccurrence = -ENUState.velocity.Z / accel
        except (AttributeError, ZeroDivisionError):
            pass # Haven&#39;t saved a velocity/time yet / calling function twice in a single time step

        return eventOccurred, timeToOccurrence, False

    def _isAboveAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &gt;= altitude and ENUState.velocity.Z &gt; 0

        if ENUState.velocity.Z &gt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBelowAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &lt;= altitude and ENUState.velocity.Z &lt; 0

        if ENUState.velocity.Z &lt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBottomStageMotorBurnedOut(self, _, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= self.rocket.stages[-1].engineShutOffTime
        timeToOccurrence = self.rocket.stages[-1].engineShutOffTime - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True

    def _timeReached(self, time, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= time
        timeToOccurrence = time - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.simEventDetector.SimEventDetector.subscribeToEvent"><code class="name flex">
<span>def <span class="ident">subscribeToEvent</span></span>(<span>self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="inputs">Inputs</h2>
<p>eventType:
"apogee", "ascendingThroughAltitude", "descendingThroughAltitude", 'motorBurnout" or "timeReached"
Can pass in a member of the EventType Enum defined above, if desired
callbackfunction:
function to call when the desired event occurs. Must have no arguments
eventTriggerValue:
None, or a trigger parameter for the eventType - an altitude or a time
triggerDelay:
(numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met</p>
<h2 id="note">Note</h2>
<p>Motor Burnout always triggers at the burnout time of the LOWEST stage's motor!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribeToEvent(self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0):
    &#39;&#39;&#39;
        Inputs:
            eventType:          &#34;apogee&#34;, &#34;ascendingThroughAltitude&#34;, &#34;descendingThroughAltitude&#34;, &#39;motorBurnout&#34; or &#34;timeReached&#34;
                Can pass in a member of the EventType Enum defined above, if desired
            callbackfunction:   function to call when the desired event occurs. Must have no arguments
            eventTriggerValue:  None, or a trigger parameter for the eventType - an altitude or a time
            triggerDelay:       (numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met

        Note:
            Motor Burnout always triggers at the burnout time of the LOWEST stage&#39;s motor!
    &#39;&#39;&#39;
    # Define map between eventType strings and checker functions
    stringToEvalFnMap = {
        EventTypes.Apogee.value:                    self._isAfterApogee,
        EventTypes.AscendingThroughAltitude.value:  self._isAboveAltitude,
        EventTypes.DescendingThroughAltitude.value: self._isBelowAltitude,
        EventTypes.MotorBurnout.value:              self._isBottomStageMotorBurnedOut,
        EventTypes.TimeReached.value:               self._timeReached
    }

    # Make sure eventType is a string
    if not isinstance(eventType, str):
        eventType = eventType.value # If for example EventType.Apogee is passed in, EventType.Apogee.value retrieves &#34;apogee&#34; from the EventType enum
    
    self.callbackFunctions.append(callbackFunction)
    self.conditionValues.append(eventTriggerValue)
    self.conditionsEvalFunctions.append(stringToEvalFnMap[eventType])
    self.triggerDelays.append(triggerDelay)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.simEventDetector.SimEventDetector.triggerEvents"><code class="name flex">
<span>def <span class="ident">triggerEvents</span></span>(<span>self) ‑> Tuple[float, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
These return values are used to influence time step adaptation to accurately resolve discrete event timing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triggerEvents(self) -&gt; Tuple[float, bool]:
    &#39;&#39;&#39; Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
        Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
            These return values are used to influence time step adaptation to accurately resolve discrete event timing
    &#39;&#39;&#39;
    # Save indices of conditions that have been triggered, will now be removed
    indicesToRemove = []
    
    estimatedTimeToNextEvent = 1e10
    nextEventTimeDeterministic = False
    
    # Precomputed to pass to sub-functions (required for altitude conditions)
    ENUState = self.rocket.environment.convertStateToENUFrame(self.rocket.rigidBody.state)

    # Check each callback condition
    for i in range(len(self.callbackFunctions)):
        # If a conditions has come true
        eventOccurred, timeToOccurrence, timeDeterministic = self.conditionsEvalFunctions[i](self.conditionValues[i], ENUState)

        # Get info about the next event to occur
        if timeToOccurrence &lt; estimatedTimeToNextEvent and not eventOccurred:
            estimatedTimeToNextEvent = timeToOccurrence
            nextEventTimeDeterministic = timeDeterministic

        if eventOccurred:
            if self.triggerDelays[i] == 0:
                # Call its function
                # TODO: Print message to simulation log saying that the event has been triggered
                self.callbackFunctions[i]()
            else:
                # Schedule the event to happen in triggerDelay seconds
                triggerTime = self.rocket.rigidBody.time + self.triggerDelays[i]
                self.subscribeToEvent(EventTypes.TimeReached, self.callbackFunctions[i], triggerTime)

            # And mark it for deletion
            indicesToRemove.append(i)

    # Delete all of the events that were triggered - working in reverse to ensure the indices of the items aren&#39;t changed before we delete them
    for i in range(len(indicesToRemove)):
        delI = len(indicesToRemove)-1-i
        indexToRemove = indicesToRemove[delI]
        
        del self.callbackFunctions[indexToRemove]
        del self.conditionValues[indexToRemove]
        del self.conditionsEvalFunctions[indexToRemove]
        del self.triggerDelays[indexToRemove]

    
    # Save velocity and time for next timestep (if we&#39;re trying to detect apogee)
        # Doing this here to avoid problems calling the apogee function multiple times in a single time step
    self.lastVelocity = ENUState.velocity
    self.lastTime = self.rocket.rigidBody.time

    return estimatedTimeToNextEvent, nextEventTimeDeterministic</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.Rocket" href="index.html">MAPLEAF.Rocket</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes" href="#MAPLEAF.Rocket.simEventDetector.EventTypes">EventTypes</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes.Apogee" href="#MAPLEAF.Rocket.simEventDetector.EventTypes.Apogee">Apogee</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes.AscendingThroughAltitude" href="#MAPLEAF.Rocket.simEventDetector.EventTypes.AscendingThroughAltitude">AscendingThroughAltitude</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes.DescendingThroughAltitude" href="#MAPLEAF.Rocket.simEventDetector.EventTypes.DescendingThroughAltitude">DescendingThroughAltitude</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes.MotorBurnout" href="#MAPLEAF.Rocket.simEventDetector.EventTypes.MotorBurnout">MotorBurnout</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector.EventTypes.TimeReached" href="#MAPLEAF.Rocket.simEventDetector.EventTypes.TimeReached">TimeReached</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.simEventDetector.SimEventDetector" href="#MAPLEAF.Rocket.simEventDetector.SimEventDetector">SimEventDetector</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.simEventDetector.SimEventDetector.subscribeToEvent" href="#MAPLEAF.Rocket.simEventDetector.SimEventDetector.subscribeToEvent">subscribeToEvent</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector.SimEventDetector.triggerEvents" href="#MAPLEAF.Rocket.simEventDetector.SimEventDetector.triggerEvents">triggerEvents</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>