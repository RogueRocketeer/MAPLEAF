<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>MAPLEAF.Rocket API documentation</title>
<meta name="description" content="Code specific to modelling Rockets.
Main class is `Rocket` â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/Rocket/">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.Rocket</code></h1>
</header>
<section id="section-intro">
<p>Code specific to modelling Rockets.<br>
Main class is <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code>.</p>
<p>Other files define models for specific rocket components or stages.<br>
In general the responsibility of rocket component classes is to model:</p>
<ol>
<li>The forces/moments (aerodynamic or otherwise (excluding gravitational forces)) applied to the rocket by that rocket component</li>
<li>The inertia of that rocket component</li>
</ol>
<p>The interface all rocket components are expected to implement is defined by the abstract base class <code><a title="MAPLEAF.Rocket.RocketComponent" href="#MAPLEAF.Rocket.RocketComponent">RocketComponent</a></code>. All rocket components inherit from this base class.</p>
<p><img alt="" src="https://airandspace.si.edu/sites/default/files/images/NASAJSC2002-01598h.jpg"></p>
<p>MAPLEAF.Rocket relies on (in order of coupling) <code><a title="MAPLEAF.Motion" href="../Motion/index.html">MAPLEAF.Motion</a></code>, <code><a title="MAPLEAF.ENV" href="../ENV/index.html">MAPLEAF.ENV</a></code>, <code><a title="MAPLEAF.IO" href="../IO/index.html">MAPLEAF.IO</a></code>, and <code><a title="MAPLEAF.GNC" href="../GNC/index.html">MAPLEAF.GNC</a></code></p>
<h3 id="approximate-material-roughnesses">Approximate Material Roughnesses</h3>
<table>
<thead>
<tr>
<th>Material</th>
<th>Roughness ( <span><span class="MathJax_Preview">\mu m</span><script type="math/tex">\mu m</script></span> )</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mirror:</td>
<td>0</td>
</tr>
<tr>
<td>Glass:</td>
<td>0.1</td>
</tr>
<tr>
<td>Finished/Polished surface:</td>
<td>0.5</td>
</tr>
<tr>
<td>Aircraft-type sheet-metal surface:</td>
<td>2</td>
</tr>
<tr>
<td>Optimum paint-sprayed surfaces:</td>
<td>5</td>
</tr>
<tr>
<td>Planed wooden boards:</td>
<td>15</td>
</tr>
<tr>
<td>Paint in aircraft mass production:</td>
<td>20</td>
</tr>
<tr>
<td>Steel plating: bare:</td>
<td>50</td>
</tr>
<tr>
<td>Smooth cement:</td>
<td>50</td>
</tr>
<tr>
<td>Surface with asphalt-type coating:</td>
<td>100</td>
</tr>
<tr>
<td>Dip-galvanized metal surface:</td>
<td>150</td>
</tr>
<tr>
<td>Incorrectly sprayed paint:</td>
<td>200</td>
</tr>
<tr>
<td>Natural cast-iron surface:</td>
<td>250</td>
</tr>
<tr>
<td>Raw wooden boards:</td>
<td>500</td>
</tr>
<tr>
<td>Average concrete:</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>(From Barrowman, 1967, Table 4-1)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">r&#39;&#39;&#39;
Code specific to modelling Rockets.  
Main class is `Rocket`.

Other files define models for specific rocket components or stages.  
In general the responsibility of rocket component classes is to model:

1. The forces/moments (aerodynamic or otherwise (excluding gravitational forces)) applied to the rocket by that rocket component
2. The inertia of that rocket component

The interface all rocket components are expected to implement is defined by the abstract base class `MAPLEAF.Rocket.RocketComponent`. All rocket components inherit from this base class.

.. image:: https://airandspace.si.edu/sites/default/files/images/NASAJSC2002-01598h.jpg

MAPLEAF.Rocket relies on (in order of coupling) `MAPLEAF.Motion`, `MAPLEAF.ENV`, `MAPLEAF.IO`, and `MAPLEAF.GNC`

### Approximate Material Roughnesses
| Material                           | Roughness ( \(\mu m\) )                                        |
|------------------------------------|-------------------------------------------------------|
| Mirror:                            | 0                                                     |
| Glass:                             | 0.1                                                   |
| Finished/Polished surface:         | 0.5                                                   |
| Aircraft-type sheet-metal surface: | 2                                                     |
| Optimum paint-sprayed surfaces:    | 5                                                     |
| Planed wooden boards:              | 15                                                    |
| Paint in aircraft mass production: | 20                                                    |
| Steel plating: bare:               | 50                                                    |
| Smooth cement:                     | 50                                                    |
| Surface with asphalt-type coating: | 100                                                   |
| Dip-galvanized metal surface:      | 150                                                   |
| Incorrectly sprayed paint:         | 200                                                   |
| Natural cast-iron surface:         | 250                                                   |
| Raw wooden boards:                 | 500                                                   |
| Average concrete:                  | 1000                                                  |

(From Barrowman, 1967, Table 4-1)  

&#39;&#39;&#39;
# Make the classes in all submodules importable directly from MAPLEAF.Rocket
from .RocketComponents import *
from .simEventDetector import *
from .boatTail import *
from .bodyTube import *
from .Fins import *
from .Propulsion import *
from .Recovery import *
from .noseCone import *
from .RocketComponentFactory import *
from .stage import *
from .rocket import *

subModules = [ RocketComponents, simEventDetector, boatTail, bodyTube, Fins, Propulsion, Recovery, noseCone, stage, rocket, RocketComponentFactory ]

__all__ = [ ]

for subModule in subModules:
    __all__ += subModule.__all__</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="MAPLEAF.Rocket.AeroFunctions" href="AeroFunctions.html">MAPLEAF.Rocket.AeroFunctions</a></code></dt>
<dd>
<div class="desc"><p>Functions to calculate parameters relevant to aerodynamic calculations -
Mach/Reynolds numbers, AOA, local frame air velocity etc â€¦</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.CompositeObject" href="CompositeObject.html">MAPLEAF.Rocket.CompositeObject</a></code></dt>
<dd>
<div class="desc"><p>Both <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code> and <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code> objects inherit from <code><a title="MAPLEAF.Rocket.CompositeObject" href="CompositeObject.html">MAPLEAF.Rocket.CompositeObject</a></code>.
It implements functionality to add forces and inertias â€¦</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.CythonFinFunctions" href="CythonFinFunctions.html">MAPLEAF.Rocket.CythonFinFunctions</a></code></dt>
<dd>
<div class="desc"><p>Cython functions to speed up the <code><a title="MAPLEAF.Rocket.FinSet" href="#MAPLEAF.Rocket.FinSet">FinSet</a></code> aerodynamic model</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.Fins" href="Fins.html">MAPLEAF.Rocket.Fins</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.Propulsion" href="Propulsion.html">MAPLEAF.Rocket.Propulsion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.Recovery" href="Recovery.html">MAPLEAF.Rocket.Recovery</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.RocketComponentFactory" href="RocketComponentFactory.html">MAPLEAF.Rocket.RocketComponentFactory</a></code></dt>
<dd>
<div class="desc"><p>In charge of initializing rocket components. Add new components to <code>stringNameToClassMap</code> to make them instantiate themselves when included in a Rocket</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.RocketComponents" href="RocketComponents.html">MAPLEAF.Rocket.RocketComponents</a></code></dt>
<dd>
<div class="desc"><p>Contains interface definitions (<code><a title="MAPLEAF.Rocket.RocketComponent" href="#MAPLEAF.Rocket.RocketComponent">RocketComponent</a></code>/<code><a title="MAPLEAF.Rocket.BodyComponent" href="#MAPLEAF.Rocket.BodyComponent">BodyComponent</a></code>) and Base classes for all RocketComponents (<code><a title="MAPLEAF.Rocket.FixedMass" href="#MAPLEAF.Rocket.FixedMass">FixedMass</a></code>),<br>
as well as some simple â€¦</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.boatTail" href="boatTail.html">MAPLEAF.Rocket.boatTail</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.bodyTube" href="bodyTube.html">MAPLEAF.Rocket.bodyTube</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.noseCone" href="noseCone.html">MAPLEAF.Rocket.noseCone</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.rocket" href="rocket.html">MAPLEAF.Rocket.rocket</a></code></dt>
<dd>
<div class="desc"><p><code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a> ties together the code in </code>MAPLEAF.GNC<code>, </code>MAPLEAF.Rocket<code>, </code>MAPLEAF.Motion<code>, and </code>MAPLEAF.ENV` to
simulate the flight of a single rocket or â€¦</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.simEventDetector" href="simEventDetector.html">MAPLEAF.Rocket.simEventDetector</a></code></dt>
<dd>
<div class="desc"><p>Generalized event detector (Apogee, motor burnout etc&hellip;) for a single vehicle.<br>
Used to trigger stage separations and recovery system deployments.</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.Rocket.stage" href="stage.html">MAPLEAF.Rocket.stage</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.Rocket.rocketComponentFactory"><code class="name flex">
<span>def <span class="ident">rocketComponentFactory</span></span>(<span>subDictPath, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a rocket component based on the stringNameToClassMap</p>
<h2 id="inputs">Inputs</h2>
<p>subDictPath:
(string) Path to subDict in simulation definition, like "Rocket.Stage1.Nosecone"
rocket:
(Rocket) that the component is a part of
stage:
(Stage) That the component is a part of
Also uses the stringNameToClassMap dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rocketComponentFactory(subDictPath, rocket, stage):
    &#34;&#34;&#34;
        Initializes a rocket component based on the stringNameToClassMap
        Inputs:
            subDictPath:        (string) Path to subDict in simulation definition, like &#34;Rocket.Stage1.Nosecone&#34;
            rocket:             (Rocket) that the component is a part of
            stage:              (Stage) That the component is a part of
        Also uses the stringNameToClassMap dictionary
    &#34;&#34;&#34;       
    # Create SubDictReader for the rocket component&#39;s dictionary
    componentDictReader = SubDictReader(subDictPath, rocket.simDefinition)

    # Figure out which class to initialize
    className = componentDictReader.getString(&#34;class&#34;)
    referencedClass = stringNameToClassMap[className]
    
    # Initialize it
    return referencedClass(componentDictReader, rocket, stage)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.Rocket.AeroDamping"><code class="flex name class">
<span>class <span class="ident">AeroDamping</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>A zero-inertia component with constant aerodynamic damping coefficients</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AeroDamping(AeroForce):
    &#39;&#39;&#39; A zero-inertia component with constant aerodynamic damping coefficients &#39;&#39;&#39;

    position = Vector(0,0,0)

    def __init__(self, componentDictReader, rocket, stage):
        self.componentDictReader = componentDictReader
        self.rocket = rocket
        self.stage = stage
        self.name = componentDictReader.getDictName()

        self.Aref = componentDictReader.getFloat(&#34;Aref&#34;)
        self.Lref = componentDictReader.getFloat(&#34;Lref&#34;)

        self.zDampingCoeffs = componentDictReader.getVector(&#34;zDampingCoeffs&#34;)
        self.yDampingCoeffs = componentDictReader.getVector(&#34;yDampingCoeffs&#34;)
        self.xDampingCoeffs = componentDictReader.getVector(&#34;xDampingCoeffs&#34;)
    
    @logForceResult
    def getAeroForce(self, state, time, environment, rocketCG):
        airspeed = max(AeroParameters.getLocalFrameAirVel(state, environment).length(), 0.0000001)
        redimConst = self.Lref / (2*airspeed)
        # Calculate moment coefficients from damping coefficients
        localFrameAngularVelocity = Vector(*state.angularVelocity)
        zMomentCoeff = self.zDampingCoeffs * localFrameAngularVelocity * redimConst
        yMomentCoeff = self.yDampingCoeffs * localFrameAngularVelocity * redimConst
        xMomentCoeff = self.xDampingCoeffs * localFrameAngularVelocity * redimConst
        momentCoeffs = [ xMomentCoeff, yMomentCoeff, zMomentCoeff ]

        return AeroFunctions.forceFromCoefficients(state, environment, 0, 0, *momentCoeffs, self.position, self.Aref, self.Lref)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.AeroForce" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.AeroForce">AeroForce</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.AeroDamping.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.AeroDamping.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.AeroForce"><code class="flex name class">
<span>class <span class="ident">AeroForce</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>A zero-Inertia component with constant aerodynamic coefficients</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AeroForce(RocketComponent):
    &#39;&#39;&#39; A zero-Inertia component with constant aerodynamic coefficients &#39;&#39;&#39;
    # Object is just a force, inertia is zero
    inertia = Inertia(Vector(0,0,0), Vector(0,0,0), 0)

    def __init__(self, componentDictReader, rocket, stage):
        self.componentDictReader = componentDictReader
        self.rocket = rocket
        self.stage = stage
        self.name = componentDictReader.getDictName()

        self.position = componentDictReader.getVector(&#34;position&#34;)
        self.Aref = componentDictReader.getFloat(&#34;Aref&#34;)
        self.Lref = componentDictReader.getFloat(&#34;Lref&#34;)

        Cd = componentDictReader.getFloat(&#34;Cd&#34;)
        Cl = componentDictReader.getFloat(&#34;Cl&#34;)
        momentCoeffs = componentDictReader.getVector(&#34;momentCoeffs&#34;)

        self.aeroCoeffs = [ Cd, Cl, *momentCoeffs ]

    def getInertia(self, time, state):
        return self.inertia

    @logForceResult
    def getAeroForce(self, state, time, environment, rocketCG):
        return AeroFunctions.forceFromCoefficients(state, environment, *self.aeroCoeffs, self.position, self.Aref, self.Lref)

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.AeroDamping" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.AeroDamping">AeroDamping</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.TabulatedAeroForce" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.TabulatedAeroForce">TabulatedAeroForce</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.AeroForce.inertia"><code class="name">var <span class="ident">inertia</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.AeroForce.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.AeroForce.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    return self.inertia</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.AeroForce.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.BoatTail"><code class="flex name class">
<span>class <span class="ident">BoatTail</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a conical boattail (aerodynamic properties quite similar to curved boattails, especially in supersonic flight)
Always assumes it's at the bottom of a rocket.
Modelled like a Transition object, but accounts for base drag.</p>
<p>Two possible sets of inputs:<br>
1. Initialization as a regular, dictionary-defined rocket component:<br>
* args = (componentDictReader, rocket, stage)<br>
* Expected classes: (<code><a title="MAPLEAF.IO.SubDictReader" href="../IO/index.html#MAPLEAF.IO.SubDictReader">SubDictReader</a></code>, <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code>, <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code>)<br>
2. Manual initialization:<br>
* args = (startDiameter, endDiameter, length, position, inertia, rocket, stage, name, surfaceRoughness)<br>
* Expected classes: (float, float, float, <code><a title="MAPLEAF.Motion.Vector" href="../Motion/index.html#MAPLEAF.Motion.Vector">Vector</a></code>, <code><a title="MAPLEAF.Motion.Inertia" href="../Motion/index.html#MAPLEAF.Motion.Inertia">Inertia</a></code>, <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code>, <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code>, str, float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoatTail(Transition):
    &#39;&#39;&#39;        
        Defines a conical boattail (aerodynamic properties quite similar to curved boattails, especially in supersonic flight)
        Always assumes it&#39;s at the bottom of a rocket.
        Modelled like a Transition object, but accounts for base drag.
    &#39;&#39;&#39;
    canConnectToComponentBelow = False 
    &#39;&#39;&#39; Overrides attribute inherited from BodyComponent (through Transition), to indicate that this component must exist at the very bottom of a rocket &#39;&#39;&#39;

    @logForceResult
    def getAeroForce(self, rocketState, time, environment, CG) -&gt; ForceMomentSystem:
        Mach = AeroParameters.getMachNumber(rocketState, environment)
        Aref = self.rocket.Aref
        
        #### Normal Force ####
        AOA = AeroParameters.getTotalAOA(rocketState, environment)
        CN = AeroFunctions.Barrowman_GetCN(AOA, Aref, self.topArea, self.bottomArea)

        #### Pressure Drag ####
        Cd_base = AeroFunctions.getBaseDragCoefficient(Mach)
        Cd_pressure = Cd_base * self.CdAdjustmentFactor
        Cd_pressure *= self.frontalArea / self.rocket.Aref

        noEngine = (self.stage.engineShutOffTime == None)
        if noEngine or time &gt; self.stage.engineShutOffTime:
            # Add base drag if engine is off
            Cd_pressure += Cd_base * self.bottomArea / Aref

        #### Skin Friction Drag ####
        if self.wettedArea == 0:
            skinFrictionDragCoefficient = 0
            rollDampingMoment = Vector(0,0,0)
        else:
            skinFrictionDragCoefficient, rollDampingMoment = AeroFunctions.getCylindricalSkinFrictionDragCoefficientAndRollDampingMoment(rocketState, environment, \
                 self.length, Mach, self.surfaceRoughness, self.wettedArea, Aref, self.rocket.finenessRatio, self.rocket.fullyTurbulentBL)

        #### Total Drag ####
        Cd = Cd_pressure + skinFrictionDragCoefficient

        #### Assemble &amp; return final force object ####
        return AeroFunctions.forceFromCdCN(rocketState, environment, Cd, CN, self.CPLocation, Aref, moment=rollDampingMoment)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.boatTail.Transition" href="boatTail.html#MAPLEAF.Rocket.boatTail.Transition">Transition</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.BoatTail.canConnectToComponentBelow"><code class="name">var <span class="ident">canConnectToComponentBelow</span></code></dt>
<dd>
<div class="desc"><p>Overrides attribute inherited from BodyComponent (through Transition), to indicate that this component must exist at the very bottom of a rocket</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.BoatTail.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.boatTail.Transition" href="boatTail.html#MAPLEAF.Rocket.boatTail.Transition">Transition</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.boatTail.Transition.getBottomInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.boatTail.Transition.getMaxDiameter" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.boatTail.Transition.getRadius" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.boatTail.Transition.getTopInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent"><code class="flex name class">
<span>class <span class="ident">BodyComponent</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class that defines interface for axisymmetric body components.
Contains logic for detecting adjacent body components &amp; defining interfaces with them
Examples: <code><a title="MAPLEAF.Rocket.NoseCone" href="#MAPLEAF.Rocket.NoseCone">NoseCone</a></code>, <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyComponent(ABC):
    &#39;&#39;&#39; 
        Class that defines interface for axisymmetric body components.
        Contains logic for detecting adjacent body components &amp; defining interfaces with them 
        Examples: `MAPLEAF.Rocket.NoseCone`, `MAPLEAF.Rocket.Stage`
    &#39;&#39;&#39;
    # Override these attributes in child classes to change whether they can connect to components above/below them
    canConnectToComponentAbove = True
    canConnectToComponentBelow = True

    def getTopInterfaceLocation(self) -&gt; Union[None, Vector]:
        &#39;&#39;&#39; For planar cylindrical interfaces, returns the location of the center of the cylindrical interface &#39;&#39;&#39;
        if self.canConnectToComponentAbove:
            return self.position
        else:
            return None

    def getBottomInterfaceLocation(self) -&gt; Union[None, Vector]:
        &#39;&#39;&#39; For planar cylindrical interfaces, returns the location of the center of the cylindrical interface &#39;&#39;&#39;
        if self.canConnectToComponentBelow:
            baseZCoord = self.position.Z-self.length
            return Vector(self.position.X, self.position.Y, baseZCoord)
        else:
            return None

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)

    def _getCenterOfPressure(self, *args) -&gt; Vector:
        return self.CPLocation

    @abstractmethod
    def getMaxDiameter(self):
        &#39;&#39;&#39; These functions used for determining rocket&#39;s current max diameter &#39;&#39;&#39;
        return

    @abstractmethod
    def getRadius(self, distanceFromTop: float) -&gt; float:
        &#39;&#39;&#39; Should return body component radius as a function of distance from the top of the component &#39;&#39;&#39;
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.boatTail.Transition" href="boatTail.html#MAPLEAF.Rocket.boatTail.Transition">Transition</a></li>
<li><a title="MAPLEAF.Rocket.bodyTube.BodyTube" href="bodyTube.html#MAPLEAF.Rocket.bodyTube.BodyTube">BodyTube</a></li>
<li><a title="MAPLEAF.Rocket.noseCone.NoseCone" href="noseCone.html#MAPLEAF.Rocket.noseCone.NoseCone">NoseCone</a></li>
<li><a title="MAPLEAF.Rocket.stage.Stage" href="stage.html#MAPLEAF.Rocket.stage.Stage">Stage</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.BodyComponent.canConnectToComponentAbove"><code class="name">var <span class="ident">canConnectToComponentAbove</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent.canConnectToComponentBelow"><code class="name">var <span class="ident">canConnectToComponentBelow</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.BodyComponent.getBottomInterfaceLocation"><code class="name flex">
<span>def <span class="ident">getBottomInterfaceLocation</span></span>(<span>self) â€‘>Â Union[NoneType,Â <a title="MAPLEAF.Motion.CythonVector.Vector" href="../Motion/CythonVector.html#MAPLEAF.Motion.CythonVector.Vector">Vector</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>For planar cylindrical interfaces, returns the location of the center of the cylindrical interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBottomInterfaceLocation(self) -&gt; Union[None, Vector]:
    &#39;&#39;&#39; For planar cylindrical interfaces, returns the location of the center of the cylindrical interface &#39;&#39;&#39;
    if self.canConnectToComponentBelow:
        baseZCoord = self.position.Z-self.length
        return Vector(self.position.X, self.position.Y, baseZCoord)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent.getMaxDiameter"><code class="name flex">
<span>def <span class="ident">getMaxDiameter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>These functions used for determining rocket's current max diameter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def getMaxDiameter(self):
    &#39;&#39;&#39; These functions used for determining rocket&#39;s current max diameter &#39;&#39;&#39;
    return</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent.getRadius"><code class="name flex">
<span>def <span class="ident">getRadius</span></span>(<span>self, distanceFromTop:Â float) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Should return body component radius as a function of distance from the top of the component</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def getRadius(self, distanceFromTop: float) -&gt; float:
    &#39;&#39;&#39; Should return body component radius as a function of distance from the top of the component &#39;&#39;&#39;
    return</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.BodyComponent.getTopInterfaceLocation"><code class="name flex">
<span>def <span class="ident">getTopInterfaceLocation</span></span>(<span>self) â€‘>Â Union[NoneType,Â <a title="MAPLEAF.Motion.CythonVector.Vector" href="../Motion/CythonVector.html#MAPLEAF.Motion.CythonVector.Vector">Vector</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>For planar cylindrical interfaces, returns the location of the center of the cylindrical interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTopInterfaceLocation(self) -&gt; Union[None, Vector]:
    &#39;&#39;&#39; For planar cylindrical interfaces, returns the location of the center of the cylindrical interface &#39;&#39;&#39;
    if self.canConnectToComponentAbove:
        return self.position
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.BodyTube"><code class="flex name class">
<span>class <span class="ident">BodyTube</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a cylindrical body tube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyTube(FixedMass, BodyComponent):
    &#39;&#39;&#39; Represent a cylindrical body tube &#39;&#39;&#39;
    
    #### Init Functions ####
    def __init__(self, componentDictReader, rocket, stage):
        FixedMass.__init__(self, componentDictReader, rocket, stage)

        self.length = componentDictReader.getFloat(&#34;length&#34;)
        self.outerDiameter = componentDictReader.getFloat(&#34;outerDiameter&#34;)
        self.surfaceRoughness = componentDictReader.tryGetFloat(&#34;surfaceRoughness&#34;, defaultValue=self.rocket.surfaceRoughness)

        # Tell the rocket/stage what its diameter is
        self.rocket.bodyTubeDiameter = self.outerDiameter
        self.stage.bodyTubeDiameter = self.outerDiameter

        self._precomputeGeometry()

    def _precomputeGeometry(self):
        self.volume = math.pi * self.outerDiameter**2 / 4 * self.length
        self.planformArea = self.outerDiameter * self.length
        self.wettedArea = math.pi * self.outerDiameter * self.length
        
        self.CPLocation = self.position - Vector(0,0,self.length/2)

    #### Operational Functions ####
    @logForceResult
    def getAeroForce(self, rocketState, time, environment, CG):
        Aref = self.rocket.Aref

        # Normal Force ----------------------------------------------------------------------------------------
        AOA = AeroParameters.getTotalAOA(rocketState, environment)
        # Niskanen Eqn 3.26 - originally from Galejs
        normalForceCoefficient = 1.1 * (math.sin(AOA))**2
        normalForceCoefficient *= self.planformArea / Aref

        # Drag -----------------------------------------------------------------------------------------------
        # Skin Friction
        Mach = AeroParameters.getMachNumber(rocketState, environment)
        skinFrictionDragCoefficient, rollDampingMoment = AeroFunctions.getCylindricalSkinFrictionDragCoefficientAndRollDampingMoment(rocketState, environment, self.length, Mach, self.surfaceRoughness, \
            self.wettedArea, Aref, self.rocket.finenessRatio, self.rocket.fullyTurbulentBL)
        
        #There is no pressure drag associated with bodytubes - skin friction drag is total drag

        # Damping moments --------------------------------------------------------------------------------------
        dampingMoments = self._computeLongitudinalDampingMoments(rocketState, environment, CG)
        
        # Roll damping due to skin friction
        dampingMoments += rollDampingMoment

        # Compute &amp; dimensionalize total-------------------------------------------------------------------------
        return AeroFunctions.forceFromCdCN(rocketState, environment, skinFrictionDragCoefficient, normalForceCoefficient, self.CPLocation, Aref, moment=dampingMoments)

    def _computeLongitudinalDampingMoments(self, rocketState, environment, CoR, nSegments=25):
        &#39;&#39;&#39; CoR = Center of Rotation (usually the rocket&#39;s CG) &#39;&#39;&#39;
        # TODO: Check if there&#39;s an nice analytical solution to this integral

        # Eqn (3.57) from Niskanen, converted to vector form and integrated numerically
        # Numerical integration: Divide body tube into segments
            # Works for body tubes in any position, rotating on any axis
        dL = self.length / nSegments
        dA = dL * self.outerDiameter
        totalDampingMoment = Vector(0,0,0)

        for i in range(nSegments):
            # Center of current segment of body tube
            segmentCentroid = self.position + Vector(0,0, -dL*i - dL/2)
            
            # Vector from center of rotation to segment centroid
            psi = segmentCentroid - CoR 

            # Velocity due to rotation is angular velocity cross distance (from center of rotation) vector
            segmentVelocity = rocketState.angularVelocity.crossProduct(psi)
            
            # Re-dimensionalizing coefficient required squared velocity - while preserving sign
            sqVel = Vector( segmentVelocity.X*abs(segmentVelocity.X), segmentVelocity.Y*abs(segmentVelocity.Y), \
                 segmentVelocity.Z*abs(segmentVelocity.Z) )

            # Moment is distance vector cross force vector
            dM = -psi.crossProduct(sqVel)
            totalDampingMoment += dM

        # All terms of the integral summation must be multiplied by this constant:
            # 1.1 is drag coefficient of a cylinder in crossflow
            # 1/2 and density are from re-dimensionalizing the coefficient
            # Outerdiameter is part of area calculation
        integrationConstantMultiple = (1.1/2)*environment.Density*dA
        totalDampingMoment *= integrationConstantMultiple

        return totalDampingMoment

    def getMaxDiameter(self):
        return self.outerDiameter

    def getRadius(self, _):
        return self.outerDiameter/2

    def plotShape(self):
        import matplotlib.pyplot as plt
        
        # Assume body tube is on the Z-axis
        tipZ = self.position.Z
        tailZ = tipZ - self.length
        radius = self.outerDiameter/2

        Xvals = []
        Yvals = []
        Xvals.append(tipZ)
        Yvals.append(radius) # top right

        Xvals.append(tipZ)
        Yvals.append(-radius) # bottom right

        Xvals.append(tailZ)
        Yvals.append(-radius) # bottom left 

        Xvals.append(tailZ)
        Yvals.append(radius) # top left

        Xvals.append(tipZ)
        Yvals.append(radius) # close the square
        plt.plot(Xvals, Yvals, color = &#39;k&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.BodyTube.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.BodyTube.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self):
    import matplotlib.pyplot as plt
    
    # Assume body tube is on the Z-axis
    tipZ = self.position.Z
    tailZ = tipZ - self.length
    radius = self.outerDiameter/2

    Xvals = []
    Yvals = []
    Xvals.append(tipZ)
    Yvals.append(radius) # top right

    Xvals.append(tipZ)
    Yvals.append(-radius) # bottom right

    Xvals.append(tailZ)
    Yvals.append(-radius) # bottom left 

    Xvals.append(tailZ)
    Yvals.append(radius) # top left

    Xvals.append(tipZ)
    Yvals.append(radius) # close the square
    plt.plot(Xvals, Yvals, color = &#39;k&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.EventTypes"><code class="flex name class">
<span>class <span class="ident">EventTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventTypes(Enum):
    Apogee = &#34;apogee&#34;
    AscendingThroughAltitude = &#34;ascendingThroughAltitude&#34;
    DescendingThroughAltitude = &#34;descendingThroughAltitude&#34;
    MotorBurnout = &#34;motorBurnout&#34;
    TimeReached = &#34;timeReached&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.EventTypes.Apogee"><code class="name">var <span class="ident">Apogee</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.EventTypes.AscendingThroughAltitude"><code class="name">var <span class="ident">AscendingThroughAltitude</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.EventTypes.DescendingThroughAltitude"><code class="name">var <span class="ident">DescendingThroughAltitude</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.EventTypes.MotorBurnout"><code class="name">var <span class="ident">MotorBurnout</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.Rocket.EventTypes.TimeReached"><code class="name">var <span class="ident">TimeReached</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.Fin"><code class="flex name class">
<span>class <span class="ident">Fin</span></span>
<span>(</span><span>componentDictReader, parentFinSet, spanwiseDirection, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a single fin in a FinSet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Fin(FixedMass):
    &#39;&#39;&#39; Represents a single fin in a FinSet &#39;&#39;&#39;

    def __init__(self, componentDictReader, parentFinSet, spanwiseDirection, rocket, stage):

        FixedMass.__init__(self, componentDictReader, rocket, stage)

        self.finSet = parentFinSet # type: FinSet
        &#39;&#39;&#39; Reference to the parent fin set &#39;&#39;&#39;

        self.spanSliceAreas = self.finSet.spanSliceAreas
        self.spanSliceRadii = self.finSet.spanSliceRadii
        self.sliceLEPositions = self.finSet.sliceLEPositions
        self.sliceLengths = self.finSet.sliceLengths

        self.finAngle = self.finSet.finAngle
        self.stallAngle = self.finSet.stallAngle

        self.span = self.finSet.span
        self.planformArea = self.finSet.planformArea
        self.midChordSweep = self.finSet.midChordSweep
        
        # Unit vector parallel to the fin&#39;s shaft and/or fin&#39;s spanwise direction, normal to the rocket&#39;s body tube
        self.spanwiseDirection = spanwiseDirection

        # Vector normal to the fin surface, in the X/Y Plane, when self.finAngle == 0
        self.undeflectedFinNormal = Vector(self.spanwiseDirection[1], -self.spanwiseDirection[0], 0)

        self.tipPosition = self.finSet.dZ_dSpan_LE_neg * self.span
        
        # Spanwise component of Center of Pressure (CP) location
        self.CPSpanWisePosition = self.spanwiseDirection*(self.finSet.MACYPos + self.finSet.bodyRadius)

    def _barrowmanAeroFunc(self, rocketState, time, environment, precomputedData, CG = Vector(0,0,0), finDeflectionAngle = None):
        &#39;&#39;&#39;
            Precomputed Data is a named tuple (PreComputedFinAeroData) which contains data/results from the parts of the fin aerodynamics calculation
                that are common to all fins in a FinSet (drag calculations mostly). These calculations are performed at the FinSet level.
            Only the parts of the Fin Aero Computation that change from fin to fin (normal force mostly, since different fins can have different angles of attack) are computed here
        &#39;&#39;&#39;
        Mach = AeroParameters.getMachNumber(rocketState, environment)
        dynamicPressure = AeroParameters.getDynamicPressure(rocketState, environment)

        if finDeflectionAngle == None:
            finDeflectionAngle = self.finAngle # Adjusted by parent finset during each timestep, when the FinSet is controlled

        # Unpack precomputedData
        airVelRelativeToFin, CPXPos, totalDragCoefficient = precomputedData

        #### Compute normal force-----------------------------------------------------------------------------------------------------------------
           
        # Find fin normal vector after fin deflection       
        finDeflectionRotation = Quaternion(axisOfRotation=self.spanwiseDirection, angle=radians(finDeflectionAngle))
        finNormal = finDeflectionRotation.rotate(self.undeflectedFinNormal)
        # Get the tangential velocity component vector, per unit radial distance from the rocket centerline
        rollAngVel = AngularVelocity(0, 0, rocketState.angularVelocity.Z)
        unitSpanTangentialAirVelocity = rollAngVel.crossProduct(self.spanwiseDirection)*(-1)
        
        def subsonicNormalForce(Mach): # Subsonic linear method
            tempBeta = AeroParameters.getBeta(Mach)
            CnAlpha = getFinCnAlpha_Subsonic_Barrowman(self.span, self.planformArea, tempBeta, self.midChordSweep)
            return getSubsonicFinNormalForce(airVelRelativeToFin, unitSpanTangentialAirVelocity, finNormal, self.spanwiseDirection, self.CPSpanWisePosition.length(), CnAlpha, self)

        def supersonicNormalForce(Mach): # Supersonic Busemann method
            gamma = AeroFunctions.getGamma()
            tempBeta = AeroParameters.getBeta(Mach)
            K1, K2, K3, Kstar = getBusemannCoefficients(Mach, tempBeta, gamma)

            # Mach Cone coords
            machAngle = asin(1/Mach)
            machCone_negZPerRadius = 1 / tan(machAngle)
            machConeEdgeZPos = []
            outerRadius = self.spanSliceRadii[-1]
            for i in range(len(self.spanSliceRadii)):
                machConeAtCurrentRadius = (outerRadius - self.spanSliceRadii[i])*machCone_negZPerRadius + self.tipPosition
                machConeEdgeZPos.append(machConeAtCurrentRadius)

            return getSupersonicFinNormalForce(airVelRelativeToFin, unitSpanTangentialAirVelocity, finNormal, machConeEdgeZPos, self.spanwiseDirection, self.CPSpanWisePosition.length(), K1, K2, K3, Kstar, self)

        if Mach &lt;= 0.8:
            normalForceMagnitude, finMoment = subsonicNormalForce(Mach)

        elif Mach &lt; 1.4:
            # Interpolate in transonic region
            # TODO: Do this with less function evaluations? Perhaps precompute AOA and Mach combinations and simply interpolate? Lazy precompute? Cython?
            x1, x2 = 0.8, 1.4 # Start, end pts of interpolated region
            dx = 0.001

            # Find normal force and derivative at start of interpolation interval
            f_x1, m_x1 = subsonicNormalForce(x1)
            f_x12, m_x12 = subsonicNormalForce(x1+dx)

            # Find normal force and derivative at end of interpolation interval
            f_x2, m_x2 = supersonicNormalForce(x2)
            f_x22, m_x22 = supersonicNormalForce(x2+dx)

            normalForceMagnitude = Interpolation.cubicInterp(Mach, x1, x2, f_x1, f_x2, f_x12, f_x22, dx)
            finMoment = Interpolation.cubicInterp(Mach, x1, x2, m_x1, m_x2, m_x12, m_x22, dx)
        else:
            normalForceMagnitude, finMoment = supersonicNormalForce(Mach)
             
        # Complete redimensionalization of normal force coefficients by multiplying by dynamic pressure
        # Direct the normal force along the fin&#39;s normal direction
        normalForce = normalForceMagnitude * dynamicPressure * finNormal
        finMoment *= dynamicPressure
                
        #### Get axial force-----------------------------------------------------------------------------------------------------------------------
        
        avgAOA = getFinSliceAngleOfAttack(self.spanSliceRadii[round(len(self.spanSliceAreas)/2)], airVelRelativeToFin, unitSpanTangentialAirVelocity, finNormal, self.spanwiseDirection, self.stallAngle) # Approximate average fin AOA
        totalAxialForceCoefficient = AeroFunctions.getDragToAxialForceFactor(avgAOA) * totalDragCoefficient
        axialForceMagnitude = totalAxialForceCoefficient * self.rocket.Aref * dynamicPressure
        axialForceDirection = self.spanwiseDirection.crossProduct(finNormal)
        axialForce = axialForceDirection*axialForceMagnitude
        
        #### Get CP Location ----------------------------------------------------------------------------------------------------------------------

        CPChordWisePosition = self.position - Vector(0, 0, CPXPos) # Ignoring the change in CP position due to fin deflection for now
        globalCP = self.CPSpanWisePosition + CPChordWisePosition

        #### Assemble total force moment system objects--------------------------------------------------------------------------------------------

        totalForce = normalForce + axialForce
        return ForceMomentSystem(totalForce, globalCP, moment=Vector(0, 0, finMoment)), globalCP

    def getAeroForce(self, rocketState, time, environment, CG, precomputedData):
        [ aeroForce, CP ] = self._barrowmanAeroFunc(rocketState, time, environment, precomputedData, CG)
        return aeroForce</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.Fin.finSet"><code class="name">var <span class="ident">finSet</span></code></dt>
<dd>
<div class="desc"><p>Reference to the parent fin set</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.Fin.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, rocketState, time, environment, CG, precomputedData)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAeroForce(self, rocketState, time, environment, CG, precomputedData):
    [ aeroForce, CP ] = self._barrowmanAeroFunc(rocketState, time, environment, precomputedData, CG)
    return aeroForce</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.FinSet"><code class="flex name class">
<span>class <span class="ident">FinSet</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Class represents a set of n identical fins, all at the same longitudinal location, arranged axisymmetrically. Fin orientations can be controlled by a <code><a title="MAPLEAF.GNC.ControlSystems.ControlSystem" href="../GNC/ControlSystems.html#MAPLEAF.GNC.ControlSystems.ControlSystem">ControlSystem</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FinSet(FixedMass, ActuatedSystem):
    &#39;&#39;&#39; Class represents a set of n identical fins, all at the same longitudinal location, arranged axisymmetrically. Fin orientations can be controlled by a `MAPLEAF.GNC.ControlSystems.ControlSystem` &#39;&#39;&#39;

    #### Initialization Functions ####
    def __init__(self, componentDictReader, rocket, stage):
        FixedMass.__init__(self, componentDictReader, rocket, stage)

        self.controlSystem = None   # Set by self.initializeActuators, if it is called by a control system being initialized ex: RocketControlSystem.__init__()
        self.actuatorList = None    # Set by self.initializeActuators, if it is called by a control system being initialized ex: RocketControlSystem.__init__()

        self.numFins = componentDictReader.getInt(&#34;numFins&#34;)
        self.firstFinAngle = componentDictReader.getFloat(&#34;firstFinAngle&#34;)

        # Set fin properties
        self.finAngle = componentDictReader.getFloat(&#34;finCantAngle&#34;)
        self.sweepAngle = math.radians(componentDictReader.getFloat(&#34;sweepAngle&#34;))
        self.rootChord = componentDictReader.getFloat(&#34;rootChord&#34;)
        self.tipChord = componentDictReader.getFloat(&#34;tipChord&#34;)
        self.span = componentDictReader.getFloat(&#34;span&#34;)
        self.surfaceRoughness = componentDictReader.tryGetFloat(&#34;surfaceRoughness&#34;, defaultValue=self.rocket.surfaceRoughness)
        self.thickness = componentDictReader.getFloat(&#34;thickness&#34;)
        self.numFinSpanSteps = componentDictReader.getInt(&#34;numFinSpanSlicesForIntegration&#34;)
        
        # Leading Edge properties
        self.leadingEdgeShape = componentDictReader.getString(&#34;LeadingEdge.shape&#34;)
        if self.leadingEdgeShape == &#34;Round&#34;:
            self.leadingEdgeRadius = componentDictReader.tryGetFloat(&#34;LeadingEdge.radius&#34;, defaultValue=self.thickness/100)
        elif self.leadingEdgeShape == &#34;Blunt&#34;:
            self.leadingEdgeThickness = componentDictReader.tryGetFloat(&#34;LeadingEdge.thickness&#34;, defaultValue=self.thickness)
        else:
            raise ValueError(&#34;ERROR: Leading edge shape: {} not implemented. Use &#39;Round&#39; or &#39;Blunt&#39;&#34;.format(self.leadingEdgeShape))

        # Trailing Edge properties
        self.trailingEdgeShape = componentDictReader.getString(&#34;TrailingEdge.shape&#34;)
        if self.trailingEdgeShape == &#34;Round&#34;:
            self.trailingEdgeRadius = componentDictReader.getFloat(&#34;TrailingEdge.radius&#34;)
        elif self.trailingEdgeShape == &#34;Blunt&#34;:
            self.trailingEdgeThickness = componentDictReader.getFloat(&#34;TrailingEdge.thickness&#34;)
        elif self.trailingEdgeShape != &#34;Tapered&#34;:
            raise ValueError(&#34;ERROR: Trailing edge shape: {} not implemented. Use &#39;Round&#39;, &#39;Blunt&#39;, or &#39;Tapered&#39;&#34;.format(self.trailingEdgeShape))

        # Common fin properties for all child fins
        self._precomputeGeometry()
        
        # Initialize all the child fins in the self.finList list
        self._initChildFins(componentDictReader, rocket, stage)

    def initializeActuators(self, controlSystem):
        self.controlSystem = controlSystem

        # Initialize an actuator model for each fin
        ActuatedSystem.__init__(self, self.numFins)

    def _precomputeGeometry(self):
        self._calculateSweepAngles()

        ### Compute Other Simple Properties ####
        self.planformArea = self.span * (self.tipChord + self.rootChord) / 2
        self.wettedArea = 2*self.planformArea
        self.aspectRatio = (2*self.span)**2/self.planformArea # Aspect ratio of the wing that would be created by reflecting the fin about its root chord (Fleeman/Niskanen)
        self.stallAngle = 15 * (1 + 1.1/self.aspectRatio) # Compute stall angle from Hoerner, &#39;Fluid Dynamic Lift&#39; for low aspect ratio wings

        # Get the body radius where the fin is mounted
        stageTopZ = self.stage.position.Z
        distanceFromTopOfStageToTopOfThisFinSet = stageTopZ - self.position.Z
        self.bodyRadius = self.stage.getRadius(distanceFromTopOfStageToTopOfThisFinSet)

        self._calculateInterferenceFactors()
        self._calculateMACProperties()
        self._splitFinsIntoSlices()

        self._precomputeSubsonicFinThicknessDrag()
        self._precomputeCPInterpolationPolynomial()
    
    def _calculateSweepAngles(self):
        &#39;&#39;&#39; Compute Trailing Edge (TE) and Mid Chord sweep angles &#39;&#39;&#39;
        LEtipChordBehindRootChord = self.span * math.tan(self.sweepAngle) # Z-distance the front of the tip chord is behind the front of the root chord
        TETipChordBehindRootChord = self.tipChord + LEtipChordBehindRootChord - self.rootChord # Z-distance the back of the tip chord is behind the back of the root chord

        if(TETipChordBehindRootChord == 0):
            self.trailingEdgeSweep = 0.0
        elif(TETipChordBehindRootChord &lt; 0):
            # Negative trailing edge sweep is a forward-swept rear
            self.trailingEdgeSweep = -1*math.atan2(abs(TETipChordBehindRootChord),self.span)
        else:
            self.trailingEdgeSweep = math.atan2(abs(TETipChordBehindRootChord), self.span)

        self.midChordSweep = (self.sweepAngle + self.trailingEdgeSweep) / 2

        self.dZ_dSpan_LE_neg = math.tan(self.sweepAngle) # -dZ/dSpan (leading edge slope)
        self.dZ_dSpan_TE_neg = math.tan(self.trailingEdgeSweep) # dZ/dSpan (trailing edge slope)

    def _calculateInterferenceFactors(self):
        # Interference w/ body tube
        # Accounts for additional normal forces generated by the fins, due to the presence of the rocket body
        # Niskanen Eqn 3.56, originally from Barrowman
        self.bodyOnFinInterferenceFactor = 1 + self.bodyRadius / (self.span + self.bodyRadius)

        # Interference b/w the fins
        # Niskanen Eqn 3.54, from MIL-HDBK-762
        # Accounts for reduced normal force generated by large numbers of fins in a group
        # Not expected to work well for more than 8 fins
        if self.numFins &lt;= 4:
            self.finNumberInterferenceFactor = 1.0
        elif self.numFins &lt;= 8:
            numberToFactorMap = {
                5: 0.948,
                6: 0.913,
                7: 0.854,
                8: 0.810,
            }
            self.finNumberInterferenceFactor = numberToFactorMap[self.finNumber]
        else:
            self.finNumberInterferenceFactor = 0.75

    def _calculateMACProperties(self):
        &#39;&#39;&#39; Calculates MAC Length, MACY, and MACX - Niskanen (Eqn. 3.30-3.32) &#39;&#39;&#39;
        def LEdgeAtY(y): # Leading Edge at y - where y is the spanwise coordinate
            return self.dZ_dSpan_LE_neg*y
                    
        numSpanSteps = round(self.span / 0.0001) # One step per 0.1 mm
        finSpanStep = self.span / numSpanSteps

        MACIntegralSum = 0
        MACYPosIntegralSum = 0
        XMACLeadingEdgeIntegralSum = 0
        for i in range(numSpanSteps):
            y = i * finSpanStep + finSpanStep/2
            MACIntegralSum += ((self.getChord(y)**2)*finSpanStep) # Eqn 3.30, integrated numerically
            MACYPosIntegralSum += y * (self.getChord(y) * finSpanStep) # Eqn 3.31, integrated numerically
            XMACLeadingEdgeIntegralSum += LEdgeAtY(y) * self.getChord(y)*finSpanStep # Eqn 3.32, integrated numerically

        # Save results
        self.MACLength = MACIntegralSum/self.planformArea
        self.MACYPos = MACYPosIntegralSum/self.planformArea
        self.XMACLeadingEdge = XMACLeadingEdgeIntegralSum/self.planformArea

    def _splitFinsIntoSlices(self):
        &#39;&#39;&#39; Precomputes fin area slices for normal force integration &#39;&#39;&#39;
        stepSize = self.span / self.numFinSpanSteps
        bodyRadius = self.bodyRadius
        
        self.spanSliceAreas = [] # Area of each slice, m^2
        self.spanSliceRadii = [] # Radius of the center of each slice, from the rocket centerline, m
        self.sliceLEPositions = [] # Z - Position of the LE at the center of the slice, from the tip of root chord
        self.sliceLengths = []

        for i in range(self.numFinSpanSteps):
            y = i*stepSize + stepSize*0.5

            self.spanSliceRadii.append(y + bodyRadius)
            self.spanSliceAreas.append(stepSize*self.getChord(y))
            self.sliceLEPositions.append(y * self.dZ_dSpan_LE_neg)
            self.sliceLengths.append(self.getChord(y))

    def _precomputeSubsonicFinThicknessDrag(self):
        &#39;&#39;&#39; Precompute the subsonic thickness drag coefficient (Barrowman Eqn 4-36) &#39;&#39;&#39;
        sigma = (self.aspectRatio/2) * (self.thickness / self.rootChord)**(1/3) # Barrowman Eqn 4-35 b
        CD_TT_star = 1.15 * (self.thickness/self.rootChord)**(5/3) * (1.61 + sigma - sqrt((sigma - 1.43)**2 + 0.578))
        
        # Get skin friction coefficient at Mach 1
        mach1State = copy.deepcopy(self.rocket.rigidBody.state)
        mach1State.velocity = Vector(0,0,340.3) # Get speed up around Mach 1
        environment = self.rocket.environment.getAirProperties(self.rocket.rigidBody.state.position, 0)
        CD_f_star = AeroFunctions.getSkinFrictionCoefficient(mach1State, environment, self.MACLength, 1.0, self.surfaceRoughness, self.rocket.fullyTurbulentBL)
        
        # Final result
        self.subsonicFinThicknessK = cos(self.midChordSweep)**2 + (((CD_TT_star/CD_f_star - 4*cos(self.midChordSweep)*(self.thickness/self.rootChord)) / (120 * cos(self.midChordSweep)**2 * (self.thickness/self.rootChord)**4))**2)**(1/3)

    def _precomputeCPInterpolationPolynomial(self):
        &#39;&#39;&#39; Precompute Interpolation polynomial coefficients for getCPXLocation function &#39;&#39;&#39;
        AR = self.aspectRatio
        f_2 = (AR * (3)**0.5 - 0.67) / (2 * (3)**0.5 * AR - 1)
        f_prime_2_t1 = (2 * (3)**-0.5 * AR) * (2 * AR * (3)**0.5 - 1) 
        f_prime_2_t2 = ((3)**0.5 * AR - 0.67) * (AR * 4 * (3)**-0.5)
        f_prime_2_denom = (2 * AR * (3)**0.5 -1)**2
        f_prime_2 = (f_prime_2_t1 - f_prime_2_t2) / f_prime_2_denom
        
        a_mat = [
                [0.5**5, 0.5**4, 0.5**3, 0.5**2, 0.5, 1],
                [5*(0.5)**4, 4*(0.5)**3, 3*(0.5)**2, 2*(0.5), 1, 0],
                [2**5, 2**4, 2**3, 2**2, 2, 1],
                [5*(2)**4, 4*(2)**3, 3*(2)**2, 2*2, 1, 0],
                [20*2**3, 12*2**2, 6*2, 2, 0, 0],
                [60*2**2, 24*2, 6, 0, 0, 0],
                ]
        
        b_vec = [0.25, 0, f_2, f_prime_2, 0, 0]
        
        # Save results
        self.x = np.linalg.solve(a_mat, b_vec)   

    def _initChildFins(self, componentDictReader, rocket, stage):
        self.finList = []
        
        finSeparationAngle = 360/self.numFins
        firstFinAngle = self.firstFinAngle

        # Create child fins
        for i in range(self.numFins):
            # Figure out what direction the fin points in
            spanwiseUnitX = math.cos(math.radians(firstFinAngle + i*finSeparationAngle))
            spanwiseUnitY = math.sin(math.radians(firstFinAngle + i*finSeparationAngle))
            spanWiseDirection = Vector(spanwiseUnitX, spanwiseUnitY, 0)

            #Initialize each fin separately and keep in a list
            self.finList.append(Fin(componentDictReader, self, spanWiseDirection, rocket, stage))

    def getLogHeader(self):
        header = &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)
        
        if self.controlSystem != None:
            for finNumber in range(1, self.numFins+1):
                header += &#34; {}Fin{}Angle(deg)&#34;.format(self.name, finNumber)

        return header

    ### Functions used during simulation ###
    def getAeroForce(self, rocketState, time, environment, CG):
        #### If control system exists, use actuator deflections 1:1 to set fin angles ####
        if self.controlSystem != None:
            # Update fin angles
            for i in range(self.numFins):
                self.finList[i].finAngle = self.actuatorList[i].getDeflection(time)

        #### Pre-calculate common properties for all child Fins ####
        precomputedData = self._getPreComputedFinAeroData(rocketState, environment, CG)

        #### Add up forces from all child Fins ####
        aeroForce = ForceMomentSystem(Vector(0,0,0), self.position)
        for fin in self.finList:
            aeroForce += fin.getAeroForce(rocketState, time, environment, CG, precomputedData)

        # TODO: Correct for sub/transonic rolling moment fin-fin interference from a high number of fins
        
        # Apply fin-body interference factor to total forces in the normal (X/Y) directions and moments
        totalInterferenceFactor = self.bodyOnFinInterferenceFactor * self.finNumberInterferenceFactor
        aeroForce.force.X *= totalInterferenceFactor
        aeroForce.force.Y *= totalInterferenceFactor
        aeroForce.moment.X *= totalInterferenceFactor
        aeroForce.moment.Y *= totalInterferenceFactor          

        #### Log results ####
        forceLogLine = &#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment)
        if self.controlSystem != None:
            for i in range(len(self.actuatorList)):
                forceLogLine += &#34; {:&gt;6.4}&#34;.format(self.finList[i].finAngle)
        self.rocket.appendToForceLogLine(forceLogLine)

        return aeroForce

    def _getPreComputedFinAeroData(self, rocketState, environment, CG):
        #General Info ---------------------------------------------------------------------------------------------------------------------
        Aref = self.rocket.Aref
        Mach = AeroParameters.getMachNumber(rocketState, environment)
        dynamicPressure = AeroParameters.getDynamicPressure(rocketState, environment)

        # Skin Friction Drag -------------------------------------------------------------------------------------------------------------
        
        skinFrictionCoefficient = AeroFunctions.getSkinFrictionCoefficient(rocketState, environment, self.MACLength, Mach, self.surfaceRoughness, self.rocket.fullyTurbulentBL)    
        # Adjust to the rocket reference area (skinFrictionCoefficient is based on wetted area)
        skinFrictionDragCoefficient = skinFrictionCoefficient*(self.wettedArea / Aref)
        # Correct for additional surface area due to fin thickness - Niskanen Eqn 3.85
        skinFrictionDragCoefficient *= (1 + 2*self.thickness/self.MACLength)
        
        # Pressure Drag ------------------------------------------------------------------------------------------------------------------

        # Leading edge drag coefficient
        if self.leadingEdgeShape == &#34;Round&#34;:
            leadingEdgeCd = AeroFunctions.getCylinderCrossFlowCd_ZeroBaseDrag(Mach)
            LEthickness = self.leadingEdgeRadius*2
        elif self.leadingEdgeShape == &#34;Blunt&#34;:
            leadingEdgeCd = AeroFunctions.getBluntBodyCd_ZeroBaseDrag(Mach)
            LEthickness = self.leadingEdgeThickness

        # Adjust for leading edge angle and convert reference area to rocket reference area - Barrowman Eqn 4-22
        leadingEdgeCdAdjustmentFactor = LEthickness * self.span * cos(self.sweepAngle)**2 / Aref
        leadingEdgeCd *= leadingEdgeCdAdjustmentFactor
            
        # Trailing edge drag coefficient - simpler method from Niskanen section 3.4.4. Corrected to use only the trailing edge area, not the full fin frontal area
            # more intricate method available in Barrowman
        baseDragCd = AeroFunctions.getBaseDragCoefficient(Mach)
        if self.trailingEdgeShape == &#34;Tapered&#34;:
            TEthickness = 0 # Zero base drag
        elif self.trailingEdgeShape == &#34;Round&#34;:
            TEthickness = self.trailingEdgeRadius # 0.5 base drag
        elif self.trailingEdgeShape == &#34;Blunt&#34;:
            TEthickness = self.trailingEdgeThickness # Full base drag
        
        # Convert to standard rocket reference Area
        trailingEdgeCd = baseDragCd * self.span*TEthickness/Aref

        # Thickness / Wave Drag
        #TODO: This section doesn&#39;t seem to be working quite right
        if Mach &lt;= 1:
            # Thickness drag, subsonic
            thicknessDrag = 4*skinFrictionCoefficient*((self.thickness/self.rootChord)*cos(self.midChordSweep) + \
                (30 * (self.thickness/self.rootChord)**4 * cos(self.midChordSweep)**2) /  \
                    (self.subsonicFinThicknessK - Mach**2 * cos(self.midChordSweep)**2)**(3/2))
        else:
            # Supersonic wave drag
            # Using simplistic method from Hoerner - assumes diamond profile (pg 17-12, Eqn 29)
            # TODO: Implement method from Barrowman&#39;s FIN program
            thicknessDrag = 2.3*self.aspectRatio * (self.thickness / self.MACLength)**2

        thicknessDrag *= self.planformArea/Aref

        pressureDragCoefficient = leadingEdgeCd + trailingEdgeCd + thicknessDrag
                        
        # Total Drag --------------------------------------------------------------------------------------------------------------------
        
        totalDragCoefficient = pressureDragCoefficient + skinFrictionDragCoefficient

        localFrameRocketVelocity = AeroParameters.getLocalFrameAirVel(rocketState, environment)
        axialPositionRelCG = self.position - CG
        finVelocityDueToRocketPitchYaw = rocketState.angularVelocity.crossProduct(axialPositionRelCG) 
        airVelRelativeToFin = localFrameRocketVelocity - finVelocityDueToRocketPitchYaw # The negative puts it in the wind frame
        CPXPos = self._getCPXPos(Mach)

        #### Transfer info to fins ####
        return PreComputedFinAeroData(airVelRelativeToFin, CPXPos, totalDragCoefficient)

    def _getCPXPos(self, Mach):
        &#39;&#39;&#39; 
            Finds the chordwise position of the center of pressure, relative to the tip of the root chord (self.position) 
            Methods from Tactical missile design by Fleeman through Niskanen
        &#39;&#39;&#39;
        if Mach &lt; 0.5:
            XF = self.XMACLeadingEdge + 0.25*self.MACLength #As per open rocket documentation

        elif Mach &gt;= 2.0:
            beta = AeroParameters.getBeta(Mach)
            CPCalc = lambda AR, B : (AR*B - 0.67) / (2*AR*B - 1) #Eq 3.35 of open rocket documentation (greater than M = 2)
            XF = self.MACLength*CPCalc(self.aspectRatio, beta) + self.XMACLeadingEdge #As per open rocket documentation

        else:
            #Between the two extremes is a polynomial curve fit
            #Fifth order polynomial fit as per Niskanen Eqn 3.36 (Originally from Fleeman)
                # Old code: XF = np.polyval(self.x, Mach)*self.MACLength + self.XMACLeadingEdge
                # Evaluate polynomial manually for maximum speed (8.5x improvement for 6 coeffs)
                    # Speed test in test/speedTests/PolyvalSpeed.py
            polyval = 0
            nTerms = len(self.x)
            for i in range(nTerms):
                polyval += self.x[i]*Mach**(nTerms-1-i)

            XF = polyval*self.MACLength + self.XMACLeadingEdge # Polyval defines the fraction of the MAC that the Cp is behind the leading edge

        return XF

    def getChord(self, y):
        &#39;&#39;&#39; Returns chord at y, where y==0 is at the root chord, and y==span is at the tip chord &#39;&#39;&#39;
        return (self.tipChord - self.rootChord) * (y/self.span) + self.rootChord

    def plotShape(self):
        import matplotlib.pyplot as plt

        BodyTubeDiameter = self.bodyRadius*2
        SubComponentPos = self.position.Z
        span = self.span
        rootChord = self.rootChord
        tipChord = self.tipChord
        sweepAngle = self.sweepAngle
        Xvals = []
        Yvals = []
        Xvals.append(SubComponentPos)
        Yvals.append(BodyTubeDiameter/2)
        Xvals.append(Xvals[0]-span*math.tan(sweepAngle))
        Yvals.append(Yvals[0]+span)
        Xvals.append(Xvals[1]-tipChord)
        Yvals.append(Yvals[1])
        Xvals.append(Xvals[0]-rootChord)
        Yvals.append(Yvals[0])
        Xvals.append(Xvals[0])
        Yvals.append(Yvals[0])
        plt.plot(Xvals,Yvals, color = &#39;k&#39;)

        if self.numFins == 4:
            Yvals = [-1*i for i in Yvals]
            plt.plot(Xvals,Yvals, color = &#39;k&#39;)
            Yvals = [0*i for i in Yvals]
            plt.plot(Xvals,Yvals, color = &#39;k&#39;)

        elif self.numFins == 3:
            Yvals = []
            Yvals.append(-BodyTubeDiameter/2*math.sin(math.radians(30)))
            Yvals.append(-(BodyTubeDiameter/2 + span)*math.sin(math.radians(30)))
            Yvals.append(Yvals[1])
            Yvals.append(Yvals[0])
            Yvals.append(Yvals[0])
            plt.plot (Xvals, Yvals, color = &#39;k&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li><a title="MAPLEAF.GNC.actuatedSystem.ActuatedSystem" href="../GNC/actuatedSystem.html#MAPLEAF.GNC.actuatedSystem.ActuatedSystem">ActuatedSystem</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.FinSet.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, rocketState, time, environment, CG)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAeroForce(self, rocketState, time, environment, CG):
    #### If control system exists, use actuator deflections 1:1 to set fin angles ####
    if self.controlSystem != None:
        # Update fin angles
        for i in range(self.numFins):
            self.finList[i].finAngle = self.actuatorList[i].getDeflection(time)

    #### Pre-calculate common properties for all child Fins ####
    precomputedData = self._getPreComputedFinAeroData(rocketState, environment, CG)

    #### Add up forces from all child Fins ####
    aeroForce = ForceMomentSystem(Vector(0,0,0), self.position)
    for fin in self.finList:
        aeroForce += fin.getAeroForce(rocketState, time, environment, CG, precomputedData)

    # TODO: Correct for sub/transonic rolling moment fin-fin interference from a high number of fins
    
    # Apply fin-body interference factor to total forces in the normal (X/Y) directions and moments
    totalInterferenceFactor = self.bodyOnFinInterferenceFactor * self.finNumberInterferenceFactor
    aeroForce.force.X *= totalInterferenceFactor
    aeroForce.force.Y *= totalInterferenceFactor
    aeroForce.moment.X *= totalInterferenceFactor
    aeroForce.moment.Y *= totalInterferenceFactor          

    #### Log results ####
    forceLogLine = &#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment)
    if self.controlSystem != None:
        for i in range(len(self.actuatorList)):
            forceLogLine += &#34; {:&gt;6.4}&#34;.format(self.finList[i].finAngle)
    self.rocket.appendToForceLogLine(forceLogLine)

    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FinSet.getChord"><code class="name flex">
<span>def <span class="ident">getChord</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns chord at y, where y==0 is at the root chord, and y==span is at the tip chord</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getChord(self, y):
    &#39;&#39;&#39; Returns chord at y, where y==0 is at the root chord, and y==span is at the tip chord &#39;&#39;&#39;
    return (self.tipChord - self.rootChord) * (y/self.span) + self.rootChord</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FinSet.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    header = &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)
    
    if self.controlSystem != None:
        for finNumber in range(1, self.numFins+1):
            header += &#34; {}Fin{}Angle(deg)&#34;.format(self.name, finNumber)

    return header</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FinSet.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self):
    import matplotlib.pyplot as plt

    BodyTubeDiameter = self.bodyRadius*2
    SubComponentPos = self.position.Z
    span = self.span
    rootChord = self.rootChord
    tipChord = self.tipChord
    sweepAngle = self.sweepAngle
    Xvals = []
    Yvals = []
    Xvals.append(SubComponentPos)
    Yvals.append(BodyTubeDiameter/2)
    Xvals.append(Xvals[0]-span*math.tan(sweepAngle))
    Yvals.append(Yvals[0]+span)
    Xvals.append(Xvals[1]-tipChord)
    Yvals.append(Yvals[1])
    Xvals.append(Xvals[0]-rootChord)
    Yvals.append(Yvals[0])
    Xvals.append(Xvals[0])
    Yvals.append(Yvals[0])
    plt.plot(Xvals,Yvals, color = &#39;k&#39;)

    if self.numFins == 4:
        Yvals = [-1*i for i in Yvals]
        plt.plot(Xvals,Yvals, color = &#39;k&#39;)
        Yvals = [0*i for i in Yvals]
        plt.plot(Xvals,Yvals, color = &#39;k&#39;)

    elif self.numFins == 3:
        Yvals = []
        Yvals.append(-BodyTubeDiameter/2*math.sin(math.radians(30)))
        Yvals.append(-(BodyTubeDiameter/2 + span)*math.sin(math.radians(30)))
        Yvals.append(Yvals[1])
        Yvals.append(Yvals[0])
        Yvals.append(Yvals[0])
        plt.plot (Xvals, Yvals, color = &#39;k&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.GNC.actuatedSystem.ActuatedSystem" href="../GNC/actuatedSystem.html#MAPLEAF.GNC.actuatedSystem.ActuatedSystem">ActuatedSystem</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.GNC.actuatedSystem.ActuatedSystem.initializeActuators" href="../GNC/actuatedSystem.html#MAPLEAF.GNC.actuatedSystem.ActuatedSystem.initializeActuators">initializeActuators</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.FixedForce"><code class="flex name class">
<span>class <span class="ident">FixedForce</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for rocket components </p>
<p>A Zero-inertia component that applies a constant ForceMomentSystem to the rocket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FixedForce(RocketComponent):
    def __init__(self, componentDictReader, rocket, stage):
        &#39;&#39;&#39; A Zero-inertia component that applies a constant ForceMomentSystem to the rocket &#39;&#39;&#39;
        self.componentDictReader = componentDictReader
        self.rocket = rocket
        self.stage = stage
        self.name = componentDictReader.getDictName()

        # Object is just a force, inertia is zero
        self.inertia = Inertia(Vector(0,0,0), Vector(0,0,0), 0)

        force = componentDictReader.getVector(&#34;force&#34;)
        forceLocation = componentDictReader.getVector(&#34;position&#34;)
        moment = componentDictReader.getVector(&#34;moment&#34;)

        self.force = ForceMomentSystem(force, forceLocation, moment)
        
    def getInertia(self, time, state):
        return self.inertia

    @logForceResult
    def getAeroForce(self, rocketState, time, environment, rocketCG):
        return self.force

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.FixedForce.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FixedForce.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    return self.inertia</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FixedForce.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.FixedMass"><code class="flex name class">
<span>class <span class="ident">FixedMass</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all fixed-mass rocket components
Implements functionality to read/store inertia and position info from sim definition file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FixedMass(RocketComponent):
    &#39;&#39;&#39;
        Base class for all fixed-mass rocket components
        Implements functionality to read/store inertia and position info from sim definition file
    &#39;&#39;&#39;
    def __init__(self, componentDictReader, rocket, stage):
        self.rocket = rocket
        self.stage = stage
        self.componentDictReader = componentDictReader
        self.name = componentDictReader.getDictName()
            
        mass = componentDictReader.getFloat(&#34;mass&#34;)

        # Position in simulation definition is relative to stage position
        self.position = componentDictReader.getVector(&#34;position&#34;) + stage.position # Store position relative to nosecone here
        # CG in simulation definition is relative to component position
        cg = componentDictReader.getVector(&#34;cg&#34;) + self.position  # Store cg location relative to nosecone here

        try:
            MOI = componentDictReader.getVector(&#34;MOI&#34;)
        except:
            MOI = Vector(mass*0.01, mass*0.01, mass*0.01) # Avoid having zero moments of inertia

        self.inertia = Inertia(MOI, cg, mass)
        self.zeroForce = ForceMomentSystem(Vector(0,0,0))

    def getInertia(self, time, state):
        return self.inertia

    def getMass(self, time):
        return self.inertia.mass

    def getCG(self, time):
        return self.inertia.CG

    def getAeroForce(self, rocketState, time, environment, CG):
        return self.zeroForce</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.Fins.Fin" href="Fins.html#MAPLEAF.Rocket.Fins.Fin">Fin</a></li>
<li><a title="MAPLEAF.Rocket.Fins.FinSet" href="Fins.html#MAPLEAF.Rocket.Fins.FinSet">FinSet</a></li>
<li><a title="MAPLEAF.Rocket.Recovery.RecoverySystem" href="Recovery.html#MAPLEAF.Rocket.Recovery.RecoverySystem">RecoverySystem</a></li>
<li><a title="MAPLEAF.Rocket.boatTail.Transition" href="boatTail.html#MAPLEAF.Rocket.boatTail.Transition">Transition</a></li>
<li><a title="MAPLEAF.Rocket.bodyTube.BodyTube" href="bodyTube.html#MAPLEAF.Rocket.bodyTube.BodyTube">BodyTube</a></li>
<li><a title="MAPLEAF.Rocket.noseCone.NoseCone" href="noseCone.html#MAPLEAF.Rocket.noseCone.NoseCone">NoseCone</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.FixedMass.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, rocketState, time, environment, CG)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAeroForce(self, rocketState, time, environment, CG):
    return self.zeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FixedMass.getCG"><code class="name flex">
<span>def <span class="ident">getCG</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCG(self, time):
    return self.inertia.CG</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FixedMass.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    return self.inertia</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FixedMass.getMass"><code class="name flex">
<span>def <span class="ident">getMass</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMass(self, time):
    return self.inertia.mass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.FractionalJetDamping"><code class="flex name class">
<span>class <span class="ident">FractionalJetDamping</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>A component to model Jet damping as per NASA's Two Stage to Orbit verification case</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FractionalJetDamping(RocketComponent):
    &#39;&#39;&#39; A component to model Jet damping as per NASA&#39;s Two Stage to Orbit verification case &#39;&#39;&#39;

    # Object is just a force, inertia is zero
    inertia = Inertia(Vector(0,0,0), Vector(0,0,0), 0)

    def __init__(self, componentDictReader, rocket, stage):
        self.rocket = rocket
        self.stage = stage
        self.componentDictReader = componentDictReader
        self.name = componentDictReader.getDictName()
        
        self.dampingFraction = componentDictReader.getFloat(&#34;fraction&#34;)

    @logForceResult
    def getAeroForce(self, rocketState, time, environmentalConditions, rocketCG):
        # Only apply damping force if current stage&#39;s engine is firing
            # (Other stage&#39;s motors will have different exit planes)
        if time &gt; self.stage.motor.ignitionTime and time &lt; self.stage.engineShutOffTime:
            currentRocketInertia = self.rocket.getInertia(time, rocketState)
            
            # Differentiate rate of MOI change
            dt = 0.001
            nextRocketInertia = self.rocket.getInertia(time+dt, rocketState)            
            MOIChangeRate = (currentRocketInertia.MOI.X - nextRocketInertia.MOI.X) / dt

            dampingFactor = MOIChangeRate * self.dampingFraction
            
            angVel = rocketState.angularVelocity
            dampingMoment = Vector(-angVel.X*dampingFactor, -angVel.Y*dampingFactor, 0)

            return ForceMomentSystem(Vector(0,0,0), moment=dampingMoment)
        else:
            return ForceMomentSystem(Vector(0,0,0))

    def getInertia(self, time, state):
        return self.inertia

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.FractionalJetDamping.inertia"><code class="name">var <span class="ident">inertia</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.FractionalJetDamping.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FractionalJetDamping.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    return self.inertia</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.FractionalJetDamping.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone"><code class="flex name class">
<span>class <span class="ident">NoseCone</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent a Tangent Ogive Nosecone</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoseCone(FixedMass, BodyComponent):
    &#39;&#39;&#39; Represent a Tangent Ogive Nosecone &#39;&#39;&#39;

    canConnectToComponentAbove = False # Overrides attribute from BodyComponent -&gt; Nosecone must be at top of rocket

    #### Initialization Functions ####
    def __init__(self, componentDictReader, rocket, stage):
        FixedMass.__init__(self, componentDictReader, rocket, stage)
        
        self.aspectRatio = componentDictReader.getFloat(&#34;aspectRatio&#34;)
        &#39;&#39;&#39; Length over diameter - aka fineness ratio (of exposed surface area) &#39;&#39;&#39;

        self.baseDiameter = componentDictReader.getFloat(&#34;baseDiameter&#34;)
        &#39;&#39;&#39; Diameter at base of nosecone (m) &#39;&#39;&#39;

        self.length = self.aspectRatio * self.baseDiameter
        &#39;&#39;&#39; Length from tip to tail, of external surface (m) &#39;&#39;&#39;

        self.shape = componentDictReader.getString(&#34;shape&#34;)
        &#39;&#39;&#39; Description of nosecone shape - something like &#39;Ogive&#39; or &#39;Cone&#39; &#39;&#39;&#39;
        
        self.surfaceRoughness = componentDictReader.tryGetFloat(&#34;surfaceRoughness&#34;, defaultValue=self.rocket.surfaceRoughness)
        &#39;&#39;&#39; (m) &#39;&#39;&#39;

        self._precomputeGeometry()

    def _precomputeGeometry(self):
        self.length = self.baseDiameter * self.aspectRatio
        self.volume = self._getVolume()
        self.planformArea = self._getPlanformArea()
        self.wettedArea = self._getWettedArea()

        # Using Barrowman&#39;s method, the CP Location is a constant
        self.baseArea = self.baseDiameter**2 * math.pi / 4
        self.CPLocation = AeroFunctions.Barrowman_GetCPLocation(self.length, 0, self.baseArea, self.volume)

        # Precompute coefficients for pressure drag interpolation-------------------------------------------        
        #  Niskanen 3.4 and Appendix B
        self.coneHalfAngle = abs(math.atan((self.baseDiameter/2) / self.length))

        self.SubsonicCdPolyCoeffs = computeSubsonicPolyCoeffs(self.coneHalfAngle)
        self.TransonicCdPolyCoeffs = computeTransonicPolyCoeffs(self.coneHalfAngle)

    def _getVolume(self):

        if self.shape == &#34;tangentOgive&#34;:
            #https://www.rocketryforum.com/attachments/nosecone_eqn2-pdf.336812/
            baseRadius = self.baseDiameter / 2
            length = self.baseDiameter * self.aspectRatio

            noseconeRadiusOfCurvature = (baseRadius**2 + length**2) / (2*baseRadius)
        
            return math.pi * ( length * noseconeRadiusOfCurvature**2 - length**3 / 3 - (noseconeRadiusOfCurvature - baseRadius) * 
                noseconeRadiusOfCurvature**2 * (math.asin(length / noseconeRadiusOfCurvature)))
        
        elif self.shape == &#34;cone&#34;:
            return math.pi * (self.baseDiameter)**2 * self.length / 3

        elif self.shape == &#34;halfSeries&#34;:
            #https://www.rocketryforum.com/attachments/nosecone_eqn2-pdf.336812/
            baseRadius = self.baseDiameter / 2
            length = self.baseDiameter * self.aspectRatio

            return math.pi * baseRadius**2 * length / 2

        else:
            raise TypeError(&#34;The nosecone shape {} is not recognized&#34;.format(self.shape))

    def _getPlanformArea(self):

        if self.shape == &#34;tangentOgive&#34;:
            baseRadius = self.baseDiameter / 2
            length = self.baseDiameter * self.aspectRatio

            noseconeRadiusOfCurvature = (baseRadius**2 + length**2) / (2*baseRadius)

            arcSectorAngle = math.asin(length / noseconeRadiusOfCurvature)
          
            arcSectorArea = arcSectorAngle * noseconeRadiusOfCurvature**2 / 2

            return 2 * (arcSectorArea - (length * (noseconeRadiusOfCurvature - baseRadius) / 2))

        elif self.shape == &#34;cone&#34;:
            return self.baseDiameter * self.length / 2

        else:
            raise TypeError(&#34;The nosecone shape {} is not recognized&#34;.format(self.shape))

    def _getWettedArea(self):

        if self.shape == &#34;tangentOgive&#34;:
            #TODO Analytical Solution: https://www.rocketryforum.com/attachments/nosecone_eqn2-pdf.336812/
            baseRadius = self.baseDiameter / 2
            length = self.baseDiameter * self.aspectRatio

            noseconeRadiusOfCurvature = (baseRadius**2 + length**2) / (2*baseRadius)
            a = noseconeRadiusOfCurvature

            numSteps = 2000
            stepSize = length / numSteps
            wettedArea = 0

            for x in range(numSteps + 1):
                wettedArea += 2 * math.pi * ((math.sqrt(a**2 - (length - x*stepSize)**2)) + baseRadius - a) * stepSize

            return wettedArea

        elif self.shape == &#34;cone&#34;:
            baseRad = self.baseDiameter/2
            return math.pi * baseRad * math.sqrt(baseRad**2 + self.length**2)

        else:
            raise TypeError(&#34;The nosecone shape {} is not recognized&#34;.format(self.shape))

    #### Operation Functions ####
    @logForceResult
    def getAeroForce(self, rocketState, time, environment, CG):
        Aref = self.rocket.Aref
        Mach = AeroParameters.getMachNumber(rocketState, environment)

        # Normal Force --------------------------------------------------------------------------------
        # TODO: Account for rate of pitch/yaw rotation in AOA calculation? Or do separate Pitch/Yaw damping moments?
        AOA = AeroParameters.getTotalAOA(rocketState, environment)
        normalForceCoefficient = AeroFunctions.Barrowman_GetCN(AOA, Aref, 0, self.baseArea)

        # Drag Force ---------------------------------------------------------------------------------------------
        #### Skin Friction ####
        skinFrictionDragCoefficient, rollDampingMoment = AeroFunctions.getCylindricalSkinFrictionDragCoefficientAndRollDampingMoment(rocketState, environment, self.length, Mach,  \
            self.surfaceRoughness, self.wettedArea, Aref, self.rocket.finenessRatio, self.rocket.fullyTurbulentBL)
        
        #### Pressure ####
        pressureDragCoefficient = self._getCd_Pressure(Mach)

        totalDragCoefficient = pressureDragCoefficient + skinFrictionDragCoefficient

        # Damping moments --------------------------------------------------------------------------------------
        # Roll damping due to skin friction
        dampingMoments = rollDampingMoment

        # Combine forces and return total -------------------------------------------------------------------------------------
        return AeroFunctions.forceFromCdCN(rocketState, environment, totalDragCoefficient, normalForceCoefficient, self.CPLocation, Aref, moment=dampingMoments)

    def _getCd_Pressure(self, Mach):
        if Mach &lt; 1:
            # Niskanen pg. 48 eq. 3.87 - Power law interpolation
            pressureDragCoefficient = self.SubsonicCdPolyCoeffs[0] * Mach**self.SubsonicCdPolyCoeffs[1]

        elif Mach &gt; 1 and Mach &lt; 1.3:
            # Interpolate in transonic region - derived from Niskanen Appendix B, Eqns B.3 - B.6
            pressureDragCoefficient = self.TransonicCdPolyCoeffs[0] + self.TransonicCdPolyCoeffs[1]*Mach +  \
                self.TransonicCdPolyCoeffs[2]*Mach**2 + self.TransonicCdPolyCoeffs[3]*Mach**3
            
        else:
            pressureDragCoefficient = getSupersonicPressureDragCoeff_Hoerner(self.coneHalfAngle, Mach)

        return pressureDragCoefficient * self.baseArea/self.rocket.Aref

    def getMaxDiameter(self):
        return self.baseDiameter

    def getRadius(self, distanceFromTip: float) -&gt; float:
        if self.shape == &#34;cone&#34;:
            return (self.baseDiameter/2) * (distanceFromTip/self.length)

        elif self.shape == &#34;tangentOgive&#34;:
            curveRadius = ((self.baseDiameter/2)**2 + self.length**2) / (self.baseDiameter)
            yComponent = math.sqrt(curveRadius**2 - (self.length - distanceFromTip)**2)
            return yComponent - (curveRadius - (self.baseDiameter/2))

    def plotShape(self) -&gt; None:
        import matplotlib.pyplot as plt
        
        SubComponentPos = self.position.Z
        length = self.baseDiameter * self.aspectRatio
        ConeRad = self.baseDiameter/2
        Rho = (ConeRad**2 + length**2)/(2*ConeRad) # values for tangent ogive equation
        Xvals = list(np.linspace(0,length, num=100)) # create 50 element tuple from 0 to length

        Yvals = [] # create y list

        for x in Xvals:
            # populate y list
            Yvals.append(self.getRadius(x))
        
        Xvals = [-1*i + SubComponentPos for i in Xvals] # these were positive. Need them to be negative to point correct way

        # top line, body tube to tip
        XvalsTop = list(Xvals) 
        YvalsTop = list(Yvals)
        XvalsTop.reverse()
        YvalsTop.reverse()

        # bottom line, tip to body tube
        XvalsBot = list(Xvals)
        YvalsBot = list(Yvals)
        YvalsBot = [-1*i for i in YvalsBot] # so the yvals are negative

        # put it all together now
        Xvals = XvalsTop + XvalsBot
        Yvals = YvalsTop + YvalsBot
        plt.plot(Xvals,Yvals, color = &#39;k&#39;)                 </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.NoseCone.canConnectToComponentAbove"><code class="name">var <span class="ident">canConnectToComponentAbove</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.NoseCone.aspectRatio"><code class="name">var <span class="ident">aspectRatio</span></code></dt>
<dd>
<div class="desc"><p>Length over diameter - aka fineness ratio (of exposed surface area)</p></div>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone.baseDiameter"><code class="name">var <span class="ident">baseDiameter</span></code></dt>
<dd>
<div class="desc"><p>Diameter at base of nosecone (m)</p></div>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Length from tip to tail, of external surface (m)</p></div>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>Description of nosecone shape - something like 'Ogive' or 'Cone'</p></div>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone.surfaceRoughness"><code class="name">var <span class="ident">surfaceRoughness</span></code></dt>
<dd>
<div class="desc"><p>(m)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.NoseCone.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.NoseCone.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self) -&gt; None:
    import matplotlib.pyplot as plt
    
    SubComponentPos = self.position.Z
    length = self.baseDiameter * self.aspectRatio
    ConeRad = self.baseDiameter/2
    Rho = (ConeRad**2 + length**2)/(2*ConeRad) # values for tangent ogive equation
    Xvals = list(np.linspace(0,length, num=100)) # create 50 element tuple from 0 to length

    Yvals = [] # create y list

    for x in Xvals:
        # populate y list
        Yvals.append(self.getRadius(x))
    
    Xvals = [-1*i + SubComponentPos for i in Xvals] # these were positive. Need them to be negative to point correct way

    # top line, body tube to tip
    XvalsTop = list(Xvals) 
    YvalsTop = list(Yvals)
    XvalsTop.reverse()
    YvalsTop.reverse()

    # bottom line, tip to body tube
    XvalsBot = list(Xvals)
    YvalsBot = list(Yvals)
    YvalsBot = [-1*i for i in YvalsBot] # so the yvals are negative

    # put it all together now
    Xvals = XvalsTop + XvalsBot
    Yvals = YvalsTop + YvalsBot
    plt.plot(Xvals,Yvals, color = &#39;k&#39;)                 </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.PlanarInterface"><code class="flex name class">
<span>class <span class="ident">PlanarInterface</span></span>
<span>(</span><span>location:Â <a title="MAPLEAF.Motion.CythonVector.Vector" href="../Motion/CythonVector.html#MAPLEAF.Motion.CythonVector.Vector">Vector</a>, component1:Â <a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a>, component2:Â <a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a>, planeNormal=&lt;MAPLEAF.Motion.CythonVector.Vector object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a planar interface between two components<br>
In the local frame, the normalVector is expected to point across the interface from component1 to component2 <br>
In a rocket, this means that (with the default normalVector pointing in the -'ve Z direction (towards the tail)), component1 is above component2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlanarInterface():
    def __init__(self, location: Vector, component1: RocketComponent, component2: RocketComponent, planeNormal=Vector(0,0,-1)):
        &#39;&#39;&#39; 
            Defines a planar interface between two components  
            In the local frame, the normalVector is expected to point across the interface from component1 to component2   
            In a rocket, this means that (with the default normalVector pointing in the -&#39;ve Z direction (towards the tail)), component1 is above component2   
        &#39;&#39;&#39;
        self.location = location
        self.component1 = component1
        self.component2 = component2
        self.normalVector = planeNormal

    @classmethod
    def createPlanarComponentInterfaces(cls, components):
        &#39;&#39;&#39;
            Expects components in the list to be sorted by z location (top to bottom)
            Tries to construct PlanarInterface objects connecting all of the BodyComponent object from top to bottom
            Returns a list of PlanarInterface objects, ordered from top to bottom
        &#39;&#39;&#39;
        return None
        # Ignore components that aren&#39;t of type &#39;BodyComponent&#39;
        bodyComponents = []
        for comp in components:
            if isinstance(comp, BodyComponent):
                bodyComponents.append(comp)
        
        # Construct interfaces between components
        componentInterfaces = []
        interfaceLocationTolerance = 0.001 # m
        
        for i in range(len(bodyComponents)-1):
            topComponent = bodyComponents[i]
            bottomComponent = bodyComponents[i+1]
            topInterfaceLoc = topComponent.getBottomInterfaceLocation()
            bottomInterfaceLoc = bottomComponent.getTopInterfaceLocation()

            if (topInterfaceLoc - bottomInterfaceLoc).length() &lt; interfaceLocationTolerance:
                interfaceLocation = (topInterfaceLoc + bottomInterfaceLoc) / 2 # Average location is where the interface will be
                componentInterfaces.append(PlanarInterface(interfaceLocation, topComponent, bottomComponent))
            else:
                raise ValueError(&#34;Body Component Location mismatch {} ({}) bottom interface at {} vs {} ({}) top interface at {}. Current interface tolerance = 0.001m&#34;.format(\
                    topComponent.name, type(topComponent), topInterfaceLoc, bottomComponent.name, type(bottomComponent), bottomInterfaceLoc))

        return componentInterfaces

    @classmethod
    def sortByZLocation(cls, components) -&gt; List[RocketComponent]:
        &#39;&#39;&#39; 
            Sort the components in order from top to bottom, component.position.Z
            This function could be relocated somewhere more suitable, at the time of writing, it is only being used to order components before creating interfaces b/w them
        &#39;&#39;&#39;
        def getZPosition(component):
            try:
                return component.position.Z
            except AttributeError:
                zeroState = RigidBodyState()
                return component.getInertia(0, zeroState).CG.Z

        components.sort(key=getZPosition, reverse=True)
        return components</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.PlanarInterface.createPlanarComponentInterfaces"><code class="name flex">
<span>def <span class="ident">createPlanarComponentInterfaces</span></span>(<span>components)</span>
</code></dt>
<dd>
<div class="desc"><p>Expects components in the list to be sorted by z location (top to bottom)
Tries to construct PlanarInterface objects connecting all of the BodyComponent object from top to bottom
Returns a list of PlanarInterface objects, ordered from top to bottom</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def createPlanarComponentInterfaces(cls, components):
    &#39;&#39;&#39;
        Expects components in the list to be sorted by z location (top to bottom)
        Tries to construct PlanarInterface objects connecting all of the BodyComponent object from top to bottom
        Returns a list of PlanarInterface objects, ordered from top to bottom
    &#39;&#39;&#39;
    return None
    # Ignore components that aren&#39;t of type &#39;BodyComponent&#39;
    bodyComponents = []
    for comp in components:
        if isinstance(comp, BodyComponent):
            bodyComponents.append(comp)
    
    # Construct interfaces between components
    componentInterfaces = []
    interfaceLocationTolerance = 0.001 # m
    
    for i in range(len(bodyComponents)-1):
        topComponent = bodyComponents[i]
        bottomComponent = bodyComponents[i+1]
        topInterfaceLoc = topComponent.getBottomInterfaceLocation()
        bottomInterfaceLoc = bottomComponent.getTopInterfaceLocation()

        if (topInterfaceLoc - bottomInterfaceLoc).length() &lt; interfaceLocationTolerance:
            interfaceLocation = (topInterfaceLoc + bottomInterfaceLoc) / 2 # Average location is where the interface will be
            componentInterfaces.append(PlanarInterface(interfaceLocation, topComponent, bottomComponent))
        else:
            raise ValueError(&#34;Body Component Location mismatch {} ({}) bottom interface at {} vs {} ({}) top interface at {}. Current interface tolerance = 0.001m&#34;.format(\
                topComponent.name, type(topComponent), topInterfaceLoc, bottomComponent.name, type(bottomComponent), bottomInterfaceLoc))

    return componentInterfaces</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.PlanarInterface.sortByZLocation"><code class="name flex">
<span>def <span class="ident">sortByZLocation</span></span>(<span>components) â€‘>Â List[<a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the components in order from top to bottom, component.position.Z
This function could be relocated somewhere more suitable, at the time of writing, it is only being used to order components before creating interfaces b/w them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sortByZLocation(cls, components) -&gt; List[RocketComponent]:
    &#39;&#39;&#39; 
        Sort the components in order from top to bottom, component.position.Z
        This function could be relocated somewhere more suitable, at the time of writing, it is only being used to order components before creating interfaces b/w them
    &#39;&#39;&#39;
    def getZPosition(component):
        try:
            return component.position.Z
        except AttributeError:
            zeroState = RigidBodyState()
            return component.getInertia(0, zeroState).CG.Z

    components.sort(key=getZPosition, reverse=True)
    return components</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.RecoverySystem"><code class="flex name class">
<span>class <span class="ident">RecoverySystem</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a recovery system with an arbitrary number of stages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecoverySystem(FixedMass):
    &#39;&#39;&#39; Represents a recovery system with an arbitrary number of stages &#39;&#39;&#39;

    #### Init Functions ####
    def __init__(self, componentDictReader, rocket, stage):
        FixedMass.__init__(self, componentDictReader, rocket, stage)
        
        self.numStages = componentDictReader.getInt(&#34;numStages&#34;)

        # Set rocket properties
        rocket.recoverySystem = self

        self._initRecoveryStages()

    def _initRecoveryStages(self):
        self.stageTriggers = [ None, ]
        self.stageTriggerValues = [ None, ]
        self.chuteAreas = [ 0, ]
        self.chuteCds = [ 0, ]
        self.delayTimes = [ 0, ]

        for i in range(1,self.numStages+1):
            self.stageTriggers.append(self.componentDictReader.getString(&#34;stage{}Trigger&#34;.format(i)))
            try:
                self.stageTriggerValues.append(self.componentDictReader.getFloat(&#34;stage{}TriggerValue&#34;.format(i)))
            except KeyError:
                self.stageTriggerValues.append(None)
                
            self.chuteAreas.append(self.componentDictReader.getFloat(&#34;stage{}ChuteArea&#34;.format(i)))
            self.chuteCds.append(self.componentDictReader.getFloat(&#34;stage{}Cd&#34;.format(i)))
            self.delayTimes.append(self.componentDictReader.getFloat(&#34;stage{}DelayTime&#34;.format(i)))

        self.currentStage = -1
        self.nextStageDeployTime = None

        # Initialize by deploying stage 0 (no chutes)
        # Sets up trigger function for the real first chute
        self._deployNextStage()

    #### Operational Functions ####
    @logForceResult
    def getAeroForce(self, rocketState, time, environment, CG):
        &#39;&#39;&#39;
            Calculates force/moment applied by the recovery system using a simple drag coefficient + area model
        &#39;&#39;&#39;
        #### Calculate Aero Force ####
        if self.currentStage == 0:
            # No recovery system deployed yet
            return ForceMomentSystem(Vector(0,0,0))
        else:
            # 3DoF force-only aero
            airVel = AeroParameters.getAirVelRelativeToVehicle(rocketState, environment)
            dragForceMagnitude = self.chuteCds[self.currentStage] * self.chuteAreas[self.currentStage] * AeroParameters.getDynamicPressure(rocketState, environment)
            totalForce = airVel.normalize() * dragForceMagnitude
            return ForceMomentSystem(totalForce)

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[&#34;Recovery&#34;]*6)

    def _deployNextStage(self):
        &#39;&#39;&#39; 
            Deploys the next stage of the recovery system  
            If appropriate, will set the simulation mode to 3DoF.
            If appropriate, will set up the trigger to deploy the next stage of the recovery system, by calling this function again.
            If this is the final recovery system stage, records the main chute deployment time.
        &#39;&#39;&#39;
        self.currentStage += 1
        if self.currentStage &gt; 0:
            print(&#34;Deployed Recovery Stage {}&#34;.format(self.currentStage))
            
        if self.currentStage == 1:
            self.rocket.isUnderChute = True
            self.rocket._switchTo3DoF()

        if self.currentStage == self.numStages:
            self.rocket.mainChuteDeployTime = self.rocket.rigidBody.time

        if self.currentStage &lt; self.numStages:
            nextTrigger = self.stageTriggers[self.currentStage + 1]
            nextTriggerValue = self.stageTriggerValues[self.currentStage + 1]
            nextTriggerDelay = self.delayTimes[self.currentStage + 1]

            # Translate trigger conditions into language simEventDetector can understand
            if nextTrigger == &#34;Apogee&#34;:
                nextTrigger = EventTypes.Apogee
            if nextTrigger == &#34;Altitude&#34;:
                nextTrigger = EventTypes.DescendingThroughAltitude
            if nextTrigger == &#34;Time&#34;:
                nextTrigger = EventTypes.TimeReached

            # Set the trigger
            self.rocket.simEventDetector.subscribeToEvent(nextTrigger, self._deployNextStage, eventTriggerValue=nextTriggerValue, triggerDelay=nextTriggerDelay)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.RecoverySystem.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.RecoverySystem.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[&#34;Recovery&#34;]*6)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.Rocket"><code class="flex name class">
<span>class <span class="ident">Rocket</span></span>
<span>(</span><span>rocketDictReader, silent=False, stageToInitialize=None, simRunner=None, environment=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to represent a single flying rigid body composed of <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code> objects.
New instances of this class are also created to model the flight of dropped stages.</p>
<p>Initialization of Rocket(s) is most easily completed through an instance of Simulation
To get a single Rocket object, initialize a Simulation and call <code><a title="MAPLEAF.SimulationRunners.Simulation.createRocket" href="../SimulationRunners/index.html#MAPLEAF.SimulationRunners.Simulation.createRocket">Simulation.createRocket()</a></code>.<br>
This will return a Rocket initialized on the pad with all its stages, ready for flight.</p>
<p>If initializing manually, can either provide fileName or simDefinition. If a simDefinition is provided, it will be used and fileName will be ignored.</p>
<p>Inputs:</p>
<ul>
<li>rocketDictReader:
(<code><a title="MAPLEAF.IO.SubDictReader" href="../IO/index.html#MAPLEAF.IO.SubDictReader">SubDictReader</a></code>) SubDictReader pointed at the "Rocket" dictionary of the desired simulation definition file.
</li>
<li>silent:
(bool) controls console output
</li>
<li>stageToInitialize:
(int or None) controls whether to initialize a complete Rocket or a single (usually dropped) stage. None = initialize complete rocket. n = initialize only stage n, where n &gt;= 1.
</li>
<li>simRunner:
(<code><a title="MAPLEAF.SimulationRunners.Simulation" href="../SimulationRunners/index.html#MAPLEAF.SimulationRunners.Simulation">Simulation</a></code>) reference to the current simulation driver/runner</li>
<li>environment:
(<code><a title="MAPLEAF.ENV.Environment" href="../ENV/index.html#MAPLEAF.ENV.Environment">Environment</a></code>) environment model from which the rocket will retrieve atmospheric properties and wind speeds</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rocket(CompositeObject):
    &#39;&#39;&#39;
        Class used to represent a single flying rigid body composed of `MAPLEAF.Rocket.Stage` objects.
        New instances of this class are also created to model the flight of dropped stages.
    &#39;&#39;&#39;
    #### Initialization ####
    def __init__(self, rocketDictReader, silent=False, stageToInitialize=None, simRunner=None, environment=None):
        &#39;&#39;&#39;
            Initialization of Rocket(s) is most easily completed through an instance of Simulation
            To get a single Rocket object, initialize a Simulation and call `MAPLEAF.SimulationRunners.Simulation.createRocket()`.  
            This will return a Rocket initialized on the pad with all its stages, ready for flight.

            If initializing manually, can either provide fileName or simDefinition. If a simDefinition is provided, it will be used and fileName will be ignored.

            Inputs:

            * rocketDictReader:     (`MAPLEAF.IO.SubDictReader`) SubDictReader pointed at the &#34;Rocket&#34; dictionary of the desired simulation definition file.  
            * silent:               (bool) controls console output  
            * stageToInitialize:    (int or None) controls whether to initialize a complete Rocket or a single (usually dropped) stage. None = initialize complete rocket. n = initialize only stage n, where n &gt;= 1.  
            * simRunner:            (`MAPLEAF.SimulationRunners.Simulation`) reference to the current simulation driver/runner
            * environment:          (`MAPLEAF.ENV.Environment`) environment model from which the rocket will retrieve atmospheric properties and wind speeds
        &#39;&#39;&#39;
        self.rocketDictReader = rocketDictReader
        self.simDefinition = rocketDictReader.simDefinition

        self.simRunner = simRunner
        &#39;&#39;&#39; Parent instance of `MAPLEAF.SimulationRunners.Simulation` (or derivative sim runner). This is usually the object that has created the current instance of Rocket. &#39;&#39;&#39;
        
        self.environment = environment
        &#39;&#39;&#39; Instance of `MAPLEAF.ENV.Environment` &#39;&#39;&#39;
        if self.environment == None:
            # If no environment is passed in, create one
            self.environment = Environment(self.simDefinition, silent=silent)

        self.name = rocketDictReader.getString(&#34;name&#34;)

        self.silent = silent
        &#39;&#39;&#39; Controls output to console &#39;&#39;&#39;

        self.stage = stageToInitialize
        &#39;&#39;&#39; If controls whether the whole rocket is initialized (if == None), or a single stage is initialized (Integer stage number) &#39;&#39;&#39;

        self.stages = []
        &#39;&#39;&#39;
            A list of `MAPLEAF.Rocket.Stage` objects that make up the rocket, ordered from top to bottom.  
            Populated by `_initializeStages`.
        &#39;&#39;&#39;

        self.recoverySystem = None
        &#39;&#39;&#39;
            Reference to the current Rocket&#39;s (which can represent a dropped stage) recovery system. Only a single recovery system is allowed per stage.  
            Set in `MAPLEAF.Rocket.RecoverySystem.__init__`
        &#39;&#39;&#39;

        self.rigidBody = None            
        &#39;&#39;&#39; 
            (`MAPLEAF.Motion.RigidBody` or `MAPLEAF.Motion.RigidBody_3DoF`) Responsible for motion integration.  
            Set in `_initializeRigidBody()`.
        &#39;&#39;&#39;

        self.isUnderChute = False
        &#39;&#39;&#39; (bool) Controlled by `MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage()` &#39;&#39;&#39;

        self.mainChuteDeployTime = None
        &#39;&#39;&#39; (float) Filled in during flight by `MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage()`  &#39;&#39;&#39;
        
        self.engineShutOffTime = None
        &#39;&#39;&#39; (float) Filled in by `MAPLEAF.Rocket.Propulsion.TabulatedMotor.__init__()` upon initialization &#39;&#39;&#39;

        self.turbulenceOffWhenUnderChute = rocketDictReader.getBool(&#34;Environment.turbulenceOffWhenUnderChute&#34;)
        &#39;&#39;&#39; (bool) &#39;&#39;&#39;

        self.maxDiameter = self._getMaxBodyTubeDiameter()     
        &#39;&#39;&#39; (float) Holds maximum constant-size body tube diameter, from bodytube components in stages &#39;&#39;&#39;

        self.Aref = math.pi * self.maxDiameter**2 / 4
        &#39;&#39;&#39; 
            Reference area for force and moment coefficients.
            Maximum rocket cross-sectional area. Remains constant during flight to retain a 1:1 relationship b/w coefficients in different parts of flight.
            Always based on the maximum body tube diameter in the fully-assembled rocket.
        &#39;&#39;&#39;
        
        # TODO: Remove
        self.targetLocation = None

        self.simEventDetector = SimEventDetector(self) 
        &#39;&#39;&#39; (`MAPLEAF.Rocket.SimEventDetector`) Used to trigger things like recovery systems and staging &#39;&#39;&#39;

        self.eventTimeStep = rocketDictReader.getFloat(&#34;SimControl.TimeStepAdaptation.eventTimingAccuracy&#34;)
        &#39;&#39;&#39; If using an adaptive time stepping method, the time step will be overridden near non-time-deterministic discrete events, possibly all the way down to this minimum value &#39;&#39;&#39;

        self.addZeroLengthBoatTailsToAccountForBaseDrag = rocketDictReader.getBool(&#34;Aero.addZeroLengthBoatTailsToAccountForBaseDrag&#34;)
        &#39;&#39;&#39; Controls whether zero-length boat tails are automatically added to the bottom of rockets without them, to make sure base drag is accounted for &#39;&#39;&#39;

        self.fullyTurbulentBL = rocketDictReader.getBool(&#34;Aero.fullyTurbulentBL&#34;)
        &#39;&#39;&#39; Controls whether skin friction is solved assuming a fully turbulent BL or using laminar/transitional flow at lower Reynolds numbers &#39;&#39;&#39;

        self.surfaceRoughness = rocketDictReader.getFloat(&#34;Aero.surfaceRoughness&#34;)
        &#39;&#39;&#39; Default surface roughness for all rocket components &#39;&#39;&#39;

        self.finenessRatio = None
        &#39;&#39;&#39; Used in some aerodynamic functions. Updated after initializing subcomponents, and throughout the flight. None if no BodyComponent(s) are present in the rocket &#39;&#39;&#39;
     
        #### Init Hardware in the loop ####
        subDicts = rocketDictReader.getImmediateSubDicts()
        if &#34;Rocket.HIL&#34; in subDicts:
            self.hardwareInTheLoopControl = &#34;yes&#34;
            quatUpdateRate = rocketDictReader.getInt(&#34;HIL.quatUpdateRate&#34;)
            posUpdateRate = rocketDictReader.getInt(&#34;HIL.posUpdateRate&#34;)
            velUpdateRate = rocketDictReader.getInt(&#34;HIL.velUpdateRate&#34;)
            teensyComPort = rocketDictReader.getString(&#34;HIL.teensyComPort&#34;)
            imuComPort = rocketDictReader.getString(&#34;HIL.imuComPort&#34;)
            teensyBaudrate = rocketDictReader.getInt(&#34;HIL.teensyBaudrate&#34;)
            imuBaudrate = rocketDictReader.getInt(&#34;HIL.imuBaudrate&#34;)
            self.hilInterface = HILInterface(quatUpdateRate,posUpdateRate,velUpdateRate, teensyComPort, imuComPort, teensyBaudrate, imuBaudrate)
        else:
            self.hardwareInTheLoopControl = &#34;no&#34;

        #### Init Components ####
        self._initializeRigidBody()
        self._initializeStages()
        self._initializeStagingTriggers()

        #### Init Parent classes ####
        CompositeObject.__init__(self, self.stages)
        self._updateFinenessRatio()

        # Adjust rigid body state position to correspond to the rocket&#39;s CG instead of nose cone tip position
        self._moveStatePositionToCG()

        #### Init Guidance/Navigation/Control System (if required) ####
        self.controlSystem = None
        &#39;&#39;&#39; None for uncontrolled rockets. `MAPLEAF.GNC.ControlSystems.RocketControlSystem` for controlled rockets &#39;&#39;&#39;
        if ( rocketDictReader.tryGetString(&#34;ControlSystem.controlledSystem&#34;) != None or rocketDictReader.tryGetString(&#34;ControlSystem.MomentController.Type&#34;) == &#34;IdealMomentController&#34;) and stageToInitialize == None:
            # Only create a control system if this is NOT a dropped stage
            ControlSystemDictReader = SubDictReader(&#34;Rocket.ControlSystem&#34;, simDefinition=self.simDefinition)
            self.controlSystem = RocketControlSystem(ControlSystemDictReader, self)

    def _getMaxBodyTubeDiameter(self):
        &#39;&#39;&#39; Gets max body tube diameter directly from config file &#39;&#39;&#39;
        stageDicts = self._getStageSubDicts()

        maxDiameter = 0
        for stageDict in stageDicts:
            componentDicts = self.rocketDictReader.getImmediateSubDicts(stageDict)
            
            for componentDict in componentDicts:
                className = self.rocketDictReader.getString(componentDict + &#34;.class&#34;)
                
                if className == &#34;Bodytube&#34;:
                    diameter = self.rocketDictReader.getFloat(componentDict + &#34;.outerDiameter&#34;)
                    maxDiameter = max(maxDiameter, diameter)
        
        return maxDiameter

    def _getStageSubDicts(self):
        # Get all immediate subdictionaries of &#39;Rocket&#39;
        stageDicts = self.rocketDictReader.getImmediateSubDicts()

        # Assume all subdictionaries represent rocket stages except for these exceptions
        nonStageSubDicts = [ &#34;Rocket.ControlSystem&#34;, &#34;Rocket.HIL&#34;, &#34;Rocket.Aero&#34; ]
        # Remove them from the list if they&#39;re in it
        for dictName in nonStageSubDicts:
            if dictName in stageDicts:
                stageDicts.remove(dictName)

        return stageDicts

    def _initializeRigidBody(self):
        #### Get initial kinematic state (in launch tower frame) ####
        initPos = self.rocketDictReader.getVector(&#34;position&#34;)
        initVel = self.rocketDictReader.getVector(&#34;velocity&#34;)
        
        # Check whether precise initial orientation has been specified
        rotationAxis = self.rocketDictReader.tryGetVector(&#34;rotationAxis&#34;, defaultValue=None)
        if rotationAxis != None:
            rotationAngle = math.radians(self.rocketDictReader.getFloat(&#34;rotationAngle&#34;))
            initOrientation = Quaternion(rotationAxis, rotationAngle)
        else:
            # Calculate initial orientation quaternion in launch tower frame
            initialDirection = self.rocketDictReader.getVector(&#34;initialDirection&#34;).normalize()
            angleFromVertical = Vector(0,0,1).angle(initialDirection)
            rotationAxis = Vector(0,0,1).crossProduct(initialDirection)
            initOrientation = Quaternion(rotationAxis, angleFromVertical)

        initAngVel = AngularVelocity(rotationVector=self.rocketDictReader.getVector(&#34;angularVelocity&#34;))
     
        initState_launchTowerFrame = RigidBodyState(initPos, initVel, initOrientation, initAngVel)

        # Convert to the global inertial frame
        initState_globalInertialFrame = self.environment.convertInitialStateToGlobalFrame(initState_launchTowerFrame)

        # Get desired time discretization method
        timeDisc = self.rocketDictReader.getString(&#34;SimControl.timeDiscretization&#34;)

        #### Initialize the rigid body ####
        if self.simRunner != None:
            self.rigidBody = RigidBody(
                initState_globalInertialFrame, 
                self._getAppliedForce, 
                self.getInertia, 
                integrationMethod=timeDisc, 
                discardedTimeStepCallback=self.simRunner.discardForceLogsForPreviousTimeStep, 
                simDefinition=self.simDefinition
            )
        else:
            self.rigidBody = RigidBody(
                initState_globalInertialFrame, 
                self._getAppliedForce, 
                self.getInertia, 
                integrationMethod=timeDisc, 
                simDefinition=self.simDefinition
            )

    def _initializeStages(self):
        &#39;&#39;&#39; Initialize each of the stages and all of their subcomponents. &#39;&#39;&#39;
        stageDicts = self._getStageSubDicts()

        # If we&#39;re initializing a dropped stage, figure out which one
        if self.stage != None:
            stageNumbers = []
            stageNumberSet = set()
            for stageDict in stageDicts:
                stageNumber = self.rocketDictReader.getFloat(stageDict + &#34;.stageNumber&#34;)
                stageNumbers.append(stageNumber)
                stageNumberSet.add(stageNumber)
            
            if len(stageNumbers) != len(stageNumberSet):
                raise ValueError(&#34;For multi-stage rockets, each stage must have a unique stage number. Set the Rocket.StageName.stageNumber value for each stage. 0 for first stage, 1 for second, etc...&#34;)
            
            stageNumbers.sort()
            stageToInitialize = stageNumbers[self.stage]

        # Initialize Stage(s)
        initializingAllStages = (self.stage == None)
        for stageDictionary in stageDicts:
            stageDictReader = SubDictReader(stageDictionary, self.simDefinition)
            stageNumber = stageDictReader.getFloat(&#34;stageNumber&#34;)

            if initializingAllStages or stageNumber == stageToInitialize:
                newStage = Stage(stageDictReader, self)
                self.stages.append(newStage)

        self.stages = PlanarInterface.sortByZLocation(self.stages)
        self.stageInterfaces = PlanarInterface.createPlanarComponentInterfaces(self.stages)

        if self.maxDiameter &gt; 0:
            # Only run this if we&#39;re running a real rocket with body tubes
            self._ensureBaseDragIsAccountedFor()

    def _initializeStagingTriggers(self):
        &#39;&#39;&#39; Set up trigger conditions for staging &#39;&#39;&#39;
        # Self.stage is not passed in if the current instance represents a rocket ready to launch - then we have to set up staging events
        if self.stage == None:
            for stageIndex in range(len(self.stages)):
                stage = self.stages[stageIndex]

                if stage.separationConditionType != &#39;None&#39;:
                    self.simEventDetector.subscribeToEvent(
                        stage.separationConditionType, 
                        self._stageSeparation, 
                        stage.separationConditionValue, 
                        triggerDelay=stage.separationDelay
                    )
                
                if stageIndex != len(self.stages)-1:
                    # Set all upper stage motors to ignite a very long time in the future    
                    stage.motor.updateIgnitionTime(1000000000, fakeValue=True)

        else:
            # Otherwise this rocket object is representing a single dropped stage, and no stage separations are necessary
            # Motor is burned out
            self.stages[0].motor.updateIgnitionTime(-1000000000, fakeValue=True)
    
    def _moveStatePositionToCG(self):
        &#39;&#39;&#39; Moves self.rigidBody.state.position to have it represent the rocket&#39;s initial CG position, not the initial nose cone position &#39;&#39;&#39;
        initInertia = self.getInertia(0, self.rigidBody.state)
        CGPosition_wrtNoseCone_localFrame = initInertia.CG
        CGPosition__wrtNoseCone_globalFrame = self.rigidBody.state.orientation.rotate(CGPosition_wrtNoseCone_localFrame)
        CGPosition_globalFrame = self.rigidBody.state.position + CGPosition__wrtNoseCone_globalFrame
        self.rigidBody.state.position = CGPosition_globalFrame

    def getLength(self):
        totalLength = 0
        for stage in self.stages:
            try:
                totalLength += stage.getLength()
            except TypeError:
                pass # Stage Length was None - no body components in stage

        return totalLength

    def plotShape(self):
        plt.figure()
        plt.gca().set_aspect(&#39;equal&#39;)

        rocketInertia = self.getInertia(0, self.rigidBody.state)
        TotalCG = rocketInertia.CG.Z
        TotalMass = rocketInertia.mass
        
        TotalCGplt = plt.plot(TotalCG, 0, color=&#39;b&#39;, marker=&#39;d&#39;, label=&#39;Total CG&#39;, linestyle=&#39;None&#39;)
        CGsubZ = []
        CGsubY = []

        plt.title(&#39;Total Rocket CG: %10.4f m \n Total Rocket Mass: %10.4f Kg&#39; % (TotalCG,TotalMass) )

        for stage in self.stages:
            zCGs, yCGs = stage.plotShape()

            # Add subcomponents CGs to arrays
            CGsubZ += zCGs
            CGsubY += yCGs

        SubCGplt = plt.plot(CGsubZ, CGsubY, color=&#39;g&#39;, marker=&#39;.&#39;, label=&#39;Subcomponent CG&#39;, linestyle=&#39;None&#39;)
        legendHeight = self.maxDiameter
        plt.legend(loc=&#39;upper center&#39;, bbox_to_anchor = (0.5,-1.05))
        plt.show()

    #### Stage Separation ####
    def _stageSeparation(self):
        print(&#34;Stage {} Separation&#34;.format(self.simRunner.stagingIndex + 1))
        # Initialize dropped stage as a new rocket
        self.simRunner.createNewDetachedStage()

        # Drop stage from current rocket
        self._dropStage()
        
        # Ignite next motor (set ignition time to the time of stage separation)
        currentTime = self.rigidBody.time
        self.stages[0].motor.updateIgnitionTime(currentTime)

        self._ensureBaseDragIsAccountedFor()
        self._updateFinenessRatio()

    def _dropStage(self, stageIndex=-1):
        droppedStage = self.stages.pop(stageIndex)
        self.recomputeFixedMassInertia()

        if self.controlSystem != None:
            # Check whether the controlled system was part of the dropped stage
            if self.controlSystem.controlledSystem in droppedStage.components:
                # If so delete the rocket&#39;s control system and remove any control system-induced time stepping modifications
                print(&#34;Rocket&#39;s controlled system was on the dropped stage. Deactivating control system.&#34;)
                self.controlSystem.restoreOriginalTimeStepping()
                self.controlSystem = None

    def _ensureBaseDragIsAccountedFor(self):
        &#39;&#39;&#39; If no BoatTail exists at the bottom of the rocket, adds a zero-length boat tail. This is necessary b/c Boat Tail aero-functions are the ones that account for base drag &#39;&#39;&#39;
        boatTailComponentAtBottomOfRocket = False
        bottomStage = self.stages[-1]
        for comp in reversed(bottomStage.components):
            if isinstance(comp, BodyComponent):
                if isinstance(comp, BoatTail):
                    boatTailComponentAtBottomOfRocket = True
                break
        
        if not boatTailComponentAtBottomOfRocket and self.addZeroLengthBoatTailsToAccountForBaseDrag:
            if not self.silent:
                print(&#34;Adding zero-length BoatTail to the bottom of current bottom stage ({}) to account for base drag&#34;.format(bottomStage.name))
            # Create a zero-length, zero-mass boat tail to account for base drag
            zeroInertia = Inertia(Vector(0,0,0), Vector(0,0,0), 0)
            diameter = self.maxDiameter # TODO: Get the actual bottom-body-tube diameter from a future Stage.getRadius function
            length = 0
            position = bottomStage.getBottomInterfaceLocation()
            boatTail = BoatTail(
                diameter, 
                diameter, 
                length, 
                position, 
                zeroInertia, 
                self, 
                bottomStage, 
                &#34;Auto-AddedZeroLengthBoatTail&#34;, 
                self.surfaceRoughness
            )
            bottomStage.components.append(boatTail)     

    def _updateFinenessRatio(self):
        &#39;&#39;&#39; Updates self.finenessRatio based on current BodyComponents in rocket stages &#39;&#39;&#39;
        length = self.getLength()
        maxDiameter = max([ stage.getMaxDiameter() for stage in self.stages ])
        if maxDiameter == 0:
            self.finenessRatio = None
        else:
            self.finenessRatio = length/maxDiameter

    #### Logging ####
    def appendToForceLogLine(self, txt: str):
        &#39;&#39;&#39; Appends txt to the current line of the parent `MAPLEAF.SimulationRunners.Simulation`&#39;s forceEvaluationLog &#39;&#39;&#39;
        try:
            self.simRunner.forceEvaluationLog[-1] += txt
        except AttributeError:
            pass # Force logging not set up for this sim

    #### Component-buildup method for Force ####
    def _getEnvironmentalConditions(self, time, state, logWind=True):
        env = self.environment.getAirProperties(state.position, time)

        # Neglect turbulent component of wind if required
        if self.isUnderChute and self.turbulenceOffWhenUnderChute:
            env = EnvironmentalConditions(
                env.ASLAltitude,
                env.Temp,
                env.Pressure,
                env.Density,
                env.DynamicViscosity,
                env.MeanWind,
                env.MeanWind,
                Vector(0, 0, 0),
            )

        # Log Wind
        if logWind:
            self.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;7.4}&#34;.format(env.Wind, env.Density))
        
        return env

    def _getAppliedForce(self, time, state):
        &#39;&#39;&#39; Get the total force currently being experienced by the rocket, used by self.rigidBody to calculate the rocket&#39;s acceleration &#39;&#39;&#39;
        self.simRunner.newForcesLogLine(&#34;{:&lt;7.3f} &#34;.format(time) + str(state))                  # Start a new line in the force Evaluation log
        
        environment = self._getEnvironmentalConditions(time, state, logWind=True)   # Get and log current air/wind properties
        
        rocketInertia = self.getInertia(time, state)                                            # Get and log current rocket inertia
        self.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.8f} {:&gt;10.8f}&#34;.format(rocketInertia.CG, rocketInertia.mass, rocketInertia.MOI))
        

        ### Component Forces ###
        if not self.isUnderChute:
            # Precompute CG, AOA, roll angle, normal force direction, localFrameAirVel, Ma, UnitRe
            Mach = AeroParameters.getMachNumber(state, environment)
            unitRe = AeroParameters.getReynoldsNumber(state, environment, 1.0)
            AOA = AeroParameters.getTotalAOA(state, environment)
            rollAngle = AeroParameters.getRollAngle(state, environment)

            # Log current rocket / flight conditions
            self.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.0f} {:&gt;10.4f} {:&gt;10.4f}&#34;.format(Mach, unitRe, math.degrees(AOA), rollAngle))

            # This function will be the inherited function CompositeObject.getAeroForce
            componentForces = self.getAeroForce(state, time, environment, rocketInertia.CG) 

        else:
            # When under chute, neglect forces from other components
            self.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.0f} {:&gt;10.4f} {:&gt;10.4f}&#34;.format(0, 0, 0, 0))
            componentForces = self.recoverySystem.getAeroForce(state, time, environment, Vector(0,0,-1))

        componentForces = componentForces.getAt(rocketInertia.CG) # Move Force-Moment system to rocket CG

        # Compute and log center of pressure z-location
        self.appendToForceLogLine(&#34; {:&gt;10.5f}&#34;.format(AeroFunctions._getCPZ(componentForces)))
           
        ### Gravity ###
        gravityForce = self.environment.getGravityForce(rocketInertia, state)        
        totalForce = componentForces + gravityForce

        ### Launch Rail ###
        totalForce = self.environment.applyLaunchTowerForce(state, time, totalForce)

        self.appendToForceLogLine(&#34; {:&gt;8.5f} {:&gt;8.6f} {:&gt;8.4f} {:&gt;8.4f}&#34;.format(
            componentForces.force, componentForces.moment, gravityForce.force, totalForce.force)
        )

        return totalForce
    
    #### Driving / Controlling Simulation ####
    def _runControlSystemAndLogStartingState(self, dt):
        &#39;&#39;&#39;
            Attempts to run the rocket control system (only runs if it&#39;s time to run again, based on its updated rate) (updating target positions for actuators)
            Logs the state of the rocket to the main simulation log
        &#39;&#39;&#39;
        startState = self.rigidBody.state
        startTime = self.rigidBody.time       

        # Control loop (if applicable)
        controlLogString = &#34;&#34; # Empty string if not overridden by running the control loop
        if self.controlSystem != None and not self.isUnderChute:
            environment = self._getEnvironmentalConditions(startTime, startState, logWind=False)

            ### Run Control Loop ###
            newTargetActuatorDeflections = self.controlSystem.runControlLoopIfRequired(startTime, startState, environment)
            
            if newTargetActuatorDeflections != False:
                # runControlLoopIfRequired returns False if the control doesn&#39;t run
                # Add target deflections to the main log string
                deflStrings = [ &#34; {:&gt;7.3f}&#34;.format(defl) for defl in newTargetActuatorDeflections ]
                controlLogString = &#34;&#34;.join(deflStrings)

        # Log NED Tait-Bryan 3-2-1 z-y-x Euler Angles if in 6DoF mode
        try: # 6DoF Mode
            globalOrientation = startState.orientation
            orientationOfNEDFrameInGlobalFrame = self.environment.earthModel.getInertialToNEDFrameRotation(*startState.position)
            orientationRelativeToNEDFrame = orientationOfNEDFrameInGlobalFrame.conjugate() * globalOrientation
            eulerAngles = orientationRelativeToNEDFrame.toEulerAngles()
            eulerAnglesString =  &#34; {:&gt;10.6f}&#34;.format(eulerAngles)
        except AttributeError:
            eulerAnglesString = &#34;&#34; # 3DoF mode

        # Log -&gt; Main Sim Log
        mainLogString = &#34;{:&lt;8.4f} {:&gt;6.5f}&#34;.format(startTime, dt) + str(startState) + eulerAnglesString + controlLogString
        print(mainLogString)

    def timeStep(self, dt: float):
        &#39;&#39;&#39;
            Tells the simulation to take a time step of size dt.  

            Usually called by functions like `MAPLEAF.SimulationRunners.Simulation.run()`

            Returns:
                * timeStepAdaptationFactor: (float) indicates the factor by which the adaptive time stepping method would like to change the timestep for the next timestep (1.0 for non-adaptive methods)
                * dt:                       (float) actual size of time step taken. Adaptive methods will override the dt asked for if the predicted error for a time step is over their error threshold.
        &#39;&#39;&#39;
        # Stop the rocket from sliding off the bottom of the launch rail
        self.rigidBody.state = self.environment.applyLaunchRailMotionConstraints(self.rigidBody.state, self.rigidBody.time)
        
        # Trigger any events that occurred during the last time step
        estimatedTimeToNextEvent, accuratePrediction = self.simEventDetector.triggerEvents()

        if &#34;Adapt&#34; in self.rigidBody.integrate.method and estimatedTimeToNextEvent &lt; dt:
            # Override time step to accurately resolve discrete events
            if accuratePrediction:
                # For time-deterministic events, just set the time step to ever so slightly past the event
                newDt = estimatedTimeToNextEvent + 1e-5
                print(&#34;Rocket + SimEventDetector overriding time step from {} to {} to accurately trigger resolve time-deterministic event.&#34;.format(dt, newDt))
                dt = newDt
            else:
                # For time-nondeterministic events, slowly approach the event
                newDt = max(estimatedTimeToNextEvent/1.5, self.eventTimeStep)
                estimatedOccurenceTime = self.rigidBody.time + estimatedTimeToNextEvent
                print(&#34;Rocket + SimEventDetector overriding time step from {} to {} to accurately resolve upcoming event. Estimated occurence at: {}&#34;.format(dt, newDt, estimatedOccurenceTime))
                dt = newDt
                
        # Logs line to mainSimLog
        self._runControlSystemAndLogStartingState(dt)

        # Take timestep
        timeStepAdjustmentFactor, estimatedError, dt = self.rigidBody.timeStep(dt)

        if &#34;Adapt&#34; in self.rigidBody.integrate.method:
            # Add estimated error for the time step to the end of the simulation log line
            try:
                self.simRunner.mainSimulationLog[-2] += &#34; {:&lt;8.6f}&#34;.format(estimatedError)
            except AttributeError:
                pass # No logging set up

        # Return time step adaptation factor - will be 1 for constant time stepping
        return timeStepAdjustmentFactor, dt
    
    def _switchTo3DoF(self):
        &#39;&#39;&#39; Switch to 3DoF simulation after recovery system is deployed &#39;&#39;&#39;
        print(&#34;Switching to 3DoF simulation&#34;)
        new3DoFState = RigidBodyState_3DoF(self.rigidBody.state.position, self.rigidBody.state.velocity)
        
        # Re-read time discretization in case an adaptive method has been selected while using a fixed-update rate control system - in that case, want to switch back to adaptive time stepping for the recovery (uncontrolled) portion of the flight
        originalTimeDiscretization = self.rocketDictReader.getString(&#34;SimControl.timeDiscretization&#34;)

        if self.simRunner != None:
            self.rigidBody = RigidBody_3DoF(
                new3DoFState, 
                self._getAppliedForce, 
                self.getMass, 
                startTime=self.rigidBody.time, 
                integrationMethod=originalTimeDiscretization, 
                discardedTimeStepCallback=self.simRunner.discardForceLogsForPreviousTimeStep, 
                simDefinition=self.simDefinition
            )
        else:
            self.rigidBody = RigidBody_3DoF(
                new3DoFState, 
                self._getAppliedForce, 
                self.getMass, 
                startTime=self.rigidBody.time, 
                integrationMethod=originalTimeDiscretization, 
                simDefinition=self.simDefinition
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject">CompositeObject</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="MAPLEAF.Rocket.Rocket.Aref"><code class="name">var <span class="ident">Aref</span></code></dt>
<dd>
<div class="desc"><p>Reference area for force and moment coefficients.
Maximum rocket cross-sectional area. Remains constant during flight to retain a 1:1 relationship b/w coefficients in different parts of flight.
Always based on the maximum body tube diameter in the fully-assembled rocket.</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.addZeroLengthBoatTailsToAccountForBaseDrag"><code class="name">var <span class="ident">addZeroLengthBoatTailsToAccountForBaseDrag</span></code></dt>
<dd>
<div class="desc"><p>Controls whether zero-length boat tails are automatically added to the bottom of rockets without them, to make sure base drag is accounted for</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.controlSystem"><code class="name">var <span class="ident">controlSystem</span></code></dt>
<dd>
<div class="desc"><p>None for uncontrolled rockets. <code><a title="MAPLEAF.GNC.ControlSystems.RocketControlSystem" href="../GNC/ControlSystems.html#MAPLEAF.GNC.ControlSystems.RocketControlSystem">RocketControlSystem</a></code> for controlled rockets</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.engineShutOffTime"><code class="name">var <span class="ident">engineShutOffTime</span></code></dt>
<dd>
<div class="desc"><p>(float) Filled in by <code><a title="MAPLEAF.Rocket.Propulsion.TabulatedMotor" href="Propulsion.html#MAPLEAF.Rocket.Propulsion.TabulatedMotor">TabulatedMotor</a></code> upon initialization</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.environment"><code class="name">var <span class="ident">environment</span></code></dt>
<dd>
<div class="desc"><p>Instance of <code><a title="MAPLEAF.ENV.Environment" href="../ENV/index.html#MAPLEAF.ENV.Environment">Environment</a></code></p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.eventTimeStep"><code class="name">var <span class="ident">eventTimeStep</span></code></dt>
<dd>
<div class="desc"><p>If using an adaptive time stepping method, the time step will be overridden near non-time-deterministic discrete events, possibly all the way down to this minimum value</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.finenessRatio"><code class="name">var <span class="ident">finenessRatio</span></code></dt>
<dd>
<div class="desc"><p>Used in some aerodynamic functions. Updated after initializing subcomponents, and throughout the flight. None if no BodyComponent(s) are present in the rocket</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.fullyTurbulentBL"><code class="name">var <span class="ident">fullyTurbulentBL</span></code></dt>
<dd>
<div class="desc"><p>Controls whether skin friction is solved assuming a fully turbulent BL or using laminar/transitional flow at lower Reynolds numbers</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.isUnderChute"><code class="name">var <span class="ident">isUnderChute</span></code></dt>
<dd>
<div class="desc"><p>(bool) Controlled by <code><a title="MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage" href="Recovery.html#MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage">RecoverySystem._deployNextStage()</a></code></p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.mainChuteDeployTime"><code class="name">var <span class="ident">mainChuteDeployTime</span></code></dt>
<dd>
<div class="desc"><p>(float) Filled in during flight by <code><a title="MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage" href="Recovery.html#MAPLEAF.Rocket.Recovery.RecoverySystem._deployNextStage">RecoverySystem._deployNextStage()</a></code></p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.maxDiameter"><code class="name">var <span class="ident">maxDiameter</span></code></dt>
<dd>
<div class="desc"><p>(float) Holds maximum constant-size body tube diameter, from bodytube components in stages</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.recoverySystem"><code class="name">var <span class="ident">recoverySystem</span></code></dt>
<dd>
<div class="desc"><p>Reference to the current Rocket's (which can represent a dropped stage) recovery system. Only a single recovery system is allowed per stage.<br>
Set in <code><a title="MAPLEAF.Rocket.RecoverySystem" href="#MAPLEAF.Rocket.RecoverySystem">RecoverySystem</a></code></p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.rigidBody"><code class="name">var <span class="ident">rigidBody</span></code></dt>
<dd>
<div class="desc"><p>(<code><a title="MAPLEAF.Motion.RigidBody" href="../Motion/index.html#MAPLEAF.Motion.RigidBody">RigidBody</a></code> or <code><a title="MAPLEAF.Motion.RigidBody_3DoF" href="../Motion/index.html#MAPLEAF.Motion.RigidBody_3DoF">RigidBody_3DoF</a></code>) Responsible for motion integration.<br>
Set in <code>_initializeRigidBody()</code>.</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.silent"><code class="name">var <span class="ident">silent</span></code></dt>
<dd>
<div class="desc"><p>Controls output to console</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.simEventDetector"><code class="name">var <span class="ident">simEventDetector</span></code></dt>
<dd>
<div class="desc"><p>(<code><a title="MAPLEAF.Rocket.SimEventDetector" href="#MAPLEAF.Rocket.SimEventDetector">SimEventDetector</a></code>) Used to trigger things like recovery systems and staging</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.simRunner"><code class="name">var <span class="ident">simRunner</span></code></dt>
<dd>
<div class="desc"><p>Parent instance of <code><a title="MAPLEAF.SimulationRunners.Simulation" href="../SimulationRunners/index.html#MAPLEAF.SimulationRunners.Simulation">Simulation</a></code> (or derivative sim runner). This is usually the object that has created the current instance of Rocket.</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.stage"><code class="name">var <span class="ident">stage</span></code></dt>
<dd>
<div class="desc"><p>If controls whether the whole rocket is initialized (if == None), or a single stage is initialized (Integer stage number)</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.stages"><code class="name">var <span class="ident">stages</span></code></dt>
<dd>
<div class="desc"><p>A list of <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code> objects that make up the rocket, ordered from top to bottom.<br>
Populated by <code>_initializeStages</code>.</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.surfaceRoughness"><code class="name">var <span class="ident">surfaceRoughness</span></code></dt>
<dd>
<div class="desc"><p>Default surface roughness for all rocket components</p></div>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.turbulenceOffWhenUnderChute"><code class="name">var <span class="ident">turbulenceOffWhenUnderChute</span></code></dt>
<dd>
<div class="desc"><p>(bool)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.Rocket.appendToForceLogLine"><code class="name flex">
<span>def <span class="ident">appendToForceLogLine</span></span>(<span>self, txt:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends txt to the current line of the parent <code><a title="MAPLEAF.SimulationRunners.Simulation" href="../SimulationRunners/index.html#MAPLEAF.SimulationRunners.Simulation">Simulation</a></code>'s forceEvaluationLog</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def appendToForceLogLine(self, txt: str):
    &#39;&#39;&#39; Appends txt to the current line of the parent `MAPLEAF.SimulationRunners.Simulation`&#39;s forceEvaluationLog &#39;&#39;&#39;
    try:
        self.simRunner.forceEvaluationLog[-1] += txt
    except AttributeError:
        pass # Force logging not set up for this sim</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.getLength"><code class="name flex">
<span>def <span class="ident">getLength</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLength(self):
    totalLength = 0
    for stage in self.stages:
        try:
            totalLength += stage.getLength()
        except TypeError:
            pass # Stage Length was None - no body components in stage

    return totalLength</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self):
    plt.figure()
    plt.gca().set_aspect(&#39;equal&#39;)

    rocketInertia = self.getInertia(0, self.rigidBody.state)
    TotalCG = rocketInertia.CG.Z
    TotalMass = rocketInertia.mass
    
    TotalCGplt = plt.plot(TotalCG, 0, color=&#39;b&#39;, marker=&#39;d&#39;, label=&#39;Total CG&#39;, linestyle=&#39;None&#39;)
    CGsubZ = []
    CGsubY = []

    plt.title(&#39;Total Rocket CG: %10.4f m \n Total Rocket Mass: %10.4f Kg&#39; % (TotalCG,TotalMass) )

    for stage in self.stages:
        zCGs, yCGs = stage.plotShape()

        # Add subcomponents CGs to arrays
        CGsubZ += zCGs
        CGsubY += yCGs

    SubCGplt = plt.plot(CGsubZ, CGsubY, color=&#39;g&#39;, marker=&#39;.&#39;, label=&#39;Subcomponent CG&#39;, linestyle=&#39;None&#39;)
    legendHeight = self.maxDiameter
    plt.legend(loc=&#39;upper center&#39;, bbox_to_anchor = (0.5,-1.05))
    plt.show()</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Rocket.timeStep"><code class="name flex">
<span>def <span class="ident">timeStep</span></span>(<span>self, dt:Â float)</span>
</code></dt>
<dd>
<div class="desc"><p>Tells the simulation to take a time step of size dt.
</p>
<p>Usually called by functions like <code><a title="MAPLEAF.SimulationRunners.Simulation.run" href="../SimulationRunners/index.html#MAPLEAF.SimulationRunners.Simulation.run">Simulation.run()</a></code></p>
<h2 id="returns">Returns</h2>
<ul>
<li>timeStepAdaptationFactor: (float) indicates the factor by which the adaptive time stepping method would like to change the timestep for the next timestep (1.0 for non-adaptive methods)</li>
<li>dt:
(float) actual size of time step taken. Adaptive methods will override the dt asked for if the predicted error for a time step is over their error threshold.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def timeStep(self, dt: float):
    &#39;&#39;&#39;
        Tells the simulation to take a time step of size dt.  

        Usually called by functions like `MAPLEAF.SimulationRunners.Simulation.run()`

        Returns:
            * timeStepAdaptationFactor: (float) indicates the factor by which the adaptive time stepping method would like to change the timestep for the next timestep (1.0 for non-adaptive methods)
            * dt:                       (float) actual size of time step taken. Adaptive methods will override the dt asked for if the predicted error for a time step is over their error threshold.
    &#39;&#39;&#39;
    # Stop the rocket from sliding off the bottom of the launch rail
    self.rigidBody.state = self.environment.applyLaunchRailMotionConstraints(self.rigidBody.state, self.rigidBody.time)
    
    # Trigger any events that occurred during the last time step
    estimatedTimeToNextEvent, accuratePrediction = self.simEventDetector.triggerEvents()

    if &#34;Adapt&#34; in self.rigidBody.integrate.method and estimatedTimeToNextEvent &lt; dt:
        # Override time step to accurately resolve discrete events
        if accuratePrediction:
            # For time-deterministic events, just set the time step to ever so slightly past the event
            newDt = estimatedTimeToNextEvent + 1e-5
            print(&#34;Rocket + SimEventDetector overriding time step from {} to {} to accurately trigger resolve time-deterministic event.&#34;.format(dt, newDt))
            dt = newDt
        else:
            # For time-nondeterministic events, slowly approach the event
            newDt = max(estimatedTimeToNextEvent/1.5, self.eventTimeStep)
            estimatedOccurenceTime = self.rigidBody.time + estimatedTimeToNextEvent
            print(&#34;Rocket + SimEventDetector overriding time step from {} to {} to accurately resolve upcoming event. Estimated occurence at: {}&#34;.format(dt, newDt, estimatedOccurenceTime))
            dt = newDt
            
    # Logs line to mainSimLog
    self._runControlSystemAndLogStartingState(dt)

    # Take timestep
    timeStepAdjustmentFactor, estimatedError, dt = self.rigidBody.timeStep(dt)

    if &#34;Adapt&#34; in self.rigidBody.integrate.method:
        # Add estimated error for the time step to the end of the simulation log line
        try:
            self.simRunner.mainSimulationLog[-2] += &#34; {:&lt;8.6f}&#34;.format(estimatedError)
        except AttributeError:
            pass # No logging set up

    # Return time step adaptation factor - will be 1 for constant time stepping
    return timeStepAdjustmentFactor, dt</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject">CompositeObject</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.getAeroForce" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.getMass" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.getMass">getMass</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.recomputeFixedMassInertia" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.recomputeFixedMassInertia">recomputeFixedMassInertia</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.RocketComponent"><code class="flex name class">
<span>class <span class="ident">RocketComponent</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Interface definition for rocket components</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RocketComponent(ABC):
    &#39;&#39;&#39; Interface definition for rocket components &#39;&#39;&#39;
    @abstractmethod
    def __init__(self, componentDictReader, rocket, stage):
        return

    @abstractmethod
    def getInertia(self, time, state) -&gt; Inertia:
        return

    @abstractmethod
    def getAeroForce(self, rocketState, time, environmentalConditions, rocketCG) -&gt; ForceMomentSystem:
        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.Propulsion.TabulatedMotor" href="Propulsion.html#MAPLEAF.Rocket.Propulsion.TabulatedMotor">TabulatedMotor</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.AeroForce" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.AeroForce">AeroForce</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedForce" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedForce">FixedForce</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.FractionalJetDamping" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FractionalJetDamping">FractionalJetDamping</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.TabulatedInertia" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.TabulatedInertia">TabulatedInertia</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.RocketComponent.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, rocketState, time, environmentalConditions, rocketCG) â€‘>Â <a title="MAPLEAF.Motion.forceMomentSystem.ForceMomentSystem" href="../Motion/forceMomentSystem.html#MAPLEAF.Motion.forceMomentSystem.ForceMomentSystem">ForceMomentSystem</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def getAeroForce(self, rocketState, time, environmentalConditions, rocketCG) -&gt; ForceMomentSystem:
    return</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.RocketComponent.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state) â€‘>Â <a title="MAPLEAF.Motion.inertia.Inertia" href="../Motion/inertia.html#MAPLEAF.Motion.inertia.Inertia">Inertia</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def getInertia(self, time, state) -&gt; Inertia:
    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.SimEventDetector"><code class="flex name class">
<span>class <span class="ident">SimEventDetector</span></span>
<span>(</span><span>rocket)</span>
</code></dt>
<dd>
<div class="desc"><p>Each sim event detector detects events on a single rocket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimEventDetector():
    &#39;&#39;&#39;
        Each sim event detector detects events on a single rocket 
    &#39;&#39;&#39;

    def __init__(self, rocket):
        self.rocket = rocket

        self.callbackFunctions = []
        self.conditionsEvalFunctions = []
        self.conditionValues = []
        self.triggerDelays = []

    def subscribeToEvent(self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0):
        &#39;&#39;&#39;
            Inputs:
                eventType:          &#34;apogee&#34;, &#34;ascendingThroughAltitude&#34;, &#34;descendingThroughAltitude&#34;, &#39;motorBurnout&#34; or &#34;timeReached&#34;
                    Can pass in a member of the EventType Enum defined above, if desired
                callbackfunction:   function to call when the desired event occurs. Must have no arguments
                eventTriggerValue:  None, or a trigger parameter for the eventType - an altitude or a time
                triggerDelay:       (numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met

            Note:
                Motor Burnout always triggers at the burnout time of the LOWEST stage&#39;s motor!
        &#39;&#39;&#39;
        # Define map between eventType strings and checker functions
        stringToEvalFnMap = {
            EventTypes.Apogee.value:                    self._isAfterApogee,
            EventTypes.AscendingThroughAltitude.value:  self._isAboveAltitude,
            EventTypes.DescendingThroughAltitude.value: self._isBelowAltitude,
            EventTypes.MotorBurnout.value:              self._isBottomStageMotorBurnedOut,
            EventTypes.TimeReached.value:               self._timeReached
        }

        # Make sure eventType is a string
        if not isinstance(eventType, str):
            eventType = eventType.value # If for example EventType.Apogee is passed in, EventType.Apogee.value retrieves &#34;apogee&#34; from the EventType enum
        
        self.callbackFunctions.append(callbackFunction)
        self.conditionValues.append(eventTriggerValue)
        self.conditionsEvalFunctions.append(stringToEvalFnMap[eventType])
        self.triggerDelays.append(triggerDelay)

    def triggerEvents(self) -&gt; Tuple[float, bool]:
        &#39;&#39;&#39; Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
            Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
                These return values are used to influence time step adaptation to accurately resolve discrete event timing
        &#39;&#39;&#39;
        # Save indices of conditions that have been triggered, will now be removed
        indicesToRemove = []
        
        estimatedTimeToNextEvent = 1e10
        nextEventTimeDeterministic = False
        
        # Precomputed to pass to sub-functions (required for altitude conditions)
        ENUState = self.rocket.environment.convertStateToENUFrame(self.rocket.rigidBody.state)

        # Check each callback condition
        for i in range(len(self.callbackFunctions)):
            # If a conditions has come true
            eventOccurred, timeToOccurrence, timeDeterministic = self.conditionsEvalFunctions[i](self.conditionValues[i], ENUState)

            # Get info about the next event to occur
            if timeToOccurrence &lt; estimatedTimeToNextEvent and not eventOccurred:
                estimatedTimeToNextEvent = timeToOccurrence
                nextEventTimeDeterministic = timeDeterministic

            if eventOccurred:
                if self.triggerDelays[i] == 0:
                    # Call its function
                    # TODO: Print message to simulation log saying that the event has been triggered
                    self.callbackFunctions[i]()
                else:
                    # Schedule the event to happen in triggerDelay seconds
                    triggerTime = self.rocket.rigidBody.time + self.triggerDelays[i]
                    self.subscribeToEvent(EventTypes.TimeReached, self.callbackFunctions[i], triggerTime)

                # And mark it for deletion
                indicesToRemove.append(i)

        # Delete all of the events that were triggered - working in reverse to ensure the indices of the items aren&#39;t changed before we delete them
        for i in range(len(indicesToRemove)):
            delI = len(indicesToRemove)-1-i
            indexToRemove = indicesToRemove[delI]
            
            del self.callbackFunctions[indexToRemove]
            del self.conditionValues[indexToRemove]
            del self.conditionsEvalFunctions[indexToRemove]
            del self.triggerDelays[indexToRemove]

        
        # Save velocity and time for next timestep (if we&#39;re trying to detect apogee)
            # Doing this here to avoid problems calling the apogee function multiple times in a single time step
        self.lastVelocity = ENUState.velocity
        self.lastTime = self.rocket.rigidBody.time

        return estimatedTimeToNextEvent, nextEventTimeDeterministic
    
    ### Event evaluation functions - each is expected to have a single parameter, return True/False ###
    def _isAfterApogee(self, _, ENUState):
        # Time &gt; 1.0 condition here to avoid setting off events if sliding slightly down before engine lights
        eventOccurred = ENUState.velocity.Z &lt;= 0 and self.rocket.rigidBody.time &gt; 1.0

        timeToOccurrence = 1e10
        try:
            accel = (ENUState.velocity.Z - self.lastVelocity.Z) / (self.rocket.rigidBody.time - self.lastTime)
            if accel &lt; 0 and ENUState.velocity.Z &gt; 0:
                timeToOccurrence = -ENUState.velocity.Z / accel
        except (AttributeError, ZeroDivisionError):
            pass # Haven&#39;t saved a velocity/time yet / calling function twice in a single time step

        return eventOccurred, timeToOccurrence, False

    def _isAboveAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &gt;= altitude and ENUState.velocity.Z &gt; 0

        if ENUState.velocity.Z &gt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBelowAltitude(self, altitude, ENUState):
        eventOccurred = ENUState.position.Z &lt;= altitude and ENUState.velocity.Z &lt; 0

        if ENUState.velocity.Z &lt; 0:
            timeToOccurrence = (altitude - ENUState.position.Z) / ENUState.velocity.Z
        else:
            timeToOccurrence = 1e10

        return eventOccurred, timeToOccurrence, False

    def _isBottomStageMotorBurnedOut(self, _, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= self.rocket.stages[-1].engineShutOffTime
        timeToOccurrence = self.rocket.stages[-1].engineShutOffTime - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True

    def _timeReached(self, time, ENUState):
        eventOccurred = self.rocket.rigidBody.time &gt;= time
        timeToOccurrence = time - self.rocket.rigidBody.time
        return eventOccurred, timeToOccurrence, True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.SimEventDetector.subscribeToEvent"><code class="name flex">
<span>def <span class="ident">subscribeToEvent</span></span>(<span>self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="inputs">Inputs</h2>
<p>eventType:
"apogee", "ascendingThroughAltitude", "descendingThroughAltitude", 'motorBurnout" or "timeReached"
Can pass in a member of the EventType Enum defined above, if desired
callbackfunction:
function to call when the desired event occurs. Must have no arguments
eventTriggerValue:
None, or a trigger parameter for the eventType - an altitude or a time
triggerDelay:
(numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met</p>
<h2 id="note">Note</h2>
<p>Motor Burnout always triggers at the burnout time of the LOWEST stage's motor!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribeToEvent(self, eventType, callbackFunction, eventTriggerValue=None, triggerDelay=0):
    &#39;&#39;&#39;
        Inputs:
            eventType:          &#34;apogee&#34;, &#34;ascendingThroughAltitude&#34;, &#34;descendingThroughAltitude&#34;, &#39;motorBurnout&#34; or &#34;timeReached&#34;
                Can pass in a member of the EventType Enum defined above, if desired
            callbackfunction:   function to call when the desired event occurs. Must have no arguments
            eventTriggerValue:  None, or a trigger parameter for the eventType - an altitude or a time
            triggerDelay:       (numeric) the amount of time, in seconds, to wait before triggering an event after a trigger condition has been met

        Note:
            Motor Burnout always triggers at the burnout time of the LOWEST stage&#39;s motor!
    &#39;&#39;&#39;
    # Define map between eventType strings and checker functions
    stringToEvalFnMap = {
        EventTypes.Apogee.value:                    self._isAfterApogee,
        EventTypes.AscendingThroughAltitude.value:  self._isAboveAltitude,
        EventTypes.DescendingThroughAltitude.value: self._isBelowAltitude,
        EventTypes.MotorBurnout.value:              self._isBottomStageMotorBurnedOut,
        EventTypes.TimeReached.value:               self._timeReached
    }

    # Make sure eventType is a string
    if not isinstance(eventType, str):
        eventType = eventType.value # If for example EventType.Apogee is passed in, EventType.Apogee.value retrieves &#34;apogee&#34; from the EventType enum
    
    self.callbackFunctions.append(callbackFunction)
    self.conditionValues.append(eventTriggerValue)
    self.conditionsEvalFunctions.append(stringToEvalFnMap[eventType])
    self.triggerDelays.append(triggerDelay)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.SimEventDetector.triggerEvents"><code class="name flex">
<span>def <span class="ident">triggerEvents</span></span>(<span>self) â€‘>Â Tuple[float,Â bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
These return values are used to influence time step adaptation to accurately resolve discrete event timing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triggerEvents(self) -&gt; Tuple[float, bool]:
    &#39;&#39;&#39; Checks if any of the events that this SimEventDetector is supposed to detect have happened. If so, triggers their callback functions.
        Returns the estimated time to the next event, and whether that event happens at a set time (time-deterministic) or not (non-time-deterministic - like an altitude condition)
            These return values are used to influence time step adaptation to accurately resolve discrete event timing
    &#39;&#39;&#39;
    # Save indices of conditions that have been triggered, will now be removed
    indicesToRemove = []
    
    estimatedTimeToNextEvent = 1e10
    nextEventTimeDeterministic = False
    
    # Precomputed to pass to sub-functions (required for altitude conditions)
    ENUState = self.rocket.environment.convertStateToENUFrame(self.rocket.rigidBody.state)

    # Check each callback condition
    for i in range(len(self.callbackFunctions)):
        # If a conditions has come true
        eventOccurred, timeToOccurrence, timeDeterministic = self.conditionsEvalFunctions[i](self.conditionValues[i], ENUState)

        # Get info about the next event to occur
        if timeToOccurrence &lt; estimatedTimeToNextEvent and not eventOccurred:
            estimatedTimeToNextEvent = timeToOccurrence
            nextEventTimeDeterministic = timeDeterministic

        if eventOccurred:
            if self.triggerDelays[i] == 0:
                # Call its function
                # TODO: Print message to simulation log saying that the event has been triggered
                self.callbackFunctions[i]()
            else:
                # Schedule the event to happen in triggerDelay seconds
                triggerTime = self.rocket.rigidBody.time + self.triggerDelays[i]
                self.subscribeToEvent(EventTypes.TimeReached, self.callbackFunctions[i], triggerTime)

            # And mark it for deletion
            indicesToRemove.append(i)

    # Delete all of the events that were triggered - working in reverse to ensure the indices of the items aren&#39;t changed before we delete them
    for i in range(len(indicesToRemove)):
        delI = len(indicesToRemove)-1-i
        indexToRemove = indicesToRemove[delI]
        
        del self.callbackFunctions[indexToRemove]
        del self.conditionValues[indexToRemove]
        del self.conditionsEvalFunctions[indexToRemove]
        del self.triggerDelays[indexToRemove]

    
    # Save velocity and time for next timestep (if we&#39;re trying to detect apogee)
        # Doing this here to avoid problems calling the apogee function multiple times in a single time step
    self.lastVelocity = ENUState.velocity
    self.lastTime = self.rocket.rigidBody.time

    return estimatedTimeToNextEvent, nextEventTimeDeterministic</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.Stage"><code class="flex name class">
<span>class <span class="ident">Stage</span></span>
<span>(</span><span>stageDictReader, rocket)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a single rocket stage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Stage(CompositeObject, BodyComponent):
    &#39;&#39;&#39; Represents a single rocket stage &#39;&#39;&#39;

    def __init__(self, stageDictReader, rocket):
        #TODO: This should take a boolean parameter &#39;dropped&#39; which specified whether the stage being initialized is on the pad (full engine) or being dropped (empty engine)
        self.rocket = rocket
        self.stageDictReader = stageDictReader

        self.name = stageDictReader.getDictName()
        self.stageNumber = stageDictReader.getInt(&#34;stageNumber&#34;)
        self.position = stageDictReader.getVector(&#34;position&#34;)

        self.separationConditionType = stageDictReader.getString(&#34;separationTriggerType&#34;)
        self.separationDelay = stageDictReader.getFloat(&#34;separationDelay&#34;)
        self.separationConditionValue = stageDictReader.getFloat(&#34;separationTriggerValue&#34;)

        #### Placeholder fields, to be filled by subcomponents ####
        self.motor = None # Filled in by Motor.__init__
        self.engineShutOffTime = None # Filled in by Motor.__init__ - used for base drag calculations

        self.components = []
        self.initializeSubComponents()

        # Check if any stage-level inertia properties are being overriden
        CGOverride = stageDictReader.tryGetVector(&#34;constCG&#34;, defaultValue=None)
        if CGOverride != None:
            CGOverride += self.position
        massOverride = stageDictReader.tryGetFloat(&#34;constMass&#34;, defaultValue=None)
        MOIOverride = stageDictReader.tryGetVector(&#34;constMOI&#34;, defaultValue=None)

        # Initialize functionality inherited from CompositeObject - pass in any overrides
        CompositeObject.__init__(self, components=self.components, CGOverride=CGOverride, MOIOverride=MOIOverride, massOverride=massOverride)
        
    def initializeSubComponents(self):
        # Assume each sub dictionary represents a component
        subDicts = self.stageDictReader.getImmediateSubDicts()

        def returnZeroIfBodyComponent(componentDictPath):
            className = self.stageDictReader.getString(componentDictPath + &#34;.class&#34;)
            componentClass = stringNameToClassMap[className]
            
            if issubclass(componentClass, BodyComponent):
                return 0, componentDictPath
            else: 
                return 1, componentDictPath

        # Make sure BodyComponents are initializede before others
            # This allows non-body components (which are attached to body components) like the fins
                # to get info about the body radius where they&#39;re mounted
        subDicts.sort(key=returnZeroIfBodyComponent)

        # Initialize each component, add to componets
        for componentDict in subDicts:
            newComponent = rocketComponentFactory(componentDict, self.rocket, self)
            self.components.append(newComponent)     

        # Create Planar Interfaces b/w components
        self.components = PlanarInterface.sortByZLocation(self.components)
        self.componentInterfaces = PlanarInterface.createPlanarComponentInterfaces(self.components)      

    def getComponentsOfType(self, type):
        matchingComponents = []
        for comp in self.components:
            if isinstance(comp, type):
                matchingComponents.append(comp)

        return matchingComponents

    #### Geometry / Introspection ####
    def _getFirstComponentOfType(self, componentList, desiredType):
        for comp in componentList:
            if isinstance(comp, desiredType):
                return comp
        return None

    def getTopInterfaceLocation(self) -&gt; Union[Vector, None]:
        # Expects components to be sorted by z-location, top to bottom
        comp = self._getFirstComponentOfType(self.components, BodyComponent)
        try:
            topZ = comp.getTopInterfaceLocation().Z
            return Vector(self.position.X, self.position.Y, topZ)   
        except AttributeError:
            return None # Occurs when comp.getTopInterfaceLocation() == None

    def getBottomInterfaceLocation(self) -&gt; Union[Vector, None]:
        # Expects components to be sorted by z-location, top to bottom
        comp = self._getFirstComponentOfType(reversed(self.components), BodyComponent)
        try:
            bottomZ = comp.getBottomInterfaceLocation().Z
            return Vector(self.position.X, self.position.Y, bottomZ)   
        except AttributeError:
            return None # Occurs when comp.getBottomInterfaceLocation() == None

    def getLength(self):
        try:
            topBodyComponent = self._getFirstComponentOfType(self.components, BodyComponent)
            topLocationZ = topBodyComponent.position.Z

            bottomBodyComponent = self._getFirstComponentOfType(reversed(self.components), BodyComponent)
            bottomLocationZ = bottomBodyComponent.position.Z - bottomBodyComponent.length
            return (topLocationZ - bottomLocationZ)
        except AttributeError:
            return None # No body components in current Stage

    def getMaxDiameter(self):
        maxDiameter = 0
        for comp in self.components:
            try:
                maxDiameter = max(comp.getMaxDiameter(), maxDiameter)
            except AttributeError:
                pass # Component is not a BodyComponent
        
        return maxDiameter

    def getRadius(self, distanceFromTop):
        topOfStageZ = self.position.Z
        desiredZ = topOfStageZ - distanceFromTop

        for comp in self.components:
            try:
                # Check if desired location is part of this component, if so, return the component&#39;s radius
                compTopZ = comp.position.Z
                compBottomZ = compTopZ - comp.length
                if desiredZ &lt;= compTopZ and desiredZ &gt;= compBottomZ:
                    distanceFromTopOfComponent = compTopZ - desiredZ
                    return comp.getRadius(distanceFromTopOfComponent)

            except AttributeError:
                pass # Not a body component
        
        raise ValueError(&#34;Length {} from the top of stage &#39;{}&#39; does not fall between the top and bottom of any of its components&#34;.format(distanceFromTop, self.name))

    def plotShape(self):
        &#39;&#39;&#39;
            Calls .plotShape() on all subcomponents
            Returns CGsubZ, CGsubY (two lists of scalars for a 2D plot)
        &#39;&#39;&#39;
        CGsubZ = []
        CGsubY = []
        for component in self.components:               
            try:
                component.plotShape()
                initialComponentInertia = component.getInertia(0, self.rocket.rigidBody.state)
                CGsubZ.append(initialComponentInertia.CG.Z)
                CGsubY.append(initialComponentInertia.CG.Y)
            
            except AttributeError:
                pass # Plotting function not implemented
        
        return CGsubZ, CGsubY</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject">CompositeObject</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.Stage.getComponentsOfType"><code class="name flex">
<span>def <span class="ident">getComponentsOfType</span></span>(<span>self, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getComponentsOfType(self, type):
    matchingComponents = []
    for comp in self.components:
        if isinstance(comp, type):
            matchingComponents.append(comp)

    return matchingComponents</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Stage.getLength"><code class="name flex">
<span>def <span class="ident">getLength</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLength(self):
    try:
        topBodyComponent = self._getFirstComponentOfType(self.components, BodyComponent)
        topLocationZ = topBodyComponent.position.Z

        bottomBodyComponent = self._getFirstComponentOfType(reversed(self.components), BodyComponent)
        bottomLocationZ = bottomBodyComponent.position.Z - bottomBodyComponent.length
        return (topLocationZ - bottomLocationZ)
    except AttributeError:
        return None # No body components in current Stage</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Stage.initializeSubComponents"><code class="name flex">
<span>def <span class="ident">initializeSubComponents</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeSubComponents(self):
    # Assume each sub dictionary represents a component
    subDicts = self.stageDictReader.getImmediateSubDicts()

    def returnZeroIfBodyComponent(componentDictPath):
        className = self.stageDictReader.getString(componentDictPath + &#34;.class&#34;)
        componentClass = stringNameToClassMap[className]
        
        if issubclass(componentClass, BodyComponent):
            return 0, componentDictPath
        else: 
            return 1, componentDictPath

    # Make sure BodyComponents are initializede before others
        # This allows non-body components (which are attached to body components) like the fins
            # to get info about the body radius where they&#39;re mounted
    subDicts.sort(key=returnZeroIfBodyComponent)

    # Initialize each component, add to componets
    for componentDict in subDicts:
        newComponent = rocketComponentFactory(componentDict, self.rocket, self)
        self.components.append(newComponent)     

    # Create Planar Interfaces b/w components
    self.components = PlanarInterface.sortByZLocation(self.components)
    self.componentInterfaces = PlanarInterface.createPlanarComponentInterfaces(self.components)      </code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Stage.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls .plotShape() on all subcomponents
Returns CGsubZ, CGsubY (two lists of scalars for a 2D plot)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self):
    &#39;&#39;&#39;
        Calls .plotShape() on all subcomponents
        Returns CGsubZ, CGsubY (two lists of scalars for a 2D plot)
    &#39;&#39;&#39;
    CGsubZ = []
    CGsubY = []
    for component in self.components:               
        try:
            component.plotShape()
            initialComponentInertia = component.getInertia(0, self.rocket.rigidBody.state)
            CGsubZ.append(initialComponentInertia.CG.Z)
            CGsubY.append(initialComponentInertia.CG.Y)
        
        except AttributeError:
            pass # Plotting function not implemented
    
    return CGsubZ, CGsubY</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject">CompositeObject</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.getAeroForce" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.getMass" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.getMass">getMass</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CompositeObject.CompositeObject.recomputeFixedMassInertia" href="CompositeObject.html#MAPLEAF.Rocket.CompositeObject.CompositeObject.recomputeFixedMassInertia">recomputeFixedMassInertia</a></code></li>
</ul>
</li>
<li><code><b><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedAeroForce"><code class="flex name class">
<span>class <span class="ident">TabulatedAeroForce</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>A zero-inertia component with aerodynamic coefficients that are tabulated according to one or more parameters (ex. AOA)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabulatedAeroForce(AeroForce):
    &#39;&#39;&#39; A zero-inertia component with aerodynamic coefficients that are tabulated according to one or more parameters (ex. AOA) &#39;&#39;&#39;

    def __init__(self, componentDictReader, rocket, stage):
        self.componentDictReader = componentDictReader
        self.rocket = rocket
        self.stage = stage
        self.name = componentDictReader.getDictName()

        self.position = componentDictReader.getVector(&#34;position&#34;)
        self.Aref = componentDictReader.getFloat(&#34;Aref&#34;)
        self.Lref = componentDictReader.getFloat(&#34;Lref&#34;)

        coefficientTableFilePath = componentDictReader.getString(&#34;filePath&#34;)
        self._loadCoefficients(coefficientTableFilePath)

    def _loadCoefficients(self, filePath):
        # Load first row to figure out what the columns mean
        with open(filePath) as f:
            columnNames = f.readline().strip().split(&#39;,&#39;)

        # Get functions that calculate the parameters used for interpolation
        # All these &#39;key&#39;/parameter columns are expected to come before &#39;value&#39; columns to be interpolated over
        self.parameterFunctions = []
        i = 0
        while i &lt; len(columnNames):
            col = columnNames[i]
            if col in AeroParameters.stringToAeroFunctionMap:
                self.parameterFunctions.append(AeroParameters.stringToAeroFunctionMap[col])
            else:
                break
            i += 1

        # Continue parsing column names - aero coefficient names now            
        # This is the ordering expected by AeroFunctions.forceFromCoefficients
        aeroCoeffStrings = [ &#34;CD&#34;, &#34;CL&#34;, &#34;CMx&#34;, &#34;CMy&#34;, &#34;CMz&#34; ]
        self.aeroCoeffIndices = [] # Provides mapping between value column position in interpolation table &amp; position in output aero coefficient list (ordered like aeroCoeffStrings above)
        while i &lt; len(columnNames):
            coeff = columnNames[i]

            if coeff in aeroCoeffStrings:
                self.aeroCoeffIndices.append(aeroCoeffStrings.index(coeff))
                
            else:
                raise ValueError(&#34;ERROR: One of the following columns: {} did not match any of the expected columns names: Keys: {}, values: {}. \
                    Or was in the wrong order. All key columns must come BEFORE value columns.&#34;.format(columnNames, AeroParameters.stringToAeroFunctionMap.keys(), aeroCoeffStrings))
            i += 1

        # Load the data table to be interpolated
        dataTable = np.loadtxt(filePath, delimiter=&#39;,&#39;, skiprows=1)

        nKeyCols = len(self.parameterFunctions)
        keys = dataTable[:, 0:nKeyCols]
        aeroCoefficients = dataTable[:, nKeyCols:]

        if nKeyCols &gt; 1:
            # Create n-dimensional interpolation function for aero coefficients
            self._interpAeroCoefficients = LinearNDInterpolator(keys, aeroCoefficients)
        else:
            # Save to use with MAPLEAF.Motion.linInterp
            self.keys = [ key[0] for key in keys ]
            self.values = aeroCoefficients

    def _getAeroCoefficients(self, state, environment):
        keys = AeroParameters.getAeroPropertiesList(self.parameterFunctions, state, environment)

        if len(keys) &gt; 1:
            # Multi-dimensional linear interpolation
            interpolatedCoefficients = self._interpAeroCoefficients(keys)[0]
        else:
            # 1D linear interpolation
            interpolatedCoefficients = linInterp(self.keys, self.values, keys[0])

        aeroCoefficients = [0.0] * 5
        for i in range(len(interpolatedCoefficients)):
            indexInCoeffArray = self.aeroCoeffIndices[i]
            aeroCoefficients[indexInCoeffArray] = interpolatedCoefficients[i]

        return aeroCoefficients

    @logForceResult
    def getAeroForce(self, state, time, environment, rocketCG):
        aeroCoefficients = self._getAeroCoefficients(state, environment)
        return AeroFunctions.forceFromCoefficients(state, environment, *aeroCoefficients, self.position, self.Aref, self.Lref)

    def getLogHeader(self):
        return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.AeroForce" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.AeroForce">AeroForce</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.TabulatedAeroForce.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedAeroForce.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}FX(N) {}FY(N) {}FZ(N) {}MX(Nm) {}MY(Nm) {}MZ(Nm)&#34;.format(*[self.name]*6)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedInertia"><code class="flex name class">
<span>class <span class="ident">TabulatedInertia</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>A zero-force component with time-varying tabulated inertia</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabulatedInertia(RocketComponent):
    &#39;&#39;&#39; A zero-force component with time-varying tabulated inertia &#39;&#39;&#39;
    def __init__(self, componentDictReader, rocket, stage):
        self.rocket = rocket
        self.stage = stage
        self.componentDictReader = componentDictReader
        self.name = componentDictReader.getDictName()

        self.zeroForce = ForceMomentSystem(Vector(0,0,0))

        inertiaTableFilePath = componentDictReader.getString(&#34;filePath&#34;)
        self._parseInertiaTable(inertiaTableFilePath)

    def _parseInertiaTable(self, filePath):
        data = np.loadtxt(filePath, skiprows=1, delimiter=&#39;,&#39;)
        self.times = data[:, 0]
        self.inertiaData = data[:, 1:]

        # Check that the right number of columns is present
        if data.shape[1] != 8:
            raise ValueError(&#34;Wrong number of columns in inertia table: {}. Expecting 8 columns: \
                Time, Mass, CGx, CGy, CGz, MOIx, MOIy, MOIz&#34;)

    def getInertia(self, time, state):
        inertiaData = linInterp(self.times, self.inertiaData, time)
        # MOI is last three columns, CG is the three before that, and mass is column 0
        return Inertia(Vector(*inertiaData[-3:]), Vector(*inertiaData[1:4]), inertiaData[0])
    
    def getAeroForce(self, rocketState, time, environment, CG):
        return self.zeroForce</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.TabulatedInertia.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, rocketState, time, environment, CG)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAeroForce(self, rocketState, time, environment, CG):
    return self.zeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedInertia.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    inertiaData = linInterp(self.times, self.inertiaData, time)
    # MOI is last three columns, CG is the three before that, and mass is column 0
    return Inertia(Vector(*inertiaData[-3:]), Vector(*inertiaData[1:4]), inertiaData[0])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedMotor"><code class="flex name class">
<span>class <span class="ident">TabulatedMotor</span></span>
<span>(</span><span>componentDictReader, rocket, stage)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="interface">Interface</h2>
<p>Initialization:
In rocket text file, attribute: "path", pointing at a motor definition text file
Format:"test/testMotorDefintion.txt"
Functions:
.Thrust(time) returns current thrust level
.OxWeight(time) returns current oxidizer weight
.FuelWeight(time) returns current fuel weight
Attributes:
.initialOxidizerWeight
.initialFuelWeight</p>
<p>All in same units as in the motor definition file (linearly interpolated)
The motor is assumed to apply zero moment to the rocket, thrust is applied in z-direction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TabulatedMotor(RocketComponent):
    &#39;&#39;&#39;
    Interface:
        Initialization:
            In rocket text file, attribute: &#34;path&#34;, pointing at a motor definition text file
            Format:&#34;test/testMotorDefintion.txt&#34;
        Functions:
            .Thrust(time) returns current thrust level
            .OxWeight(time) returns current oxidizer weight
            .FuelWeight(time) returns current fuel weight
        Attributes:
            .initialOxidizerWeight
            .initialFuelWeight

        All in same units as in the motor definition file (linearly interpolated)
        The motor is assumed to apply zero moment to the rocket, thrust is applied in z-direction
    &#39;&#39;&#39;

    #### Init Functions ####
    def __init__(self, componentDictReader, rocket, stage):
        #TODO: Oxidizer and Fuel CG Locations should be defined relative to the motor location
        self.rocket = rocket
        self.stage = stage
        self.componentDictReader = componentDictReader
        self.name = componentDictReader.getDictName()

        stage.motor = self
        self.classType = componentDictReader.getString(&#34;class&#34;)
        self.ignitionTime = 0 # Modified by Rocket._initializeStaging and Rocket._stageSeparation

        # Impulse adjustments (mostly for Monte Carlo sims)
        self.impulseAdjustFactor = componentDictReader.getFloat(&#34;impulseAdjustFactor&#34;)
        self.burnTimeAdjustFactor = componentDictReader.getFloat(&#34;burnTimeAdjustFactor&#34;)

        motorFilePath = componentDictReader.getString(&#34;path&#34;)
        self._parseMotorDefinitionFile(motorFilePath)

        # Set the position to the initial CG location
        initInertia = self.getInertia(0, &#34;fakeState&#34;)
        self.position = initInertia.CG

    #TODO: Build converter/parser for standard engine format like rasp/.eng or something like that

    def _parseMotorDefinitionFile(self, motorFilePath):
        &#39;&#39;&#39; Parses a motor definition text file. See MAPLEAF/Examples/Motors for examples &#39;&#39;&#39;
      
        # Get motor definition text
        with open(motorFilePath, &#34;r&#34;) as motorFile:
            motorFileText = motorFile.read()

        # Remove all comment rows
        comment = re.compile(&#34;#.*&#34;) 
        motorFileText = re.sub(comment, &#34;&#34;, motorFileText)
        
        #Remove blank lines
        motorFileText = [line for line in motorFileText.split(&#39;\n&#39;) if line.strip() != &#39;&#39;]
        
        # Parse CG locations
        # TODO: Future motors should be able to exist off the rocket&#39;s center axis
        self.initOxCG_Z = float(motorFileText[0].split()[1]) + self.stage.position.Z
        self.finalOxCG_Z = float(motorFileText[1].split()[1]) + self.stage.position.Z
        self.initFuelCG_Z = float(motorFileText[2].split()[1]) + self.stage.position.Z
        self.finalFuelCG_Z = float(motorFileText[3].split()[1]) + self.stage.position.Z
        motorFileText = motorFileText[4:]

        # Parse data; Columns defined in MAPLEAF/Examples/Motors/test.txt
        # Gets defined values for: Time, thrust, oxFlowRate, fuelFlowRate, oxMOI, fuelMOI
        self.times = []
        self.thrustLevels = []
        oxFlowRate = []
        fuelFlowRate = []
        self.oxMOIs = []
        self.fuelMOIs = []
        for dataLine in motorFileText:
            # Splits line at each white space
            info = dataLine.split()

            self.times.append(float(info[0]))
            self.thrustLevels.append(float(info[1]))
            oxFlowRate.append(float(info[2]))
            fuelFlowRate.append(float(info[3]))
            
            oxVecStartIndex = dataLine.index(&#39;(&#39;)
            oxVecEndIndex = dataLine.index(&#39;)&#39;, oxVecStartIndex)+1
            oxVecString  = dataLine[oxVecStartIndex:oxVecEndIndex]
            oxMOIVec = Vector(oxVecString)
            self.oxMOIs.append(oxMOIVec)

            fuelVecStartIndex = dataLine.index(&#39;(&#39;, oxVecEndIndex)
            fuelVecEndIndex = dataLine.index(&#39;)&#39;, fuelVecStartIndex)+1
            fuelVecString  = dataLine[fuelVecStartIndex:fuelVecEndIndex]
            fuelMOIVec = Vector(fuelVecString)
            self.fuelMOIs.append(fuelMOIVec)

        # Tell the rocket and stage when their engines shut off -&gt; used for flight animations
        self.stage.engineShutOffTime = self.times[-1]
        if self.rocket.engineShutOffTime == None:
            self.rocket.engineShutOffTime = self.times[-1]
        else:
            self.rocket.engineShutOffTime = max(self.rocket.engineShutOffTime, self.times[-1])

        # Apply adjustment factors for monte carlo sims
        self.thrustLevels = [ thrust*self.impulseAdjustFactor/self.burnTimeAdjustFactor for thrust in self.thrustLevels ]
        self.times = [ t*self.burnTimeAdjustFactor for t in self.times ]

        # Calculate initial fuel and oxidizer masses through trapezoid rule
        # Trapezoid rule matches the linear interpolation used to find thrust values
        self.initialOxidizerWeight = 0
        self.initialFuelWeight = 0
        self.oxWeights = [ 0 ]
        self.fuelWeights = [ 0 ]
        for i in range(len(self.times)-1, 0, -1):
            deltaT = self.times[i] - self.times[i-1]
            def integrateVal(value, sum, timeSeries):
                sum += deltaT * (value[i-1] + value[i]) / 2
                timeSeries.insert(0, sum)
                return sum

            self.initialOxidizerWeight = integrateVal(oxFlowRate, self.initialOxidizerWeight, self.oxWeights)
            self.initialFuelWeight = integrateVal(fuelFlowRate, self.initialFuelWeight, self.fuelWeights)

    #### Operational Functions ####
    def getInertia(self, time, state):
        timeSinceIgnition = max(0, time - self.ignitionTime)

        oxInertia = self._getOxInertia(timeSinceIgnition)
        fuelInertia = self._getFuelInertia(timeSinceIgnition)
        
        return oxInertia + fuelInertia

    def getAeroForce(self, state, time, environment, CG):
        #TODO: Model &#34;thrust damping&#34; - where gases moving quickly in the engine act to damp out rotation about the x and y axes
        #TODO: Thrust vs altitude compensation
        timeSinceIgnition = max(0, time - self.ignitionTime)
        
        # Determine thrust magnitude
        if timeSinceIgnition &lt; 0 or timeSinceIgnition &gt; self.times[-1]:
            thrustMagnitude = 0
        else:
            thrustMagnitude = linInterp(self.times, self.thrustLevels, timeSinceIgnition)
        
        # Create Vector
        thrust = Vector(0,0, thrustMagnitude)

        # Log and return
        self.rocket.appendToForceLogLine(&#34; {:&gt;10.4f}&#34;.format(thrust.Z))
        return ForceMomentSystem(thrust)

    def updateIgnitionTime(self, ignitionTime, fakeValue=False):
        self.ignitionTime = ignitionTime
        if not fakeValue:
            self.rocket.engineShutOffTime = max(self.rocket.engineShutOffTime, self.ignitionTime + self.times[-1])
            self.stage.engineShutOffTime = self.ignitionTime + self.times[-1]

    def getLogHeader(self):
        return &#34; {}Thrust(N)&#34;.format(self.name)

    def getTotalImpulse(self):
        # Integrate the thrust - assume linear interpolations between points given -&gt; midpoint rule integrates this perfectly
        totalImpulse = 0
        for i in range(1, len(self.times)):
            deltaT = self.times[i] - self.times[i-1]
            totalImpulse += deltaT * (self.thrustLevels[i-1] + self.thrustLevels[i]) / 2
        
        return totalImpulse

    def _getMass(self, timeSinceIgnition):
        return self.OxWeight(timeSinceIgnition) + self.FuelWeight(timeSinceIgnition)

    def _getOxInertia(self, timeSinceIgnition):
        if self.initialOxidizerWeight == 0:
            return Inertia(Vector(0,0,0), Vector(0,0,0), 0)

        oxWeight = linInterp(self.times, self.oxWeights, timeSinceIgnition)
        
        # Find fraction of oxidizer burned
        oxBurnedFrac = 1 - (oxWeight/self.initialOxidizerWeight)
        
        #Linearly interpolate CG location based on fraction of oxidizer burned
        oxCG_Z = self.initOxCG_Z*(1 - oxBurnedFrac) + self.finalOxCG_Z*oxBurnedFrac
        #TODO: Allow motor(s) to be defined off-axis
        oxCG = Vector(0,0,oxCG_Z)

        # Get MOI
        oxMOI = linInterp(self.times, self.oxMOIs, timeSinceIgnition)
        
        return Inertia(oxMOI, oxCG, oxWeight)

    def _getFuelInertia(self, timeSinceIgnition):
        if self.initialFuelWeight == 0:
            return Inertia(Vector(0,0,0), Vector(0,0,0), 0)

        #See comments in _getOxInertia()
        fuelWeight = linInterp(self.times, self.fuelWeights, timeSinceIgnition)

        fuelBurnedFrac = 1 - (fuelWeight / self.initialFuelWeight)

        fuelCG_Z = self.initFuelCG_Z*(1 - fuelBurnedFrac) + self.finalFuelCG_Z*fuelBurnedFrac
        fuelCG = Vector(0,0,fuelCG_Z)

        fuelMOI = linInterp(self.times, self.fuelMOIs, timeSinceIgnition)

        return Inertia(fuelMOI, fuelCG, fuelWeight)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.TabulatedMotor.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>self, state, time, environment, CG)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAeroForce(self, state, time, environment, CG):
    #TODO: Model &#34;thrust damping&#34; - where gases moving quickly in the engine act to damp out rotation about the x and y axes
    #TODO: Thrust vs altitude compensation
    timeSinceIgnition = max(0, time - self.ignitionTime)
    
    # Determine thrust magnitude
    if timeSinceIgnition &lt; 0 or timeSinceIgnition &gt; self.times[-1]:
        thrustMagnitude = 0
    else:
        thrustMagnitude = linInterp(self.times, self.thrustLevels, timeSinceIgnition)
    
    # Create Vector
    thrust = Vector(0,0, thrustMagnitude)

    # Log and return
    self.rocket.appendToForceLogLine(&#34; {:&gt;10.4f}&#34;.format(thrust.Z))
    return ForceMomentSystem(thrust)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedMotor.getInertia"><code class="name flex">
<span>def <span class="ident">getInertia</span></span>(<span>self, time, state)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertia(self, time, state):
    timeSinceIgnition = max(0, time - self.ignitionTime)

    oxInertia = self._getOxInertia(timeSinceIgnition)
    fuelInertia = self._getFuelInertia(timeSinceIgnition)
    
    return oxInertia + fuelInertia</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedMotor.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; {}Thrust(N)&#34;.format(self.name)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedMotor.getTotalImpulse"><code class="name flex">
<span>def <span class="ident">getTotalImpulse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTotalImpulse(self):
    # Integrate the thrust - assume linear interpolations between points given -&gt; midpoint rule integrates this perfectly
    totalImpulse = 0
    for i in range(1, len(self.times)):
        deltaT = self.times[i] - self.times[i-1]
        totalImpulse += deltaT * (self.thrustLevels[i-1] + self.thrustLevels[i]) / 2
    
    return totalImpulse</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.TabulatedMotor.updateIgnitionTime"><code class="name flex">
<span>def <span class="ident">updateIgnitionTime</span></span>(<span>self, ignitionTime, fakeValue=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateIgnitionTime(self, ignitionTime, fakeValue=False):
    self.ignitionTime = ignitionTime
    if not fakeValue:
        self.rocket.engineShutOffTime = max(self.rocket.engineShutOffTime, self.ignitionTime + self.times[-1])
        self.stage.engineShutOffTime = self.ignitionTime + self.times[-1]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Rocket.Transition"><code class="flex name class">
<span>class <span class="ident">Transition</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Models a conical diameter transition (growing or shrinking) </p>
<p>Two possible sets of inputs:<br>
1. Initialization as a regular, dictionary-defined rocket component:<br>
* args = (componentDictReader, rocket, stage)<br>
* Expected classes: (<code><a title="MAPLEAF.IO.SubDictReader" href="../IO/index.html#MAPLEAF.IO.SubDictReader">SubDictReader</a></code>, <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code>, <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code>)<br>
2. Manual initialization:<br>
* args = (startDiameter, endDiameter, length, position, inertia, rocket, stage, name, surfaceRoughness)<br>
* Expected classes: (float, float, float, <code><a title="MAPLEAF.Motion.Vector" href="../Motion/index.html#MAPLEAF.Motion.Vector">Vector</a></code>, <code><a title="MAPLEAF.Motion.Inertia" href="../Motion/index.html#MAPLEAF.Motion.Inertia">Inertia</a></code>, <code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code>, <code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code>, str, float)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transition(FixedMass, BodyComponent):
    &#39;&#39;&#39; Models a conical diameter transition (growing or shrinking) &#39;&#39;&#39;

    def __init__(self, *args):
        &#39;&#39;&#39;
            Two possible sets of inputs:  
            1. Initialization as a regular, dictionary-defined rocket component:  
                * args = (componentDictReader, rocket, stage)  
                * Expected classes: (`MAPLEAF.IO.SubDictReader`, `MAPLEAF.Rocket.Rocket`, `MAPLEAF.Rocket.Stage`)  
            2. Manual initialization:  
                * args = (startDiameter, endDiameter, length, position, inertia, rocket, stage, name, surfaceRoughness)  
                * Expected classes: (float, float, float, `MAPLEAF.Motion.Vector`, `MAPLEAF.Motion.Inertia`, `MAPLEAF.Rocket.Rocket`, `MAPLEAF.Rocket.Stage`, str, float)  
        &#39;&#39;&#39;
        if len(args) == 3:
            # Classic initialization from componentDictReader
            componentDictReader, rocket, stage = args
            FixedMass.__init__(self, componentDictReader, rocket, stage)

            self.length = componentDictReader.getFloat(&#34;length&#34;)
            self.startDiameter = componentDictReader.getFloat(&#34;startDiameter&#34;)
            self.endDiameter = componentDictReader.getFloat(&#34;endDiameter&#34;)
            self.surfaceRoughness = componentDictReader.tryGetFloat(&#34;surfaceRoughness&#34;, defaultValue=self.rocket.surfaceRoughness)
        else:
            # Initialization from parameters passed in
            self.startDiameter, self.endDiameter, self.length, self.position, self.inertia, self.rocket, self.stage, self.name, self.surfaceRoughness = args

        self._precomputeGeometry()

    def _precomputeGeometry(self):
        # Calculate basic areas
        self.topArea = self.startDiameter**2 * math.pi/4
        self.bottomArea = self.endDiameter**2 * math.pi/4
        self.frontalArea = abs(self.topArea - self.bottomArea)

        # Calculate surface area, volume, CP
        if self.length == 0:
            self.wettedArea = 0.0
            self.volume = 0.0
            self.CPLocation = self.position
        else:
            maxDiameter = max(self.startDiameter, self.endDiameter)
            minDiameter = min(self.startDiameter, self.endDiameter)

            hypotenuseSlope = ((maxDiameter - minDiameter) / self.length)
            # Boat tail is a truncated cone
            # Compute surface area of non-truncated cone starting at top of boattail
            baseConeHeight = maxDiameter / hypotenuseSlope
            baseHypotenuse = math.sqrt((maxDiameter/2)**2 + baseConeHeight**2)
            fullConeSurfaceArea = math.pi * (maxDiameter/2) * baseHypotenuse
            # Compute surface area of non-truncated cone starting at bottom of boattail
            tipConeHeight = minDiameter / hypotenuseSlope
            tipHypotenuse = math.sqrt((minDiameter/2)**2 + tipConeHeight**2)
            tipConeSurfaceArea = math.pi * (minDiameter/2) * tipHypotenuse
            # Surface area is the difference b/w the two
            self.wettedArea = fullConeSurfaceArea - tipConeSurfaceArea

            # Volume calculation uses same method as surface area calculation above
            fullConeVolume = self.topArea * baseConeHeight / 3
            tipConeVolume = self.bottomArea * tipConeHeight / 3
            self.volume = fullConeVolume - tipConeVolume

            # Calculate CP
            self.CPLocation = AeroFunctions.Barrowman_GetCPLocation(self.length, self.topArea, self.bottomArea, self.volume, self.position)

        # Calc aspect ratio
        if self.startDiameter == self.endDiameter:
            aspectRatio = 100 # Avoid division by zero
        else:
            aspectRatio = self.length / abs(self.startDiameter - self.endDiameter)

        # Precompute drag properties
        if self.endDiameter &lt;= self.startDiameter:
            # Calculate Cd multiplier based on aspect ratio - Niskanen Eqn 3.88
            if aspectRatio &lt; 1:
                self.CdAdjustmentFactor = 1
            elif aspectRatio &lt; 3:
                self.CdAdjustmentFactor = (3 - aspectRatio) / 2
            else:
                self.CdAdjustmentFactor = 0
        else:
            if self.length == 0:
                coneHalfAngle = math.pi/2
            else:
                coneHalfAngle = math.atan(abs(self.startDiameter - self.endDiameter)/2 / self.length)

            self.coneHalfAngle = coneHalfAngle
            self.SubsonicCdPolyCoeffs = computeSubsonicPolyCoeffs(coneHalfAngle)
            self.TransonicCdPolyCoeffs = computeTransonicPolyCoeffs(coneHalfAngle)

    def plotShape(self):
        import matplotlib.pyplot as plt
        Xvals = []
        Yvals = []

        forePos = self.position.Z
        aftPos = forePos - self.length
        foreRadius = self.startDiameter/2
        aftRadius = self.endDiameter/2

        Xvals.append(forePos)
        Yvals.append(foreRadius) # top right

        Xvals.append(aftPos)
        Yvals.append(aftRadius) # top left

        Xvals.append(aftPos)
        Yvals.append(-aftRadius) # bottom left

        Xvals.append(forePos)
        Yvals.append(-foreRadius) # bottom right

        Xvals.append(forePos)
        Yvals.append(foreRadius) # close in the shape
        plt.plot(Xvals, Yvals, color = &#39;k&#39;)

    @logForceResult
    def getAeroForce(self, rocketState, time, environment, CG) -&gt; ForceMomentSystem:
        Mach = AeroParameters.getMachNumber(rocketState, environment)
        Aref = self.rocket.Aref
        
        #### Normal Force ####
        AOA = AeroParameters.getTotalAOA(rocketState, environment)
        CN = AeroFunctions.Barrowman_GetCN(AOA, Aref, self.topArea, self.bottomArea)

        #### Pressure Drag ####
        if self.startDiameter &gt; self.endDiameter:
            # Pressure base drag
            Cd_base = AeroFunctions.getBaseDragCoefficient(Mach)
            Cd_pressure = Cd_base * self.CdAdjustmentFactor

        else:
            # Pressure drag calculated like a nose cone
            if Mach &lt; 1:
                # Niskanen pg. 48 eq. 3.87 - Power law interpolation
                Cd_pressure = self.SubsonicCdPolyCoeffs[0] * Mach**self.SubsonicCdPolyCoeffs[1]

            elif Mach &gt; 1 and Mach &lt; 1.3:
                # Interpolate in transonic region - derived from Niskanen Appendix B, Eqns B.3 - B.6
                Cd_pressure = self.TransonicCdPolyCoeffs[0] + self.TransonicCdPolyCoeffs[1]*Mach +  \
                    self.TransonicCdPolyCoeffs[2]*Mach**2 + self.TransonicCdPolyCoeffs[3]*Mach**3
                
            else:
                Cd_pressure = getSupersonicPressureDragCoeff_Hoerner(self.coneHalfAngle, Mach)
        
        # Make reference are the rocket&#39;s, not this objects
        Cd_pressure *= self.frontalArea / Aref 

        #### Skin Friction Drag ####
        if self.wettedArea == 0:
            skinFrictionDragCoefficient = 0
            rollDampingMoment = Vector(0,0,0)
        else:
            skinFrictionDragCoefficient, rollDampingMoment = AeroFunctions.getCylindricalSkinFrictionDragCoefficientAndRollDampingMoment(rocketState, environment, \
                 self.length, Mach, self.surfaceRoughness, self.wettedArea, Aref, self.rocket.finenessRatio, self.rocket.fullyTurbulentBL)

        #### Total Drag ####
        Cd = Cd_pressure + skinFrictionDragCoefficient

        #### Assemble &amp; return final force object ####
        return AeroFunctions.forceFromCdCN(rocketState, environment, Cd, CN, self.CPLocation, Aref, moment=rollDampingMoment)

    def getMaxDiameter(self):
        return max(self.startDiameter, self.endDiameter)

    def getRadius(self, distanceFromTip):
        return (distanceFromTip/self.length * (self.endDiameter - self.startDiameter) + self.startDiameter) / 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.RocketComponents.FixedMass" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.FixedMass">FixedMass</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.RocketComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.RocketComponent">RocketComponent</a></li>
<li><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.Rocket.boatTail.BoatTail" href="boatTail.html#MAPLEAF.Rocket.boatTail.BoatTail">BoatTail</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Rocket.Transition.getAeroForce"><code class="name flex">
<span>def <span class="ident">getAeroForce</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loggedAeroFunction(*args):
    aeroForce = func(*args)
    
    # Log to force evaluation log
    rocketComponent = args[0]
    rocketComponent.rocket.appendToForceLogLine(&#34; {:&gt;10.4f} {:&gt;10.4f}&#34;.format(aeroForce.force, aeroForce.moment))
    
    return aeroForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Rocket.Transition.plotShape"><code class="name flex">
<span>def <span class="ident">plotShape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotShape(self):
    import matplotlib.pyplot as plt
    Xvals = []
    Yvals = []

    forePos = self.position.Z
    aftPos = forePos - self.length
    foreRadius = self.startDiameter/2
    aftRadius = self.endDiameter/2

    Xvals.append(forePos)
    Yvals.append(foreRadius) # top right

    Xvals.append(aftPos)
    Yvals.append(aftRadius) # top left

    Xvals.append(aftPos)
    Yvals.append(-aftRadius) # bottom left

    Xvals.append(forePos)
    Yvals.append(-foreRadius) # bottom right

    Xvals.append(forePos)
    Yvals.append(foreRadius) # close in the shape
    plt.plot(Xvals, Yvals, color = &#39;k&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent">BodyComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation" href="RocketComponents.html#MAPLEAF.Rocket.RocketComponents.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#approximate-material-roughnesses">Approximate Material Roughnesses</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF" href="../index.html">MAPLEAF</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="MAPLEAF.Rocket.AeroFunctions" href="AeroFunctions.html">MAPLEAF.Rocket.AeroFunctions</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CompositeObject" href="CompositeObject.html">MAPLEAF.Rocket.CompositeObject</a></code></li>
<li><code><a title="MAPLEAF.Rocket.CythonFinFunctions" href="CythonFinFunctions.html">MAPLEAF.Rocket.CythonFinFunctions</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Fins" href="Fins.html">MAPLEAF.Rocket.Fins</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Propulsion" href="Propulsion.html">MAPLEAF.Rocket.Propulsion</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Recovery" href="Recovery.html">MAPLEAF.Rocket.Recovery</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponentFactory" href="RocketComponentFactory.html">MAPLEAF.Rocket.RocketComponentFactory</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponents" href="RocketComponents.html">MAPLEAF.Rocket.RocketComponents</a></code></li>
<li><code><a title="MAPLEAF.Rocket.boatTail" href="boatTail.html">MAPLEAF.Rocket.boatTail</a></code></li>
<li><code><a title="MAPLEAF.Rocket.bodyTube" href="bodyTube.html">MAPLEAF.Rocket.bodyTube</a></code></li>
<li><code><a title="MAPLEAF.Rocket.noseCone" href="noseCone.html">MAPLEAF.Rocket.noseCone</a></code></li>
<li><code><a title="MAPLEAF.Rocket.rocket" href="rocket.html">MAPLEAF.Rocket.rocket</a></code></li>
<li><code><a title="MAPLEAF.Rocket.simEventDetector" href="simEventDetector.html">MAPLEAF.Rocket.simEventDetector</a></code></li>
<li><code><a title="MAPLEAF.Rocket.stage" href="stage.html">MAPLEAF.Rocket.stage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.rocketComponentFactory" href="#MAPLEAF.Rocket.rocketComponentFactory">rocketComponentFactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.Rocket.AeroDamping" href="#MAPLEAF.Rocket.AeroDamping">AeroDamping</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.AeroDamping.getAeroForce" href="#MAPLEAF.Rocket.AeroDamping.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.AeroDamping.position" href="#MAPLEAF.Rocket.AeroDamping.position">position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.AeroForce" href="#MAPLEAF.Rocket.AeroForce">AeroForce</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.AeroForce.getAeroForce" href="#MAPLEAF.Rocket.AeroForce.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.AeroForce.getInertia" href="#MAPLEAF.Rocket.AeroForce.getInertia">getInertia</a></code></li>
<li><code><a title="MAPLEAF.Rocket.AeroForce.getLogHeader" href="#MAPLEAF.Rocket.AeroForce.getLogHeader">getLogHeader</a></code></li>
<li><code><a title="MAPLEAF.Rocket.AeroForce.inertia" href="#MAPLEAF.Rocket.AeroForce.inertia">inertia</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.BoatTail" href="#MAPLEAF.Rocket.BoatTail">BoatTail</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.BoatTail.canConnectToComponentBelow" href="#MAPLEAF.Rocket.BoatTail.canConnectToComponentBelow">canConnectToComponentBelow</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BoatTail.getAeroForce" href="#MAPLEAF.Rocket.BoatTail.getAeroForce">getAeroForce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.BodyComponent" href="#MAPLEAF.Rocket.BodyComponent">BodyComponent</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.BodyComponent.canConnectToComponentAbove" href="#MAPLEAF.Rocket.BodyComponent.canConnectToComponentAbove">canConnectToComponentAbove</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.canConnectToComponentBelow" href="#MAPLEAF.Rocket.BodyComponent.canConnectToComponentBelow">canConnectToComponentBelow</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.getBottomInterfaceLocation" href="#MAPLEAF.Rocket.BodyComponent.getBottomInterfaceLocation">getBottomInterfaceLocation</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.getLogHeader" href="#MAPLEAF.Rocket.BodyComponent.getLogHeader">getLogHeader</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.getMaxDiameter" href="#MAPLEAF.Rocket.BodyComponent.getMaxDiameter">getMaxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.getRadius" href="#MAPLEAF.Rocket.BodyComponent.getRadius">getRadius</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyComponent.getTopInterfaceLocation" href="#MAPLEAF.Rocket.BodyComponent.getTopInterfaceLocation">getTopInterfaceLocation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.BodyTube" href="#MAPLEAF.Rocket.BodyTube">BodyTube</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.BodyTube.getAeroForce" href="#MAPLEAF.Rocket.BodyTube.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.BodyTube.plotShape" href="#MAPLEAF.Rocket.BodyTube.plotShape">plotShape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.EventTypes" href="#MAPLEAF.Rocket.EventTypes">EventTypes</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.EventTypes.Apogee" href="#MAPLEAF.Rocket.EventTypes.Apogee">Apogee</a></code></li>
<li><code><a title="MAPLEAF.Rocket.EventTypes.AscendingThroughAltitude" href="#MAPLEAF.Rocket.EventTypes.AscendingThroughAltitude">AscendingThroughAltitude</a></code></li>
<li><code><a title="MAPLEAF.Rocket.EventTypes.DescendingThroughAltitude" href="#MAPLEAF.Rocket.EventTypes.DescendingThroughAltitude">DescendingThroughAltitude</a></code></li>
<li><code><a title="MAPLEAF.Rocket.EventTypes.MotorBurnout" href="#MAPLEAF.Rocket.EventTypes.MotorBurnout">MotorBurnout</a></code></li>
<li><code><a title="MAPLEAF.Rocket.EventTypes.TimeReached" href="#MAPLEAF.Rocket.EventTypes.TimeReached">TimeReached</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.Fin" href="#MAPLEAF.Rocket.Fin">Fin</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.Fin.finSet" href="#MAPLEAF.Rocket.Fin.finSet">finSet</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Fin.getAeroForce" href="#MAPLEAF.Rocket.Fin.getAeroForce">getAeroForce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.FinSet" href="#MAPLEAF.Rocket.FinSet">FinSet</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.FinSet.getAeroForce" href="#MAPLEAF.Rocket.FinSet.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FinSet.getChord" href="#MAPLEAF.Rocket.FinSet.getChord">getChord</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FinSet.getLogHeader" href="#MAPLEAF.Rocket.FinSet.getLogHeader">getLogHeader</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FinSet.plotShape" href="#MAPLEAF.Rocket.FinSet.plotShape">plotShape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.FixedForce" href="#MAPLEAF.Rocket.FixedForce">FixedForce</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.FixedForce.getAeroForce" href="#MAPLEAF.Rocket.FixedForce.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FixedForce.getInertia" href="#MAPLEAF.Rocket.FixedForce.getInertia">getInertia</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FixedForce.getLogHeader" href="#MAPLEAF.Rocket.FixedForce.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.FixedMass" href="#MAPLEAF.Rocket.FixedMass">FixedMass</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.FixedMass.getAeroForce" href="#MAPLEAF.Rocket.FixedMass.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FixedMass.getCG" href="#MAPLEAF.Rocket.FixedMass.getCG">getCG</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FixedMass.getInertia" href="#MAPLEAF.Rocket.FixedMass.getInertia">getInertia</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FixedMass.getMass" href="#MAPLEAF.Rocket.FixedMass.getMass">getMass</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.FractionalJetDamping" href="#MAPLEAF.Rocket.FractionalJetDamping">FractionalJetDamping</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.FractionalJetDamping.getAeroForce" href="#MAPLEAF.Rocket.FractionalJetDamping.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FractionalJetDamping.getInertia" href="#MAPLEAF.Rocket.FractionalJetDamping.getInertia">getInertia</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FractionalJetDamping.getLogHeader" href="#MAPLEAF.Rocket.FractionalJetDamping.getLogHeader">getLogHeader</a></code></li>
<li><code><a title="MAPLEAF.Rocket.FractionalJetDamping.inertia" href="#MAPLEAF.Rocket.FractionalJetDamping.inertia">inertia</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.NoseCone" href="#MAPLEAF.Rocket.NoseCone">NoseCone</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.NoseCone.aspectRatio" href="#MAPLEAF.Rocket.NoseCone.aspectRatio">aspectRatio</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.baseDiameter" href="#MAPLEAF.Rocket.NoseCone.baseDiameter">baseDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.canConnectToComponentAbove" href="#MAPLEAF.Rocket.NoseCone.canConnectToComponentAbove">canConnectToComponentAbove</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.getAeroForce" href="#MAPLEAF.Rocket.NoseCone.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.length" href="#MAPLEAF.Rocket.NoseCone.length">length</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.plotShape" href="#MAPLEAF.Rocket.NoseCone.plotShape">plotShape</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.shape" href="#MAPLEAF.Rocket.NoseCone.shape">shape</a></code></li>
<li><code><a title="MAPLEAF.Rocket.NoseCone.surfaceRoughness" href="#MAPLEAF.Rocket.NoseCone.surfaceRoughness">surfaceRoughness</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.PlanarInterface" href="#MAPLEAF.Rocket.PlanarInterface">PlanarInterface</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.PlanarInterface.createPlanarComponentInterfaces" href="#MAPLEAF.Rocket.PlanarInterface.createPlanarComponentInterfaces">createPlanarComponentInterfaces</a></code></li>
<li><code><a title="MAPLEAF.Rocket.PlanarInterface.sortByZLocation" href="#MAPLEAF.Rocket.PlanarInterface.sortByZLocation">sortByZLocation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.RecoverySystem" href="#MAPLEAF.Rocket.RecoverySystem">RecoverySystem</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.RecoverySystem.getAeroForce" href="#MAPLEAF.Rocket.RecoverySystem.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RecoverySystem.getLogHeader" href="#MAPLEAF.Rocket.RecoverySystem.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.Rocket" href="#MAPLEAF.Rocket.Rocket">Rocket</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.Rocket.Aref" href="#MAPLEAF.Rocket.Rocket.Aref">Aref</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.addZeroLengthBoatTailsToAccountForBaseDrag" href="#MAPLEAF.Rocket.Rocket.addZeroLengthBoatTailsToAccountForBaseDrag">addZeroLengthBoatTailsToAccountForBaseDrag</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.appendToForceLogLine" href="#MAPLEAF.Rocket.Rocket.appendToForceLogLine">appendToForceLogLine</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.controlSystem" href="#MAPLEAF.Rocket.Rocket.controlSystem">controlSystem</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.engineShutOffTime" href="#MAPLEAF.Rocket.Rocket.engineShutOffTime">engineShutOffTime</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.environment" href="#MAPLEAF.Rocket.Rocket.environment">environment</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.eventTimeStep" href="#MAPLEAF.Rocket.Rocket.eventTimeStep">eventTimeStep</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.finenessRatio" href="#MAPLEAF.Rocket.Rocket.finenessRatio">finenessRatio</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.fullyTurbulentBL" href="#MAPLEAF.Rocket.Rocket.fullyTurbulentBL">fullyTurbulentBL</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.getLength" href="#MAPLEAF.Rocket.Rocket.getLength">getLength</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.isUnderChute" href="#MAPLEAF.Rocket.Rocket.isUnderChute">isUnderChute</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.mainChuteDeployTime" href="#MAPLEAF.Rocket.Rocket.mainChuteDeployTime">mainChuteDeployTime</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.maxDiameter" href="#MAPLEAF.Rocket.Rocket.maxDiameter">maxDiameter</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.plotShape" href="#MAPLEAF.Rocket.Rocket.plotShape">plotShape</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.recoverySystem" href="#MAPLEAF.Rocket.Rocket.recoverySystem">recoverySystem</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.rigidBody" href="#MAPLEAF.Rocket.Rocket.rigidBody">rigidBody</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.silent" href="#MAPLEAF.Rocket.Rocket.silent">silent</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.simEventDetector" href="#MAPLEAF.Rocket.Rocket.simEventDetector">simEventDetector</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.simRunner" href="#MAPLEAF.Rocket.Rocket.simRunner">simRunner</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.stage" href="#MAPLEAF.Rocket.Rocket.stage">stage</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.stages" href="#MAPLEAF.Rocket.Rocket.stages">stages</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.surfaceRoughness" href="#MAPLEAF.Rocket.Rocket.surfaceRoughness">surfaceRoughness</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.timeStep" href="#MAPLEAF.Rocket.Rocket.timeStep">timeStep</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Rocket.turbulenceOffWhenUnderChute" href="#MAPLEAF.Rocket.Rocket.turbulenceOffWhenUnderChute">turbulenceOffWhenUnderChute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.RocketComponent" href="#MAPLEAF.Rocket.RocketComponent">RocketComponent</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.RocketComponent.getAeroForce" href="#MAPLEAF.Rocket.RocketComponent.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.RocketComponent.getInertia" href="#MAPLEAF.Rocket.RocketComponent.getInertia">getInertia</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.SimEventDetector" href="#MAPLEAF.Rocket.SimEventDetector">SimEventDetector</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.SimEventDetector.subscribeToEvent" href="#MAPLEAF.Rocket.SimEventDetector.subscribeToEvent">subscribeToEvent</a></code></li>
<li><code><a title="MAPLEAF.Rocket.SimEventDetector.triggerEvents" href="#MAPLEAF.Rocket.SimEventDetector.triggerEvents">triggerEvents</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.Stage" href="#MAPLEAF.Rocket.Stage">Stage</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.Stage.getComponentsOfType" href="#MAPLEAF.Rocket.Stage.getComponentsOfType">getComponentsOfType</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Stage.getLength" href="#MAPLEAF.Rocket.Stage.getLength">getLength</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Stage.initializeSubComponents" href="#MAPLEAF.Rocket.Stage.initializeSubComponents">initializeSubComponents</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Stage.plotShape" href="#MAPLEAF.Rocket.Stage.plotShape">plotShape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.TabulatedAeroForce" href="#MAPLEAF.Rocket.TabulatedAeroForce">TabulatedAeroForce</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.TabulatedAeroForce.getAeroForce" href="#MAPLEAF.Rocket.TabulatedAeroForce.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedAeroForce.getLogHeader" href="#MAPLEAF.Rocket.TabulatedAeroForce.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.TabulatedInertia" href="#MAPLEAF.Rocket.TabulatedInertia">TabulatedInertia</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.TabulatedInertia.getAeroForce" href="#MAPLEAF.Rocket.TabulatedInertia.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedInertia.getInertia" href="#MAPLEAF.Rocket.TabulatedInertia.getInertia">getInertia</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.TabulatedMotor" href="#MAPLEAF.Rocket.TabulatedMotor">TabulatedMotor</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.TabulatedMotor.getAeroForce" href="#MAPLEAF.Rocket.TabulatedMotor.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedMotor.getInertia" href="#MAPLEAF.Rocket.TabulatedMotor.getInertia">getInertia</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedMotor.getLogHeader" href="#MAPLEAF.Rocket.TabulatedMotor.getLogHeader">getLogHeader</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedMotor.getTotalImpulse" href="#MAPLEAF.Rocket.TabulatedMotor.getTotalImpulse">getTotalImpulse</a></code></li>
<li><code><a title="MAPLEAF.Rocket.TabulatedMotor.updateIgnitionTime" href="#MAPLEAF.Rocket.TabulatedMotor.updateIgnitionTime">updateIgnitionTime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Rocket.Transition" href="#MAPLEAF.Rocket.Transition">Transition</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Rocket.Transition.getAeroForce" href="#MAPLEAF.Rocket.Transition.getAeroForce">getAeroForce</a></code></li>
<li><code><a title="MAPLEAF.Rocket.Transition.plotShape" href="#MAPLEAF.Rocket.Transition.plotShape">plotShape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>