<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>MAPLEAF.Motion.RigidBodyStates API documentation</title>
<meta name="description" content="Define standard and time-derivative rigid body states.
These are defined in such a way that, for the purposes of Runge-Kutta motion integration, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/Motion/RigidBodyStates.html">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.Motion.RigidBodyStates</code></h1>
</header>
<section id="section-intro">
<p>Define standard and time-derivative rigid body states.<br>
These are defined in such a way that, for the purposes of Runge-Kutta motion integration, they can be treated like scalars.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39; 
Define standard and time-derivative rigid body states.  
These are defined in such a way that, for the purposes of Runge-Kutta motion integration, they can be treated like scalars.
&#39;&#39;&#39;

from MAPLEAF.Motion import Vector
from MAPLEAF.Motion import Quaternion
from MAPLEAF.Motion import AngularVelocity

__all__ = [ &#34;RigidBodyState_3DoF&#34;, &#34;RigidBodyStateDerivative_3DoF&#34;, &#34;RigidBodyState&#34;, &#34;RigidBodyStateDerivative&#34;, &#34;interpolateRigidBodyStates&#34;, &#34;StateList&#34; ]

class RigidBodyState_3DoF():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame

        Adding rigidBodyStates adds the vectors

        Multiplying an rigidBodyState by a scalar scales the vectors
            0.5 *  = half the vector length
    &#34;&#34;&#34;
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        
        return RigidBodyState_3DoF(newPos, newVel)

    def __mul__(self, scalar):
        &#39;&#39;&#39; Used to negate the rigid body state for subtractions &#39;&#39;&#39;
        scalar = float(scalar)
        newPos = self.position * scalar
        newVel = self.velocity * scalar

        return RigidBodyState_3DoF(newPos, newVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;
        #TODO: Ensure this scales properly with the version in the 6DoF IntegratbleRigidBodyState __abs__ function

        return self.position.length() + self.velocity.length()

    def __str__(self):
        &#39;&#39;&#39; Called by print &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f}&#34;.format(self.position, self.velocity)

    def __neg__(self):
        return self*-1

class RigidBodyStateDerivative_3DoF():
    def __init__(self, velocity, acceleration):
        self.velocity = velocity
        self.acceleration = acceleration

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.velocity + rigidBodyState2.velocity
        newVel = self.acceleration + rigidBodyState2.acceleration
        
        return RigidBodyStateDerivative_3DoF(newPos, newVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39; Used in: initVal + timeStep {*} slope &#39;&#39;&#39;
        timeStep = float(timeStep)
        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep

        # After multiplying by a timestep, we get a regular (integrated) rigid body state back
        return RigidBodyState_3DoF(dPos, dVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar

        return RigidBodyStateDerivative_3DoF(vel, accel)

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar

class RigidBodyState():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame
            Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket&#39;s local frame 
                (Orientation of the rocket in the global frame)
            Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame

        Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)

        Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
            0.5 *  = half the vector length, half the rotation size, directions the same

        No other operations are defined
    &#34;&#34;&#34;
    def __init__(self, position=None, velocity=None, orientation=None, angularVelocity=None):
        self.position = Vector(0,0,0) if (position is None) else position
        self.velocity = Vector(0,0,0) if (velocity is None) else velocity
        self.orientation = Quaternion(1,0,0,0) if (orientation is None) else orientation
        self.angularVelocity = AngularVelocity(0,0,0) if (angularVelocity is None) else angularVelocity
    
    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        newAngVel = self.angularVelocity + rigidBodyState2.angularVelocity
        newOrientation = rigidBodyState2.orientation * self.orientation.normalize()
        
        return RigidBodyState(newPos, newVel, newOrientation.normalize(), newAngVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: initVal + timeStep {*} slope
            Expected to always be multiplied by a scalar
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        newPos = self.position * timeStep
        newVel = self.velocity * timeStep
        newAngVel = self.angularVelocity * timeStep
        newOrientation = self.orientation.scaleRotation(timeStep)

        return RigidBodyState(newPos, newVel, newOrientation, newAngVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        positionMag = self.position.length() + self.velocity.length()
        orientationMag = abs(self.orientation.rotationAngle()) + self.angularVelocity.angVel()

        return orientationMag*100 + positionMag

    def __eq__(self, iRBS2):
        try:
            properties = [ self.position, self.velocity, self.orientation, self.angularVelocity ]
            otherProperties = [ iRBS2.position, iRBS2.velocity, iRBS2.orientation, iRBS2.angularVelocity ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    def __str__(self):
        &#39;&#39;&#39; Called by print function &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f} {:&gt;11.7f} {:&gt;9.4f}&#34;.format(self.position, self.velocity, self.orientation, self.angularVelocity)

    ### Wrapper/Thin functions ###
    def __neg__(self):
        return RigidBodyState(self.position*-1, self.velocity*-1, self.orientation.conjugate(), self.angularVelocity*-1)

class RigidBodyStateDerivative():
    def __init__(self, velocity, acceleration, angularVelocity, angularAccel):
        self.velocity = velocity
        self.acceleration = acceleration
        self.angularVelocity = angularVelocity
        self.angularAccel = angularAccel

    def __add__(self, state2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newVel = self.velocity + state2.velocity
        newAccel = self.acceleration + state2.acceleration
        newAngVel = self.angularVelocity + state2.angularVelocity
        newAngAccel = self.angularAccel + state2.angularAccel
        
        return RigidBodyStateDerivative(newVel, newAccel, newAngVel, newAngAccel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: timeStep {*} slope
            Expected to always be multiplied by a scalar, timestep
            Returns integrated change in rigid body state over given time step
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep
        dOrientation = (self.angularVelocity * timeStep).toQuaternion()
        dOrientation.normalize()
        dAngVel = self.angularAccel * timeStep

        # After integration over a time step, get a regular rigid body state back
        return RigidBodyState(dPos, dVel, dOrientation, dAngVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar
        angVel = self.angularVelocity * invScalar
        angAccel = self.angularAccel * invScalar

        return RigidBodyStateDerivative(vel, accel, angVel, angAccel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        # positionMag = self.position.length() + self.velocity.length()

        orientationMag = self.angularVelocity.angVel() + self.angularAccel.angVel()

        return orientationMag*100

    def __eq__(self, state2):
        try:
            properties = [ self.velocity, self.acceleration, self.angularVelocity, self.angularAccel ]
            otherProperties = [ state2.velocity, state2.acceleration, state2.angularVelocity, state2.angularAccel ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar

class StateList(list):
    &#39;&#39;&#39; 
        Purpose is to provide a generalized version of RigidBodyState, which can be integrated like a scalar, but allows MAPLEAF to integrate arbitrary additional parameters.

        Contains a list of parameters that define the (rocket) state, all of which are to be integrated
        Overrides operators to make +-* operations elementwise
        Capable of representing a StateList and the derivative of a StateList

        Called StateList instead of StateVector because it can contain objects of any type, like a Python list, and unlike a Vector.
                
        ..note: If we want to compile this object w/ Cython in the future, We may want to restrict ourselves to scalars

        Example: RocketState([ initRigidBodyState, tankLevel1, actuatorPosition1 ])
    &#39;&#39;&#39;
    #### Initialization and setting/getting attributes ####
    def __init__(self, stateVariables, variableNames=None, _nameToIndexMap=None):
        &#39;&#39;&#39;
            stateVariables: (`list`) of state variable values (RigidBodyState assumed to be in position 0)
            variableNames:  (`list[str]`) of state variable names. If passed in, can access values as attributes: stateList.varName
           _ nameToIndexMap:(`dict[str:int]`) maps variable names to indices in the itemList. If not provided, but a nameList is, will be generated from the nameList

            Pass in a nameList to be able to access variables by name - order must match that of the itemList.
                For unnamed variables, put None in the namelist

            Only pass in one of nameList or _nameToIndexMap. When both are passed in, _nameToIndexMap takes precedence.
                _nameToIndexMap intended for internal use only, no correctness checks performed on it
        &#39;&#39;&#39;
        super().__init__(stateVariables) # Pass itemList to parent (list) constructor

        if _nameToIndexMap != None:
            # Does not check whether each variable is in the nameToIndexMap - could omit some if desired
            self.nameToIndexMap = _nameToIndexMap

        elif variableNames != None:
            # Generate nameToIndexMap from variableNames list
            if len(variableNames) == len(stateVariables):
                forbiddenVarNames = [ &#34;position&#34;, &#34;velocity&#34;, &#34;orientation&#34;, &#34;angularVelocity&#34; ]
                for forbiddenName in forbiddenVarNames:
                    if forbiddenName in variableNames:
                        raise ValueError(&#34;ERROR: The following variable names are reserved for rigid body states: {}&#34;.format(forbiddenVarNames))

                self.nameToIndexMap = { variableNames[i]:i for i in range(len(variableNames)) }
                if len(variableNames) != len(self.nameToIndexMap.keys()):
                    raise ValueError(&#34;ERROR: Duplicate state variable name in: {}&#34;.format(variableNames))
            else:
                raise ValueError(&#34;ERROR: Number of state variables must match number of variable names provided&#34;)
        
        else:
            self.nameToIndexMap = dict()

    def __getattr__(self, name):
        try:
            # Check if the attribute name is in the nameToIndexMap - return item from that index
            return self[self.nameToIndexMap[name]]
        except KeyError:
            # Try getting the attribute from the rigidBodyState (assumed first element)
            return getattr(self[0], name)

    def __setattr__(self, name, value):
        if name in self.__dict__ or name == &#34;nameToIndexMap&#34;:
            self.__dict__[name] = value
        elif name in self.nameToIndexMap:
            # Check if the attribute name is in the nameToIndexMap - set item at that index
            indexToSet = self.nameToIndexMap[name]
            self[indexToSet] = value
        elif name in self[0].__dict__:
            # Try getting the attribute from the rigidBodyState (assumed first element)
            setattr(self[0], name, value)

    def addStateVariable(self, name, currentValue):
        self.append(currentValue)
        self.nameToIndexMap[name] = len(self)-1

    #### Arithmetic ####
    def __add__(self, state2):
        return StateList([ x + y for x, y in zip(self, state2) ], _nameToIndexMap=self.nameToIndexMap)

    def __sub__(self, state2):
        return StateList([ x - y for x, y in zip(self, state2) ], _nameToIndexMap=self.nameToIndexMap)

    def __mul__(self, scalar):
        return StateList([ x*scalar for x in self ], _nameToIndexMap=self.nameToIndexMap)

    def __truediv__(self, scalar):
        return StateList([ x/scalar for x in self ], _nameToIndexMap=self.nameToIndexMap)

    def __rmul__(self, scalar):
        return self * scalar # Call regular __mul__ function

    def __abs__(self):
        return sum([ abs(x) for x in self ])

    def __eq__(self, state2):
        try:
            return all([ x == y for x,y in zip(self, state2) ])
        except TypeError:
            return False

    def __neg__(self):
        return StateList([ -x for x in self ], _nameToIndexMap=self.nameToIndexMap)

    #### String functions ####
    # TODO: Convert to new logging framework
    def getLogHeader(self):
        header = &#34;&#34;
        for i in range(len(self)):
            try:
                # If the variable defines a getLogHeader function, use it
                header += self[i].getLogHeader()
            
            except AttributeError:
                # Item doesn&#39;t have a getLogHeader function (ex. it&#39;s a float)
                # Try to find it in nameToIndexMap
                varName = None
                for key, val in self.nameToIndexMap.items():
                    if val == i:
                        varName = &#34; &#34; + key
                
                # Otherwise just call it stateVariableN
                if varName == None:
                    varName = &#34; StateVariable{}&#34;.format(i)

                header += varName
        
        return header

    def __str__(self):
        varStrings = [ x.__str__() for x in self ]
        return &#34; &#34;.join(varStrings)

def interpolateRigidBodyStates(state1, state2, state1Weight):
    &#39;&#39;&#39;
        Linearly interpolates between state 1 and state2.
        state1Weight should be a decimal value between 0 and 1.
    &#39;&#39;&#39;
    state2Weight = 1 - state1Weight
    
    # Properties of all rigid body states
    pos = state1.position*state1Weight + state2.position*state2Weight
    vel = state1.velocity*state1Weight + state2.velocity*state2Weight

    try:
        # 6DoF Properties
        orientationDelta = state1.orientation.slerp(state2.orientation, state1Weight) # Use spherical linear interpolation for quaternions
        orientation = state1.orientation * orientationDelta
        angVel = state1.angularVelocity*state1Weight + state2.angularVelocity*state2Weight
        return RigidBodyState(pos, vel, orientation, angVel)

    except AttributeError:
        # 3DoF doesn&#39;t include orientation / angVel
        return RigidBodyState_3DoF(pos, vel)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.interpolateRigidBodyStates"><code class="name flex">
<span>def <span class="ident">interpolateRigidBodyStates</span></span>(<span>state1, state2, state1Weight)</span>
</code></dt>
<dd>
<div class="desc"><p>Linearly interpolates between state 1 and state2.
state1Weight should be a decimal value between 0 and 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolateRigidBodyStates(state1, state2, state1Weight):
    &#39;&#39;&#39;
        Linearly interpolates between state 1 and state2.
        state1Weight should be a decimal value between 0 and 1.
    &#39;&#39;&#39;
    state2Weight = 1 - state1Weight
    
    # Properties of all rigid body states
    pos = state1.position*state1Weight + state2.position*state2Weight
    vel = state1.velocity*state1Weight + state2.velocity*state2Weight

    try:
        # 6DoF Properties
        orientationDelta = state1.orientation.slerp(state2.orientation, state1Weight) # Use spherical linear interpolation for quaternions
        orientation = state1.orientation * orientationDelta
        angVel = state1.angularVelocity*state1Weight + state2.angularVelocity*state2Weight
        return RigidBodyState(pos, vel, orientation, angVel)

    except AttributeError:
        # 3DoF doesn&#39;t include orientation / angVel
        return RigidBodyState_3DoF(pos, vel)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState"><code class="flex name class">
<span>class <span class="ident">RigidBodyState</span></span>
<span>(</span><span>position=None, velocity=None, orientation=None, angularVelocity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
Pos/Vel are expected to be Vectors - Defined with reference to the global frame
Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket's local frame
(Orientation of the rocket in the global frame)
Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame</p>
<p>Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)</p>
<p>Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
0.5 *
= half the vector length, half the rotation size, directions the same</p>
<p>No other operations are defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyState():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame
            Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket&#39;s local frame 
                (Orientation of the rocket in the global frame)
            Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame

        Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)

        Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
            0.5 *  = half the vector length, half the rotation size, directions the same

        No other operations are defined
    &#34;&#34;&#34;
    def __init__(self, position=None, velocity=None, orientation=None, angularVelocity=None):
        self.position = Vector(0,0,0) if (position is None) else position
        self.velocity = Vector(0,0,0) if (velocity is None) else velocity
        self.orientation = Quaternion(1,0,0,0) if (orientation is None) else orientation
        self.angularVelocity = AngularVelocity(0,0,0) if (angularVelocity is None) else angularVelocity
    
    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        newAngVel = self.angularVelocity + rigidBodyState2.angularVelocity
        newOrientation = rigidBodyState2.orientation * self.orientation.normalize()
        
        return RigidBodyState(newPos, newVel, newOrientation.normalize(), newAngVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: initVal + timeStep {*} slope
            Expected to always be multiplied by a scalar
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        newPos = self.position * timeStep
        newVel = self.velocity * timeStep
        newAngVel = self.angularVelocity * timeStep
        newOrientation = self.orientation.scaleRotation(timeStep)

        return RigidBodyState(newPos, newVel, newOrientation, newAngVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        positionMag = self.position.length() + self.velocity.length()
        orientationMag = abs(self.orientation.rotationAngle()) + self.angularVelocity.angVel()

        return orientationMag*100 + positionMag

    def __eq__(self, iRBS2):
        try:
            properties = [ self.position, self.velocity, self.orientation, self.angularVelocity ]
            otherProperties = [ iRBS2.position, iRBS2.velocity, iRBS2.orientation, iRBS2.angularVelocity ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    def __str__(self):
        &#39;&#39;&#39; Called by print function &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f} {:&gt;11.7f} {:&gt;9.4f}&#34;.format(self.position, self.velocity, self.orientation, self.angularVelocity)

    ### Wrapper/Thin functions ###
    def __neg__(self):
        return RigidBodyState(self.position*-1, self.velocity*-1, self.orientation.conjugate(), self.angularVelocity*-1)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative"><code class="flex name class">
<span>class <span class="ident">RigidBodyStateDerivative</span></span>
<span>(</span><span>velocity, acceleration, angularVelocity, angularAccel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyStateDerivative():
    def __init__(self, velocity, acceleration, angularVelocity, angularAccel):
        self.velocity = velocity
        self.acceleration = acceleration
        self.angularVelocity = angularVelocity
        self.angularAccel = angularAccel

    def __add__(self, state2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newVel = self.velocity + state2.velocity
        newAccel = self.acceleration + state2.acceleration
        newAngVel = self.angularVelocity + state2.angularVelocity
        newAngAccel = self.angularAccel + state2.angularAccel
        
        return RigidBodyStateDerivative(newVel, newAccel, newAngVel, newAngAccel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: timeStep {*} slope
            Expected to always be multiplied by a scalar, timestep
            Returns integrated change in rigid body state over given time step
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep
        dOrientation = (self.angularVelocity * timeStep).toQuaternion()
        dOrientation.normalize()
        dAngVel = self.angularAccel * timeStep

        # After integration over a time step, get a regular rigid body state back
        return RigidBodyState(dPos, dVel, dOrientation, dAngVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar
        angVel = self.angularVelocity * invScalar
        angAccel = self.angularAccel * invScalar

        return RigidBodyStateDerivative(vel, accel, angVel, angAccel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        # positionMag = self.position.length() + self.velocity.length()

        orientationMag = self.angularVelocity.angVel() + self.angularAccel.angVel()

        return orientationMag*100

    def __eq__(self, state2):
        try:
            properties = [ self.velocity, self.acceleration, self.angularVelocity, self.angularAccel ]
            otherProperties = [ state2.velocity, state2.acceleration, state2.angularVelocity, state2.angularAccel ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF"><code class="flex name class">
<span>class <span class="ident">RigidBodyStateDerivative_3DoF</span></span>
<span>(</span><span>velocity, acceleration)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyStateDerivative_3DoF():
    def __init__(self, velocity, acceleration):
        self.velocity = velocity
        self.acceleration = acceleration

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.velocity + rigidBodyState2.velocity
        newVel = self.acceleration + rigidBodyState2.acceleration
        
        return RigidBodyStateDerivative_3DoF(newPos, newVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39; Used in: initVal + timeStep {*} slope &#39;&#39;&#39;
        timeStep = float(timeStep)
        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep

        # After multiplying by a timestep, we get a regular (integrated) rigid body state back
        return RigidBodyState_3DoF(dPos, dVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar

        return RigidBodyStateDerivative_3DoF(vel, accel)

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF"><code class="flex name class">
<span>class <span class="ident">RigidBodyState_3DoF</span></span>
<span>(</span><span>position, velocity)</span>
</code></dt>
<dd>
<div class="desc"><p>Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
Pos/Vel are expected to be Vectors - Defined with reference to the global frame</p>
<p>Adding rigidBodyStates adds the vectors</p>
<p>Multiplying an rigidBodyState by a scalar scales the vectors
0.5 *
= half the vector length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyState_3DoF():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame

        Adding rigidBodyStates adds the vectors

        Multiplying an rigidBodyState by a scalar scales the vectors
            0.5 *  = half the vector length
    &#34;&#34;&#34;
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        
        return RigidBodyState_3DoF(newPos, newVel)

    def __mul__(self, scalar):
        &#39;&#39;&#39; Used to negate the rigid body state for subtractions &#39;&#39;&#39;
        scalar = float(scalar)
        newPos = self.position * scalar
        newVel = self.velocity * scalar

        return RigidBodyState_3DoF(newPos, newVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;
        #TODO: Ensure this scales properly with the version in the 6DoF IntegratbleRigidBodyState __abs__ function

        return self.position.length() + self.velocity.length()

    def __str__(self):
        &#39;&#39;&#39; Called by print &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f}&#34;.format(self.position, self.velocity)

    def __neg__(self):
        return self*-1</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.StateList"><code class="flex name class">
<span>class <span class="ident">StateList</span></span>
<span>(</span><span>stateVariables, variableNames=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Purpose is to provide a generalized version of RigidBodyState, which can be integrated like a scalar, but allows MAPLEAF to integrate arbitrary additional parameters.</p>
<p>Contains a list of parameters that define the (rocket) state, all of which are to be integrated
Overrides operators to make +-* operations elementwise
Capable of representing a StateList and the derivative of a StateList</p>
<p>Called StateList instead of StateVector because it can contain objects of any type, like a Python list, and unlike a Vector.</p>
<p>..note: If we want to compile this object w/ Cython in the future, We may want to restrict ourselves to scalars</p>
<p>Example: RocketState([ initRigidBodyState, tankLevel1, actuatorPosition1 ])</p>
<p>stateVariables: (<code>list</code>) of state variable values (RigidBodyState assumed to be in position 0)
variableNames:
(<code>list[str]</code>) of state variable names. If passed in, can access values as attributes: stateList.varName
_ nameToIndexMap:(<code>dict[str:int]</code>) maps variable names to indices in the itemList. If not provided, but a nameList is, will be generated from the nameList</p>
<p>Pass in a nameList to be able to access variables by name - order must match that of the itemList.
For unnamed variables, put None in the namelist</p>
<p>Only pass in one of nameList or _nameToIndexMap. When both are passed in, _nameToIndexMap takes precedence.
_nameToIndexMap intended for internal use only, no correctness checks performed on it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StateList(list):
    &#39;&#39;&#39; 
        Purpose is to provide a generalized version of RigidBodyState, which can be integrated like a scalar, but allows MAPLEAF to integrate arbitrary additional parameters.

        Contains a list of parameters that define the (rocket) state, all of which are to be integrated
        Overrides operators to make +-* operations elementwise
        Capable of representing a StateList and the derivative of a StateList

        Called StateList instead of StateVector because it can contain objects of any type, like a Python list, and unlike a Vector.
                
        ..note: If we want to compile this object w/ Cython in the future, We may want to restrict ourselves to scalars

        Example: RocketState([ initRigidBodyState, tankLevel1, actuatorPosition1 ])
    &#39;&#39;&#39;
    #### Initialization and setting/getting attributes ####
    def __init__(self, stateVariables, variableNames=None, _nameToIndexMap=None):
        &#39;&#39;&#39;
            stateVariables: (`list`) of state variable values (RigidBodyState assumed to be in position 0)
            variableNames:  (`list[str]`) of state variable names. If passed in, can access values as attributes: stateList.varName
           _ nameToIndexMap:(`dict[str:int]`) maps variable names to indices in the itemList. If not provided, but a nameList is, will be generated from the nameList

            Pass in a nameList to be able to access variables by name - order must match that of the itemList.
                For unnamed variables, put None in the namelist

            Only pass in one of nameList or _nameToIndexMap. When both are passed in, _nameToIndexMap takes precedence.
                _nameToIndexMap intended for internal use only, no correctness checks performed on it
        &#39;&#39;&#39;
        super().__init__(stateVariables) # Pass itemList to parent (list) constructor

        if _nameToIndexMap != None:
            # Does not check whether each variable is in the nameToIndexMap - could omit some if desired
            self.nameToIndexMap = _nameToIndexMap

        elif variableNames != None:
            # Generate nameToIndexMap from variableNames list
            if len(variableNames) == len(stateVariables):
                forbiddenVarNames = [ &#34;position&#34;, &#34;velocity&#34;, &#34;orientation&#34;, &#34;angularVelocity&#34; ]
                for forbiddenName in forbiddenVarNames:
                    if forbiddenName in variableNames:
                        raise ValueError(&#34;ERROR: The following variable names are reserved for rigid body states: {}&#34;.format(forbiddenVarNames))

                self.nameToIndexMap = { variableNames[i]:i for i in range(len(variableNames)) }
                if len(variableNames) != len(self.nameToIndexMap.keys()):
                    raise ValueError(&#34;ERROR: Duplicate state variable name in: {}&#34;.format(variableNames))
            else:
                raise ValueError(&#34;ERROR: Number of state variables must match number of variable names provided&#34;)
        
        else:
            self.nameToIndexMap = dict()

    def __getattr__(self, name):
        try:
            # Check if the attribute name is in the nameToIndexMap - return item from that index
            return self[self.nameToIndexMap[name]]
        except KeyError:
            # Try getting the attribute from the rigidBodyState (assumed first element)
            return getattr(self[0], name)

    def __setattr__(self, name, value):
        if name in self.__dict__ or name == &#34;nameToIndexMap&#34;:
            self.__dict__[name] = value
        elif name in self.nameToIndexMap:
            # Check if the attribute name is in the nameToIndexMap - set item at that index
            indexToSet = self.nameToIndexMap[name]
            self[indexToSet] = value
        elif name in self[0].__dict__:
            # Try getting the attribute from the rigidBodyState (assumed first element)
            setattr(self[0], name, value)

    def addStateVariable(self, name, currentValue):
        self.append(currentValue)
        self.nameToIndexMap[name] = len(self)-1

    #### Arithmetic ####
    def __add__(self, state2):
        return StateList([ x + y for x, y in zip(self, state2) ], _nameToIndexMap=self.nameToIndexMap)

    def __sub__(self, state2):
        return StateList([ x - y for x, y in zip(self, state2) ], _nameToIndexMap=self.nameToIndexMap)

    def __mul__(self, scalar):
        return StateList([ x*scalar for x in self ], _nameToIndexMap=self.nameToIndexMap)

    def __truediv__(self, scalar):
        return StateList([ x/scalar for x in self ], _nameToIndexMap=self.nameToIndexMap)

    def __rmul__(self, scalar):
        return self * scalar # Call regular __mul__ function

    def __abs__(self):
        return sum([ abs(x) for x in self ])

    def __eq__(self, state2):
        try:
            return all([ x == y for x,y in zip(self, state2) ])
        except TypeError:
            return False

    def __neg__(self):
        return StateList([ -x for x in self ], _nameToIndexMap=self.nameToIndexMap)

    #### String functions ####
    # TODO: Convert to new logging framework
    def getLogHeader(self):
        header = &#34;&#34;
        for i in range(len(self)):
            try:
                # If the variable defines a getLogHeader function, use it
                header += self[i].getLogHeader()
            
            except AttributeError:
                # Item doesn&#39;t have a getLogHeader function (ex. it&#39;s a float)
                # Try to find it in nameToIndexMap
                varName = None
                for key, val in self.nameToIndexMap.items():
                    if val == i:
                        varName = &#34; &#34; + key
                
                # Otherwise just call it stateVariableN
                if varName == None:
                    varName = &#34; StateVariable{}&#34;.format(i)

                header += varName
        
        return header

    def __str__(self):
        varStrings = [ x.__str__() for x in self ]
        return &#34; &#34;.join(varStrings)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.list</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.StateList.addStateVariable"><code class="name flex">
<span>def <span class="ident">addStateVariable</span></span>(<span>self, name, currentValue)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addStateVariable(self, name, currentValue):
    self.append(currentValue)
    self.nameToIndexMap[name] = len(self)-1</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.StateList.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    header = &#34;&#34;
    for i in range(len(self)):
        try:
            # If the variable defines a getLogHeader function, use it
            header += self[i].getLogHeader()
        
        except AttributeError:
            # Item doesn&#39;t have a getLogHeader function (ex. it&#39;s a float)
            # Try to find it in nameToIndexMap
            varName = None
            for key, val in self.nameToIndexMap.items():
                if val == i:
                    varName = &#34; &#34; + key
            
            # Otherwise just call it stateVariableN
            if varName == None:
                varName = &#34; StateVariable{}&#34;.format(i)

            header += varName
    
    return header</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.Motion" href="index.html">MAPLEAF.Motion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MAPLEAF.Motion.RigidBodyStates.interpolateRigidBodyStates" href="#MAPLEAF.Motion.RigidBodyStates.interpolateRigidBodyStates">interpolateRigidBodyStates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState">RigidBodyState</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative">RigidBodyStateDerivative</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF">RigidBodyStateDerivative_3DoF</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF">RigidBodyState_3DoF</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.StateList" href="#MAPLEAF.Motion.RigidBodyStates.StateList">StateList</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Motion.RigidBodyStates.StateList.addStateVariable" href="#MAPLEAF.Motion.RigidBodyStates.StateList.addStateVariable">addStateVariable</a></code></li>
<li><code><a title="MAPLEAF.Motion.RigidBodyStates.StateList.getLogHeader" href="#MAPLEAF.Motion.RigidBodyStates.StateList.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>