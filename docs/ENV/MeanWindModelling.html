<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>MAPLEAF.ENV.MeanWindModelling API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.ENV.MeanWindModelling</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import random
from math import cos, radians, sin

import numpy as np
import pandas as pd
from scipy.stats import rv_histogram

from MAPLEAF.Interpolation import linInterp
from MAPLEAF.IO.SimDefinition import defaultConfigValues
from MAPLEAF.IO.SubDictReader import SubDictReader
from MAPLEAF.Motion.CythonVector import Vector

__pdoc__ = {
    &#39;_meanWindModel_Constant&#39;:            True,
    &#39;_meanWindModel_Hellman&#39;:             True,
    &#39;_meanWindModel_InterpolatedProfile&#39;: True,
    &#39;_windRoseDataSampler&#39;:               True,
    &#39;_radioSondeDataSampler&#39;:             True,
}

# Mean Wind Model Abstract Base Class / Interface Definition
class MeanWindModel(abc.ABC):
    &#39;&#39;&#39; Defines the interface for Mean Wind Models instantiated by meanWindModelFactory.    &#39;&#39;&#39;

    @abc.abstractmethod
    def getMeanWind(self, AGLAltitude):
        pass

# Mean Wind Model Factory
def meanWindModelFactory(simDefinition=None, silent=False):
    &#39;&#39;&#39;
        Arguments: 
            simDefinition: A SimDefinition containing the simulation definition file for the present simulation

        Returns:
            meanWindModel, created based on the parameters provided in the SimDefinition passed in 
    &#39;&#39;&#39;
    if simDefinition == None:
        constWind = Vector(defaultConfigValues[&#34;Environment.ConstantMeanWind.velocity&#34;])
        return _meanWindModel_Constant(constWind)

    envReader = SubDictReader(&#39;Environment&#39;, simDefinition)
    meanWindModel = None
    meanWindModelType = envReader.getString(&#34;MeanWindModel&#34;)

    if meanWindModelType == &#34;Constant&#34;:
        meanGroundWind = envReader.getVector(&#34;ConstantMeanWind.velocity&#34;)
        if not silent:
            print(&#34;Constant ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))

        meanWindModel = _meanWindModel_Constant(meanGroundWind)

    elif meanWindModelType in [ &#34;SampledGroundWindData&#34;, &#34;Hellman&#34; ]:
        def getLocationSampledGroundWindVel():
            #### Get list of, and weights of, locations to sample wind rose from
            GroundWindLocationsSampled = envReader.getString(&#34;SampledGroundWindData.locationsToSample&#34;).split()
            locationsSampled = []
            locationWeights = []
            # Parse into locations (1st, 3rd, 5th... values) and weights (2nd, 4th, 6th... values)
            for i in range(0, len(GroundWindLocationsSampled), 2):
                locationsSampled.append(GroundWindLocationsSampled[i])
                locationWeights.append(float(GroundWindLocationsSampled[i+1]))
            launchMonth = envReader.getString(&#34;SampledGroundWindData.launchMonth&#34;)

            # Sample wind rose(s)
            sampler = _windRoseDataSampler(silent=silent)
            meanGroundWind = sampler.sampleWindRoses(locationsSampled, locationWeights, launchMonth)

            # Output choices parsed from input file and resulting wind
            if not silent:
                if simDefinition.monteCarloLogger != None:
                    simDefinition.monteCarloLogger.log(&#34;Sampling ground winds from: {}&#34;.format(locationsSampled))
                    simDefinition.monteCarloLogger.log(&#34;Sampling weights for each location: {}&#34;.format(locationWeights))
                    simDefinition.monteCarloLogger.log(&#34;Sampling wind distribution from month of: {}&#34;.format(launchMonth))
                    simDefinition.monteCarloLogger.log(&#34;Sampled mean ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))
                else:
                    print(&#34;Sampling ground winds from: {}&#34;.format(locationsSampled))
                    print(&#34;Sampling weights for each location: {}&#34;.format(locationWeights))
                    print(&#34;Sampling wind distribution from month of: {}&#34;.format(launchMonth))
                    print(&#34;Sampled mean ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))

            return meanGroundWind

        ### Create and return appropriate wind vs altitude model ###
        if meanWindModelType == &#34;SampledGroundWindData&#34;:
            meanGroundWind = getLocationSampledGroundWindVel()
            if not silent:
                print(&#34;Wind is not a function of altitude&#34;)
            meanWindModel = _meanWindModel_Constant(meanGroundWind)

        elif meanWindModelType == &#34;Hellman&#34;:
            groundWindModel = envReader.getString(&#34;Hellman.groundWindModel&#34;)

            # Get ground wind
            if groundWindModel == &#34;Constant&#34;:
                meanGroundWind = envReader.getVector(&#34;ConstantMeanWind.velocity&#34;)
            elif groundWindModel == &#34;SampledGroundWindData&#34;:
                meanGroundWind = getLocationSampledGroundWindVel()

            HellmanAlphaCoeff = envReader.getFloat(&#34;Hellman.alphaCoeff&#34;)
            HellmanAltitudeLimit = envReader.getFloat(&#34;Hellman.altitudeLimit&#34;)

            if not silent:
                print(&#34;Constant ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))
                print(&#34;Wind vs. altitude governed by Hellman law: v2 = v1*(z2/10)^a where a = {}&#34;.format(HellmanAlphaCoeff))
                print(&#34;Hellman law is taken to apply up to an altitude of {} m AGL&#34;.format(HellmanAltitudeLimit))

            meanWindModel = _meanWindModel_Hellman(meanGroundWind, HellmanAltitudeLimit, HellmanAlphaCoeff)
    
    elif meanWindModelType == &#34;CustomWindProfile&#34;:
        meanWindProfileFilePath = envReader.getString(&#34;CustomWindProfile.filePath&#34;)
        meanWindModel = _meanWindModel_InterpolatedProfile(windFilePath=meanWindProfileFilePath)

    elif meanWindModelType == &#34;SampledRadioSondeData&#34;:
        # Get locations and location weights
        locationsAndWeights = envReader.getString(&#34;SampledRadioSondeData.locationsToSample&#34;).split()
        locations = []
        weights = []
        for i in range(0, len(locationsAndWeights), 2):
            locations.append(locationsAndWeights[i])
            weights.append(float(locationsAndWeights[i+1]))
            
        locationASLAltitudes = [ float(x) for x in envReader.getString(&#34;SampledRadioSondeData.locationASLAltitudes&#34;).split() ]

        # Get launch month
        launchMonth = envReader.getString(&#34;SampledRadioSondeData.launchMonth&#34;)

        # Get random seed (if provided)
        radioSondeRandomSeed = envReader.tryGetString(&#34;SampledRadioSondeData.randomSeed&#34;)

        # Select and parse radio sonde profile
        sampler = _radioSondeDataSampler(silent=silent)
        altitudes, windVectors = sampler.getRadioSondeWindProfile(locations, weights, locationASLAltitudes, launchMonth, radioSondeRandomSeed)
        
        meanWindModel = _meanWindModel_InterpolatedProfile(windAltitudes=altitudes, winds=windVectors)

    else:
        raise ValueError(&#34;Unknown MeanWindModel: {}. Please see SimDefinitionTemplate.txt for available options.&#34;.format(meanWindModelType))

    return meanWindModel

# Actual Mean Wind Model classes - these are instantiated by meanWindModelFactory
class _meanWindModel_Constant(MeanWindModel):
    &#39;&#39;&#39; Defines a constant wind speed at all altitudes  &#39;&#39;&#39;
    
    def __init__(self, wind):
        self.wind = wind

    def getMeanWind(self, AGLAltitude):
        return self.wind

class _meanWindModel_Hellman(MeanWindModel):
    &#39;&#39;&#39;
        Uses the Hellman law to scale a ground velocity using a power law as the atmospheric boundary layer is exited.
        Low-altitude only. https://en.wikipedia.org/wiki/Wind_gradient -&gt; Engineering Section.

    &#39;&#39;&#39;
    def __init__(self, groundMeanWind=Vector(0,0,0), altitudeLimit=1500, hellmanAlphaCoeff=0.14):
        &#39;&#39;&#39;
            Arguments:
                groundMeanWind: Wind Vector at ground level (~10m above surface), in m/s
                altitudeLimit: Altitude above which the power law transitions into a constant profile (m, AGL)
                hellmanAlphaCoeff: Alpha in the Hellman model (1/7 is a common first guess, but can vary widely depending on terrain)
        &#39;&#39;&#39;
        self.groundMeanWind = groundMeanWind
        self.altitudeLimit = altitudeLimit
        self.hellmanAlphaCoeff = hellmanAlphaCoeff

    def getMeanWind(self, AGLAltitude):
        # Limit velocity scaling to up to the specified altitude limit
        HellmanAltitude = max(min(self.altitudeLimit, AGLAltitude), 10)
        # Assume initial winds come from a height of 10m
        return self.groundMeanWind * (HellmanAltitude/10)**self.hellmanAlphaCoeff

class _meanWindModel_InterpolatedProfile(MeanWindModel):
    def __init__(self, windAltitudes=[], winds=[], windFilePath=None):
        &#39;&#39;&#39;
            Arguments:
                windAltitudes: list of altitudes at which wind vectors will be provided (m AGL)
                winds: list of wind vectors, matching the ordering of windAltitudes (m/s)

                windFilePath: string path to a text file containing a table, formatted similarly to the following:
                    AGlAltitude(m) WindX(m/s) WindY(m/s) WindZ(m/s)
                    a1              wx1         wy1     wz1
                    a2              wx2         wy2     wz2

            Notes:
                Provide either windAltitudes AND winds, OR windFilePath. If all are provided, windAltitudes/winds will be used
        &#39;&#39;&#39;
        if len(windAltitudes) + len(winds) &gt; 0:
            self.windAltitudes = windAltitudes
            self.winds = winds

        elif windFilePath != None:
            self._readCustomWindProfile(windFilePath)

        else:
            raise ValueError(&#34;Incomplete initialization info provided. Provide either windAltitudes AND winds, OR windFilePath&#34;)

    def _readCustomWindProfile(self, filePath):
        windProfile = np.loadtxt(filePath, skiprows=1)
        self.windAltitudes = windProfile[:, 0]
        self.winds = windProfile[:, 1:]

    def getMeanWind(self, AGLAltitude):
        return Vector(*linInterp(self.windAltitudes, self.winds, AGLAltitude))

# Wind Data readers/samplers
class _windRoseDataSampler():
    &#39;&#39;&#39; 
        Parses wind rose data files from Iowa State University&#39;s Environmental Mesonet.
    &#39;&#39;&#39;

    def __init__(self, silent=False):
        self.silent = silent

        # TODO: Generalize extreme winds outside Medecine Hat
        self.extremeWinds = [ 25, 31, 50 ] # mph = [ 40, 50, 80 ] km/h
        self.extremeWinds = [ x * 0.44704 for x in self.extremeWinds ] # convert to m/s
        self.extremeWindProbabilities = [ 0.01, 0.004, 0 ] # Decimal, chance of being at or higher than given wind speed, based on hourly peak gust data for Medecine Hat, AB

    def sampleWindRoses(self, locationsSampled, locationWeights, launchMonth):
        # Choose a wind rose based on the location weights
        averagedWindRose = self._getAveragedWindRose( Months=[launchMonth], locations=locationsSampled, locationWeights=locationWeights )
        speedrvHist = self._createWindSpeedCDF(averagedWindRose)
        
        # Choose a wind speed
        windSpeed = speedrvHist.ppf(random.random())
        
        # Construct heading probabilities based on that wind speed, then choose a wind heading
        heading_rvHist = self._createHeadingCDF(averagedWindRose, windSpeed=windSpeed)
        windHeading = heading_rvHist.ppf(random.random())
        windDirectionVector = _convertWindHeadingToXYPlaneWindDirection(windHeading)
        meanGroundWind = windDirectionVector * windSpeed

        return meanGroundWind

    def _readWindRose(self, filePath):
        &#39;&#39;&#39;
            Currently not general, will only work with Wind Rose data from Iowa State University - Iowa Environmental Mesonet
            http://mesonet.agron.iastate.edu/sites/windrose.phtml?network=WI_ASOS&amp;station=CWA
        &#39;&#39;&#39;
        # Read data (Header = Direction,     Calm, 2.0  4.9, 5.0  6.9, 7.0  9.9,10.0 14.9,15.0 19.9,    20.0+)
        windRose = pd.read_csv(filePath, delimiter=&#34;,&#34;, comment=&#34;#&#34;)
        # Split direction column into min and max directions: ex. &#34;000-010&#34;
        directionMinMax = windRose[&#34;Direction&#34;].str.split(&#34;-&#34;, n=1, expand=True)
        windRose.drop(columns=[&#34;Direction&#34;], inplace=True)
        # Convert each of the split string data to floats
        directionMinMax = directionMinMax.astype(float)
        # Add new direction columns
        windRose[&#34;direction&#34;] = (directionMinMax[0] + directionMinMax[1]) / 2
        # Set first direction to 0 degrees instead of 5 (assumed incorrect in windrose file)
        windRose.iloc[0,-1] = 0

        nameMap = {
            &#34;     Calm&#34;: 1.0,
            &#34; 2.0  4.9&#34;: 3.5,
            &#34; 5.0  6.9&#34;: 6.0,
            &#34; 7.0  9.9&#34;: 8.5,
            &#34;10.0 14.9&#34;: 12.5,
            &#34;15.0 19.9&#34;: 17.5,
            &#34;    20.0+&#34;: 23.5
        }
        windRose.rename(mapper=nameMap, inplace=True, axis=&#39;columns&#39;)

        # Replace empty values in the first column with zeros
        windRose.replace(r&#39;^\s*$&#39;, 0.0, regex=True, inplace=True)
        windRose[1.0] = windRose[1.0].astype(float)

        return windRose

    def _getAveragedWindRose(self, Months=[&#34;May&#34;], MonthWeights=[1.0], locations=[&#34;MedecineHat&#34;], locationWeights=[1.0]):
        windRose = self._readWindRose(&#34;test/WindData/WindroseAprMedecineHat.txt&#34;)*0.0 # Initialize as zero
        for i in range(len(Months)):
            for a in range(len(locations)):
                windRoseFilePath = &#34;test/WindData/Windrose{}{}.txt&#34;.format(Months[i], locations[a])
                windRose += self._readWindRose(windRoseFilePath) * MonthWeights[i] * locationWeights[a]

        return windRose.copy()

    def _createWindSpeedCDF(self, windRose):
        &#39;&#39;&#39;Calculates wind speed CDF from a windrose (wind rose can be generated using self.readWindRose())&#39;&#39;&#39;
        # Sum over headings to get probabilities for each speed
        likelyhoodBySpeed = windRose.sum()
        likelyhoodBySpeed.drop(index=[&#34;direction&#34;], inplace=True)

        # Normalize to 0-1 probability range
        totalProb = likelyhoodBySpeed.sum()
        likelyhoodBySpeed = list(likelyhoodBySpeed / totalProb)

        # Bin boundaries
        cdfX = [ x * 0.44704 for x in [ 0, 2, 5, 7, 10, 15, 20, 23.5 ] ] # Convert to m/s from mph
        likelyhoodBySpeed[-1] -= sum(self.extremeWindProbabilities)
        cdfX += self.extremeWinds
        likelyhoodBySpeed += self.extremeWindProbabilities

        return rv_histogram((likelyhoodBySpeed, cdfX))

    def _createHeadingCDF(self, windRose, windSpeed=None):
        &#39;&#39;&#39;
            Calculates wind heading CDF from a windrose (wind rose can be generated using self.readWindRose())
            Pass in wind speed in m/s
        &#39;&#39;&#39;
        windRose = windRose.set_index(&#34;direction&#34;)
        windRose.loc[360] = windRose.loc[0]
        windRose.drop(index=[0], inplace=True)
        headings = list(windRose.index)
        headings.insert(0,0)
        
        if windSpeed == None:
            # Sum over all speeds to get overall probabilities for each heading
            likelyhoodByHeading = list(windRose.sum(axis=1))
        else:
            # Eliminate the empty first column, replace it with data from the 3.5 mph column
            windRose.iloc[:,0] = windRose.iloc[:,1]
            windRose.rename(columns={1.0:0.0}, inplace=True)

            # Convert from mph to m/s string
            windRose = windRose.rename(columns=lambda c: str(c * 0.44704))
            
            try:
                # If windSpeed exists already, use it
                likelyhoodByHeading = list(windRose[str(windSpeed)])
            except KeyError:
                #### Linearly interpolate to find wind speed probabilities at the given heading ####
                # Create new empty column at desired wind speed
                windRose[str(windSpeed)] = np.nan
                # Convert back to float names
                windRose = windRose.rename(columns=lambda c: float(c))
                # Sort the new column into position
                windRose = windRose.reindex(sorted(windRose.columns), axis=1)
                # Interpolate
                windRose = windRose.interpolate(method=&#34;index&#34;, axis=1, interpolate=True)            
                # Grab the new column as a list
                likelyhoodByHeading = list(windRose[windSpeed])

        #TODO: Need to de-rotate these headings by 5 degrees?
        return rv_histogram((likelyhoodByHeading, headings))

class _radioSondeDataSampler():
    &#39;&#39;&#39; 
        Parses data from radio sonde data files from IGRA-2 after they&#39;ve been post-processed by test/WindData/filterRadioSondeData.py
        IGRA-2 format info: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
    &#39;&#39;&#39;

    def __init__(self, silent=False, monteCarloDataLogger=None):
        self.silent = silent
        self.monteCarloDataLogger = monteCarloDataLogger

    def getRadioSondeWindProfile(self, locations=[&#34;Edmonton&#34;, &#34;Glasgow&#34;], locationWeights=[0.48, 0.52], locationASLAltitudes=[710, 638], launchMonth=None, randomSeed=None):
        &#39;&#39;&#39;
            Arguments:
                locations:              list of location names. Names must match those in radio sonde data file names (ex. &#34;Edmonton&#34; -&gt; &#34;RadioSondeEdmonton_filtered.txt&#34;)
                locationWeights:        list of numeric values, must add to one. Order should match list of locations.
                locationASLAltitudes:   list of ASL altitudes (m). Order should match list of locations.
                launchMonth:            3-letter string (&#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34;, etc...) indicating month from which data is desired. Otherwise &#34;Yearly&#34; or None to select randomly from all months
                randomSeed:             Pass in the same random seed to pick the same radio sonde profile

            Returns:
                altitudes:              List of numeric altitudes (meters AGL) 
                windVectors:            Corresponding list of wind vectors (m/s)
        &#39;&#39;&#39;
        # Set random seed if provided
        random.seed(randomSeed)

        # Pick a location
        selectedLocation = random.choices(locations, locationWeights, k=1)[0]

        locationASLAltitude = locationASLAltitudes[locations.index(selectedLocation)]
        # Load radiosonde data for that location
        radioSondeFilePath = &#34;test/WindData/RadioSonde{}_filtered.txt&#34;.format(selectedLocation)
        
        # Read datasets from fille
        if launchMonth != &#34;Yearly&#34;:
            datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath, filterByMonth=launchMonth)
        else:
            datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath)

        # Pick one of it&#39;s datasets
        selectedDataset = random.randint(0, len(datasetStartLines)-1)
        
        # selectedDataset is an array of strings, header is a string
        # Example header: #CAM00071119 2000 01 01 12 1117   75 ncdc-gts ncdc-gts  535475 -1141083
        header, radioSondeData = self._extractRadioSondeDataSet(datasetStartLines, data, selectedDataset)
        stationID, year, month, day, hour = self._parseRadioSondeHeader(header)

        if not self.silent:
            if self.monteCarloDataLogger != None:
                self.monteCarloDataLogger.log(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
            else:
                print(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
        
        # Turn data from strings into a numpy array
        altitudes, windVectors = self._parseRadioSondeData(radioSondeData, locationASLAltitude)
        return altitudes, windVectors

    def _readRadioSondeDataFile(self, radioSondeFilePath, filterByMonth=None):
        &#39;&#39;&#39;
            Arguments:
                radioSondeFilePath: String File Path to radio sonde data file
                filterByMonth: 3-letter acronym of month from which radio sonde profiles are desired. Pass in &#34;Yearly&#34; or None to select all months

            Returns: datasetStartlines, data
                datasetStartlines is a list containing the numbers on which each data set starts - lines not from filterByMonth are ommitted
                data is a list of strings, each being a line of the original file
        &#39;&#39;&#39;
        
        with open(radioSondeFilePath, &#39;r&#39;) as file:
            data = file.readlines()

        # Yearly means no filter
        if filterByMonth == &#34;Yearly&#34;:
            filterByMonth = None

        # Get Month number
        if filterByMonth != None:
            monthList = [ &#34;noZerothMonth&#34;, &#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34;, &#34;Apr&#34;, &#34;May&#34;, &#34;Jun&#34;, &#34;Jul&#34;, &#34;Aug&#34;, &#34;Sep&#34;, &#34;Oct&#34;, &#34;Nov&#34;, &#34;Dec&#34; ]
            monthNumber = monthList.index(filterByMonth)
        
        datasetStartLines = []
        i = 0
        while i &lt; len(data):
            # Radio sonde data header lines start with #
            # Check that profile month matches the desired month
            if data[i][0] == &#34;#&#34; and (filterByMonth == None or int(data[i].split()[2]) == monthNumber):
                datasetStartLines.append(i)
            i += 1
        
        return datasetStartLines, data

    def _extractRadioSondeDataSet(self, datasetStartLines, data, desiredDataSetNumber):
        &#39;&#39;&#39; Returns header string and list of strings representing data for chosen dataset &#39;&#39;&#39;
        startLine = datasetStartLines[desiredDataSetNumber]
        header = data[startLine]

        # Collect the data, starting with the line after the header
        i = startLine + 1
        dataset = []

        # Stop at next header or end of file
            # Don&#39;t go to next dataset start  line, because the start lines from other months are potentially excluded from that list, but still need to be respected here
        while i &lt; len(data) and data[i][0] != &#34;#&#34;:
            dataset.append(data[i])
            i += 1

        return header, dataset

    def _parseRadioSondeHeader(self, headerString):
        &#39;&#39;&#39;
            Returns stationID, Year, Month, Day, Hour
            Example header: #CAM00071119 2000 01 01 12 1117   75 ncdc-gts ncdc-gts  535475 -1141083
            Further data format info: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
        &#39;&#39;&#39;
        
        data = headerString.split()
        stationID = data[0][1:]
        year = int(data[1])
        month = int(data[2])
        day = int(data[3])
        hour = int(data[4])
        return stationID, year, month, day, hour

    def _parseRadioSondeData(self, data, locationASLAltitude):
        &#39;&#39;&#39;
            Returns:
                altitudes: List of AGL altitudes (m)
                windVectors: List of corresponding mean wind vectors

            Both returned lists are sorted from lowest to highest altitude

            Further info about radio sonde input data at: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
            Input data expects that radio sonde data has already been reduced to just the altitude, wind heading and wind speed columsn using test/WindData/filterRadioSondeData.py
        &#39;&#39;&#39;
        result = []
        for line in data:
            result.append([ float(x) for x in line.split() ])
        
        result = np.array(result)
        result[:,2] = result[:,2] / 10 # Convert to m/s from m/s *10

        # Sort rows by altitude
        result = result[result[:,0].argsort()]
        altitudes = result[:,0] - locationASLAltitude # Convert altitudes to AGL

        # Turn heading and speed into a velocity vector
        windVectors = []
        for i in range(len(result)):
            windDirection = _convertWindHeadingToXYPlaneWindDirection(result[i,1])
            windVec = windDirection*result[i,2]
            windVectors.append(np.array((windVec.X, windVec.Y, windVec.Z)))

        return altitudes, windVectors

def _convertWindHeadingToXYPlaneWindDirection(heading, AngleBetweenYAxisandNorth=0):
    &#39;&#39;&#39;
        Reminder: wind rose indicates where wind is blowing FROM
        This function outputs a vector indicating where wind is blowing TOWARDS
        Heading angle of 90 degrees is defined to point east
        AnglBetweenYAxis and North defined in the same way, if that&#39;s 90 degrees, the Y axis is pointing east
    &#39;&#39;&#39;
    totalAngleFromYAxis = heading + AngleBetweenYAxisandNorth
    y = cos(radians(totalAngleFromYAxis))
    x = sin(radians(totalAngleFromYAxis))
    headingVector = Vector(x, y, 0)
    windDirectionVector = -1 * headingVector # Wind is in opposite direction of heading
    return windDirectionVector

#If this file is run by itself
# if __name__ == &#39;__main__&#39;:
    # from SimDefinition import SimDefinition
    # fW = SimDefinition(&#34;test/simDefinitions/Wind.txt&#34;)
    # fW.setValue(&#34;Environment.MeanWindModel&#34;, &#34;SampledGroundWindData&#34;)

    # a = meanWindModelFactory(fW)

    # import matplotlib.pyplot as plt
    # plt.figure(figsize=(3.5,3))
    # plt.rcParams[&#34;font.family&#34;] = &#34;Times New Roman&#34;
    # plt.rcParams[&#34;font.size&#34;] = &#34;10&#34;




    # print(&#34;Plotting using scipy rv_histogram&#34;)
    # rvHist = a._createHeadingCDF_scipy(wR, windSpeed=5)

    # values = []
    # for i in range(10000):
    #     # Sample the rv_histogram using ppf function (Quantile)
    #     values.append(rvHist.ppf(random.random()))

    # plt.hist(values, bins=36, cumulative=True, density=True, label=&#34;Sampled CDF&#34;)

    # X = np.linspace(0, 360, 100)
    # plt.plot(X, rvHist.pdf(X)*100, label=&#34;PDF&#34;)
    # plt.plot(X, rvHist.cdf(X), label=&#34;CDF&#34;)

    # plt.legend()

    # plt.show()




    #### Plot radiosonde wind profile ####
    # from math import atan2, degrees
    # windHeadings = [ degrees(atan2(-x, -y)) for x,y,z in a.winds ]
    # for i in range(len(windHeadings)):
    #     if windHeadings[i] &lt; 0:
    #         windHeadings[i] += 360
    # windSpeeds = [ np.linalg.norm(x) for x in a.winds ]
    # altitudes = [ x / 1000 for x in a.windAltitudes ]


    # plt.plot(altitudes, windHeadings, label=&#34;Wind heading (degrees)&#34;)
    # plt.plot(altitudes, windSpeeds, label=&#34;Wind speed (m/s)&#34;)
    # plt.legend()
    # plt.ylim([0,350])
    # plt.xlim([0, 35])
    # plt.xlabel(&#34;Altitude (km, AGL)&#34;)
    # plt.tight_layout()
    # plt.savefig(&#34;C:/Users/rando/Documents/flightSimPaper/Figures/Images/SampleRadioSondeProfile_Edmonton20120304_12.eps&#34;, bbox_inches=&#34;tight&#34;, pad_inches=0)


    # plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling.meanWindModelFactory"><code class="name flex">
<span>def <span class="ident">meanWindModelFactory</span></span>(<span>simDefinition=None, silent=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Arguments:
simDefinition: A SimDefinition containing the simulation definition file for the present simulation</p>
<h2 id="returns">Returns</h2>
<p>meanWindModel, created based on the parameters provided in the SimDefinition passed in</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meanWindModelFactory(simDefinition=None, silent=False):
    &#39;&#39;&#39;
        Arguments: 
            simDefinition: A SimDefinition containing the simulation definition file for the present simulation

        Returns:
            meanWindModel, created based on the parameters provided in the SimDefinition passed in 
    &#39;&#39;&#39;
    if simDefinition == None:
        constWind = Vector(defaultConfigValues[&#34;Environment.ConstantMeanWind.velocity&#34;])
        return _meanWindModel_Constant(constWind)

    envReader = SubDictReader(&#39;Environment&#39;, simDefinition)
    meanWindModel = None
    meanWindModelType = envReader.getString(&#34;MeanWindModel&#34;)

    if meanWindModelType == &#34;Constant&#34;:
        meanGroundWind = envReader.getVector(&#34;ConstantMeanWind.velocity&#34;)
        if not silent:
            print(&#34;Constant ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))

        meanWindModel = _meanWindModel_Constant(meanGroundWind)

    elif meanWindModelType in [ &#34;SampledGroundWindData&#34;, &#34;Hellman&#34; ]:
        def getLocationSampledGroundWindVel():
            #### Get list of, and weights of, locations to sample wind rose from
            GroundWindLocationsSampled = envReader.getString(&#34;SampledGroundWindData.locationsToSample&#34;).split()
            locationsSampled = []
            locationWeights = []
            # Parse into locations (1st, 3rd, 5th... values) and weights (2nd, 4th, 6th... values)
            for i in range(0, len(GroundWindLocationsSampled), 2):
                locationsSampled.append(GroundWindLocationsSampled[i])
                locationWeights.append(float(GroundWindLocationsSampled[i+1]))
            launchMonth = envReader.getString(&#34;SampledGroundWindData.launchMonth&#34;)

            # Sample wind rose(s)
            sampler = _windRoseDataSampler(silent=silent)
            meanGroundWind = sampler.sampleWindRoses(locationsSampled, locationWeights, launchMonth)

            # Output choices parsed from input file and resulting wind
            if not silent:
                if simDefinition.monteCarloLogger != None:
                    simDefinition.monteCarloLogger.log(&#34;Sampling ground winds from: {}&#34;.format(locationsSampled))
                    simDefinition.monteCarloLogger.log(&#34;Sampling weights for each location: {}&#34;.format(locationWeights))
                    simDefinition.monteCarloLogger.log(&#34;Sampling wind distribution from month of: {}&#34;.format(launchMonth))
                    simDefinition.monteCarloLogger.log(&#34;Sampled mean ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))
                else:
                    print(&#34;Sampling ground winds from: {}&#34;.format(locationsSampled))
                    print(&#34;Sampling weights for each location: {}&#34;.format(locationWeights))
                    print(&#34;Sampling wind distribution from month of: {}&#34;.format(launchMonth))
                    print(&#34;Sampled mean ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))

            return meanGroundWind

        ### Create and return appropriate wind vs altitude model ###
        if meanWindModelType == &#34;SampledGroundWindData&#34;:
            meanGroundWind = getLocationSampledGroundWindVel()
            if not silent:
                print(&#34;Wind is not a function of altitude&#34;)
            meanWindModel = _meanWindModel_Constant(meanGroundWind)

        elif meanWindModelType == &#34;Hellman&#34;:
            groundWindModel = envReader.getString(&#34;Hellman.groundWindModel&#34;)

            # Get ground wind
            if groundWindModel == &#34;Constant&#34;:
                meanGroundWind = envReader.getVector(&#34;ConstantMeanWind.velocity&#34;)
            elif groundWindModel == &#34;SampledGroundWindData&#34;:
                meanGroundWind = getLocationSampledGroundWindVel()

            HellmanAlphaCoeff = envReader.getFloat(&#34;Hellman.alphaCoeff&#34;)
            HellmanAltitudeLimit = envReader.getFloat(&#34;Hellman.altitudeLimit&#34;)

            if not silent:
                print(&#34;Constant ground wind: {:1.2f} m/s&#34;.format(meanGroundWind))
                print(&#34;Wind vs. altitude governed by Hellman law: v2 = v1*(z2/10)^a where a = {}&#34;.format(HellmanAlphaCoeff))
                print(&#34;Hellman law is taken to apply up to an altitude of {} m AGL&#34;.format(HellmanAltitudeLimit))

            meanWindModel = _meanWindModel_Hellman(meanGroundWind, HellmanAltitudeLimit, HellmanAlphaCoeff)
    
    elif meanWindModelType == &#34;CustomWindProfile&#34;:
        meanWindProfileFilePath = envReader.getString(&#34;CustomWindProfile.filePath&#34;)
        meanWindModel = _meanWindModel_InterpolatedProfile(windFilePath=meanWindProfileFilePath)

    elif meanWindModelType == &#34;SampledRadioSondeData&#34;:
        # Get locations and location weights
        locationsAndWeights = envReader.getString(&#34;SampledRadioSondeData.locationsToSample&#34;).split()
        locations = []
        weights = []
        for i in range(0, len(locationsAndWeights), 2):
            locations.append(locationsAndWeights[i])
            weights.append(float(locationsAndWeights[i+1]))
            
        locationASLAltitudes = [ float(x) for x in envReader.getString(&#34;SampledRadioSondeData.locationASLAltitudes&#34;).split() ]

        # Get launch month
        launchMonth = envReader.getString(&#34;SampledRadioSondeData.launchMonth&#34;)

        # Get random seed (if provided)
        radioSondeRandomSeed = envReader.tryGetString(&#34;SampledRadioSondeData.randomSeed&#34;)

        # Select and parse radio sonde profile
        sampler = _radioSondeDataSampler(silent=silent)
        altitudes, windVectors = sampler.getRadioSondeWindProfile(locations, weights, locationASLAltitudes, launchMonth, radioSondeRandomSeed)
        
        meanWindModel = _meanWindModel_InterpolatedProfile(windAltitudes=altitudes, winds=windVectors)

    else:
        raise ValueError(&#34;Unknown MeanWindModel: {}. Please see SimDefinitionTemplate.txt for available options.&#34;.format(meanWindModelType))

    return meanWindModel</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling.MeanWindModel"><code class="flex name class">
<span>class <span class="ident">MeanWindModel</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines the interface for Mean Wind Models instantiated by meanWindModelFactory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeanWindModel(abc.ABC):
    &#39;&#39;&#39; Defines the interface for Mean Wind Models instantiated by meanWindModelFactory.    &#39;&#39;&#39;

    @abc.abstractmethod
    def getMeanWind(self, AGLAltitude):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant">_meanWindModel_Constant</a></li>
<li><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman">_meanWindModel_Hellman</a></li>
<li><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile">_meanWindModel_InterpolatedProfile</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling.MeanWindModel.getMeanWind"><code class="name flex">
<span>def <span class="ident">getMeanWind</span></span>(<span>self, AGLAltitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def getMeanWind(self, AGLAltitude):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant"><code class="flex name class">
<span>class <span class="ident">_meanWindModel_Constant</span></span>
<span>(</span><span>wind)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a constant wind speed at all altitudes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _meanWindModel_Constant(MeanWindModel):
    &#39;&#39;&#39; Defines a constant wind speed at all altitudes  &#39;&#39;&#39;
    
    def __init__(self, wind):
        self.wind = wind

    def getMeanWind(self, AGLAltitude):
        return self.wind</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.MeanWindModelling.MeanWindModel" href="#MAPLEAF.ENV.MeanWindModelling.MeanWindModel">MeanWindModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant.getMeanWind"><code class="name flex">
<span>def <span class="ident">getMeanWind</span></span>(<span>self, AGLAltitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMeanWind(self, AGLAltitude):
    return self.wind</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman"><code class="flex name class">
<span>class <span class="ident">_meanWindModel_Hellman</span></span>
<span>(</span><span>groundMeanWind=&lt;MAPLEAF.Motion.CythonVector.Vector object&gt;, altitudeLimit=1500, hellmanAlphaCoeff=0.14)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the Hellman law to scale a ground velocity using a power law as the atmospheric boundary layer is exited.
Low-altitude only. <a href="https://en.wikipedia.org/wiki/Wind_gradient">https://en.wikipedia.org/wiki/Wind_gradient</a> -&gt; Engineering Section.</p>
<h2 id="arguments">Arguments</h2>
<p>groundMeanWind: Wind Vector at ground level (~10m above surface), in m/s
altitudeLimit: Altitude above which the power law transitions into a constant profile (m, AGL)
hellmanAlphaCoeff: Alpha in the Hellman model (1/7 is a common first guess, but can vary widely depending on terrain)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _meanWindModel_Hellman(MeanWindModel):
    &#39;&#39;&#39;
        Uses the Hellman law to scale a ground velocity using a power law as the atmospheric boundary layer is exited.
        Low-altitude only. https://en.wikipedia.org/wiki/Wind_gradient -&gt; Engineering Section.

    &#39;&#39;&#39;
    def __init__(self, groundMeanWind=Vector(0,0,0), altitudeLimit=1500, hellmanAlphaCoeff=0.14):
        &#39;&#39;&#39;
            Arguments:
                groundMeanWind: Wind Vector at ground level (~10m above surface), in m/s
                altitudeLimit: Altitude above which the power law transitions into a constant profile (m, AGL)
                hellmanAlphaCoeff: Alpha in the Hellman model (1/7 is a common first guess, but can vary widely depending on terrain)
        &#39;&#39;&#39;
        self.groundMeanWind = groundMeanWind
        self.altitudeLimit = altitudeLimit
        self.hellmanAlphaCoeff = hellmanAlphaCoeff

    def getMeanWind(self, AGLAltitude):
        # Limit velocity scaling to up to the specified altitude limit
        HellmanAltitude = max(min(self.altitudeLimit, AGLAltitude), 10)
        # Assume initial winds come from a height of 10m
        return self.groundMeanWind * (HellmanAltitude/10)**self.hellmanAlphaCoeff</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.MeanWindModelling.MeanWindModel" href="#MAPLEAF.ENV.MeanWindModelling.MeanWindModel">MeanWindModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman.getMeanWind"><code class="name flex">
<span>def <span class="ident">getMeanWind</span></span>(<span>self, AGLAltitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMeanWind(self, AGLAltitude):
    # Limit velocity scaling to up to the specified altitude limit
    HellmanAltitude = max(min(self.altitudeLimit, AGLAltitude), 10)
    # Assume initial winds come from a height of 10m
    return self.groundMeanWind * (HellmanAltitude/10)**self.hellmanAlphaCoeff</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile"><code class="flex name class">
<span>class <span class="ident">_meanWindModel_InterpolatedProfile</span></span>
<span>(</span><span>windAltitudes=[], winds=[], windFilePath=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the interface for Mean Wind Models instantiated by meanWindModelFactory.
</p>
<h2 id="arguments">Arguments</h2>
<p>windAltitudes: list of altitudes at which wind vectors will be provided (m AGL)
winds: list of wind vectors, matching the ordering of windAltitudes (m/s)</p>
<p>windFilePath: string path to a text file containing a table, formatted similarly to the following:
AGlAltitude(m) WindX(m/s) WindY(m/s) WindZ(m/s)
a1
wx1
wy1
wz1
a2
wx2
wy2
wz2</p>
<h2 id="notes">Notes</h2>
<p>Provide either windAltitudes AND winds, OR windFilePath. If all are provided, windAltitudes/winds will be used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _meanWindModel_InterpolatedProfile(MeanWindModel):
    def __init__(self, windAltitudes=[], winds=[], windFilePath=None):
        &#39;&#39;&#39;
            Arguments:
                windAltitudes: list of altitudes at which wind vectors will be provided (m AGL)
                winds: list of wind vectors, matching the ordering of windAltitudes (m/s)

                windFilePath: string path to a text file containing a table, formatted similarly to the following:
                    AGlAltitude(m) WindX(m/s) WindY(m/s) WindZ(m/s)
                    a1              wx1         wy1     wz1
                    a2              wx2         wy2     wz2

            Notes:
                Provide either windAltitudes AND winds, OR windFilePath. If all are provided, windAltitudes/winds will be used
        &#39;&#39;&#39;
        if len(windAltitudes) + len(winds) &gt; 0:
            self.windAltitudes = windAltitudes
            self.winds = winds

        elif windFilePath != None:
            self._readCustomWindProfile(windFilePath)

        else:
            raise ValueError(&#34;Incomplete initialization info provided. Provide either windAltitudes AND winds, OR windFilePath&#34;)

    def _readCustomWindProfile(self, filePath):
        windProfile = np.loadtxt(filePath, skiprows=1)
        self.windAltitudes = windProfile[:, 0]
        self.winds = windProfile[:, 1:]

    def getMeanWind(self, AGLAltitude):
        return Vector(*linInterp(self.windAltitudes, self.winds, AGLAltitude))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.MeanWindModelling.MeanWindModel" href="#MAPLEAF.ENV.MeanWindModelling.MeanWindModel">MeanWindModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile.getMeanWind"><code class="name flex">
<span>def <span class="ident">getMeanWind</span></span>(<span>self, AGLAltitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMeanWind(self, AGLAltitude):
    return Vector(*linInterp(self.windAltitudes, self.winds, AGLAltitude))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler"><code class="flex name class">
<span>class <span class="ident">_radioSondeDataSampler</span></span>
<span>(</span><span>silent=False, monteCarloDataLogger=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses data from radio sonde data files from IGRA-2 after they've been post-processed by test/WindData/filterRadioSondeData.py
IGRA-2 format info: <a href="https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt">https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _radioSondeDataSampler():
    &#39;&#39;&#39; 
        Parses data from radio sonde data files from IGRA-2 after they&#39;ve been post-processed by test/WindData/filterRadioSondeData.py
        IGRA-2 format info: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
    &#39;&#39;&#39;

    def __init__(self, silent=False, monteCarloDataLogger=None):
        self.silent = silent
        self.monteCarloDataLogger = monteCarloDataLogger

    def getRadioSondeWindProfile(self, locations=[&#34;Edmonton&#34;, &#34;Glasgow&#34;], locationWeights=[0.48, 0.52], locationASLAltitudes=[710, 638], launchMonth=None, randomSeed=None):
        &#39;&#39;&#39;
            Arguments:
                locations:              list of location names. Names must match those in radio sonde data file names (ex. &#34;Edmonton&#34; -&gt; &#34;RadioSondeEdmonton_filtered.txt&#34;)
                locationWeights:        list of numeric values, must add to one. Order should match list of locations.
                locationASLAltitudes:   list of ASL altitudes (m). Order should match list of locations.
                launchMonth:            3-letter string (&#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34;, etc...) indicating month from which data is desired. Otherwise &#34;Yearly&#34; or None to select randomly from all months
                randomSeed:             Pass in the same random seed to pick the same radio sonde profile

            Returns:
                altitudes:              List of numeric altitudes (meters AGL) 
                windVectors:            Corresponding list of wind vectors (m/s)
        &#39;&#39;&#39;
        # Set random seed if provided
        random.seed(randomSeed)

        # Pick a location
        selectedLocation = random.choices(locations, locationWeights, k=1)[0]

        locationASLAltitude = locationASLAltitudes[locations.index(selectedLocation)]
        # Load radiosonde data for that location
        radioSondeFilePath = &#34;test/WindData/RadioSonde{}_filtered.txt&#34;.format(selectedLocation)
        
        # Read datasets from fille
        if launchMonth != &#34;Yearly&#34;:
            datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath, filterByMonth=launchMonth)
        else:
            datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath)

        # Pick one of it&#39;s datasets
        selectedDataset = random.randint(0, len(datasetStartLines)-1)
        
        # selectedDataset is an array of strings, header is a string
        # Example header: #CAM00071119 2000 01 01 12 1117   75 ncdc-gts ncdc-gts  535475 -1141083
        header, radioSondeData = self._extractRadioSondeDataSet(datasetStartLines, data, selectedDataset)
        stationID, year, month, day, hour = self._parseRadioSondeHeader(header)

        if not self.silent:
            if self.monteCarloDataLogger != None:
                self.monteCarloDataLogger.log(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
            else:
                print(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
        
        # Turn data from strings into a numpy array
        altitudes, windVectors = self._parseRadioSondeData(radioSondeData, locationASLAltitude)
        return altitudes, windVectors

    def _readRadioSondeDataFile(self, radioSondeFilePath, filterByMonth=None):
        &#39;&#39;&#39;
            Arguments:
                radioSondeFilePath: String File Path to radio sonde data file
                filterByMonth: 3-letter acronym of month from which radio sonde profiles are desired. Pass in &#34;Yearly&#34; or None to select all months

            Returns: datasetStartlines, data
                datasetStartlines is a list containing the numbers on which each data set starts - lines not from filterByMonth are ommitted
                data is a list of strings, each being a line of the original file
        &#39;&#39;&#39;
        
        with open(radioSondeFilePath, &#39;r&#39;) as file:
            data = file.readlines()

        # Yearly means no filter
        if filterByMonth == &#34;Yearly&#34;:
            filterByMonth = None

        # Get Month number
        if filterByMonth != None:
            monthList = [ &#34;noZerothMonth&#34;, &#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34;, &#34;Apr&#34;, &#34;May&#34;, &#34;Jun&#34;, &#34;Jul&#34;, &#34;Aug&#34;, &#34;Sep&#34;, &#34;Oct&#34;, &#34;Nov&#34;, &#34;Dec&#34; ]
            monthNumber = monthList.index(filterByMonth)
        
        datasetStartLines = []
        i = 0
        while i &lt; len(data):
            # Radio sonde data header lines start with #
            # Check that profile month matches the desired month
            if data[i][0] == &#34;#&#34; and (filterByMonth == None or int(data[i].split()[2]) == monthNumber):
                datasetStartLines.append(i)
            i += 1
        
        return datasetStartLines, data

    def _extractRadioSondeDataSet(self, datasetStartLines, data, desiredDataSetNumber):
        &#39;&#39;&#39; Returns header string and list of strings representing data for chosen dataset &#39;&#39;&#39;
        startLine = datasetStartLines[desiredDataSetNumber]
        header = data[startLine]

        # Collect the data, starting with the line after the header
        i = startLine + 1
        dataset = []

        # Stop at next header or end of file
            # Don&#39;t go to next dataset start  line, because the start lines from other months are potentially excluded from that list, but still need to be respected here
        while i &lt; len(data) and data[i][0] != &#34;#&#34;:
            dataset.append(data[i])
            i += 1

        return header, dataset

    def _parseRadioSondeHeader(self, headerString):
        &#39;&#39;&#39;
            Returns stationID, Year, Month, Day, Hour
            Example header: #CAM00071119 2000 01 01 12 1117   75 ncdc-gts ncdc-gts  535475 -1141083
            Further data format info: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
        &#39;&#39;&#39;
        
        data = headerString.split()
        stationID = data[0][1:]
        year = int(data[1])
        month = int(data[2])
        day = int(data[3])
        hour = int(data[4])
        return stationID, year, month, day, hour

    def _parseRadioSondeData(self, data, locationASLAltitude):
        &#39;&#39;&#39;
            Returns:
                altitudes: List of AGL altitudes (m)
                windVectors: List of corresponding mean wind vectors

            Both returned lists are sorted from lowest to highest altitude

            Further info about radio sonde input data at: https://www1.ncdc.noaa.gov/pub/data/igra/data/igra2-data-format.txt
            Input data expects that radio sonde data has already been reduced to just the altitude, wind heading and wind speed columsn using test/WindData/filterRadioSondeData.py
        &#39;&#39;&#39;
        result = []
        for line in data:
            result.append([ float(x) for x in line.split() ])
        
        result = np.array(result)
        result[:,2] = result[:,2] / 10 # Convert to m/s from m/s *10

        # Sort rows by altitude
        result = result[result[:,0].argsort()]
        altitudes = result[:,0] - locationASLAltitude # Convert altitudes to AGL

        # Turn heading and speed into a velocity vector
        windVectors = []
        for i in range(len(result)):
            windDirection = _convertWindHeadingToXYPlaneWindDirection(result[i,1])
            windVec = windDirection*result[i,2]
            windVectors.append(np.array((windVec.X, windVec.Y, windVec.Z)))

        return altitudes, windVectors</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler.getRadioSondeWindProfile"><code class="name flex">
<span>def <span class="ident">getRadioSondeWindProfile</span></span>(<span>self, locations=['Edmonton', 'Glasgow'], locationWeights=[0.48, 0.52], locationASLAltitudes=[710, 638], launchMonth=None, randomSeed=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="arguments">Arguments</h2>
<p>locations:
list of location names. Names must match those in radio sonde data file names (ex. "Edmonton" -&gt; "RadioSondeEdmonton_filtered.txt")
locationWeights:
list of numeric values, must add to one. Order should match list of locations.
locationASLAltitudes:
list of ASL altitudes (m). Order should match list of locations.
launchMonth:
3-letter string ("Jan", "Feb", "Mar", etc&hellip;) indicating month from which data is desired. Otherwise "Yearly" or None to select randomly from all months
randomSeed:
Pass in the same random seed to pick the same radio sonde profile</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>altitudes</code></dt>
<dd>
<pre><code>     List of numeric altitudes (meters AGL)
</code></pre>
</dd>
<dt><code>windVectors</code></dt>
<dd>
<pre><code>   Corresponding list of wind vectors (m/s)
</code></pre>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getRadioSondeWindProfile(self, locations=[&#34;Edmonton&#34;, &#34;Glasgow&#34;], locationWeights=[0.48, 0.52], locationASLAltitudes=[710, 638], launchMonth=None, randomSeed=None):
    &#39;&#39;&#39;
        Arguments:
            locations:              list of location names. Names must match those in radio sonde data file names (ex. &#34;Edmonton&#34; -&gt; &#34;RadioSondeEdmonton_filtered.txt&#34;)
            locationWeights:        list of numeric values, must add to one. Order should match list of locations.
            locationASLAltitudes:   list of ASL altitudes (m). Order should match list of locations.
            launchMonth:            3-letter string (&#34;Jan&#34;, &#34;Feb&#34;, &#34;Mar&#34;, etc...) indicating month from which data is desired. Otherwise &#34;Yearly&#34; or None to select randomly from all months
            randomSeed:             Pass in the same random seed to pick the same radio sonde profile

        Returns:
            altitudes:              List of numeric altitudes (meters AGL) 
            windVectors:            Corresponding list of wind vectors (m/s)
    &#39;&#39;&#39;
    # Set random seed if provided
    random.seed(randomSeed)

    # Pick a location
    selectedLocation = random.choices(locations, locationWeights, k=1)[0]

    locationASLAltitude = locationASLAltitudes[locations.index(selectedLocation)]
    # Load radiosonde data for that location
    radioSondeFilePath = &#34;test/WindData/RadioSonde{}_filtered.txt&#34;.format(selectedLocation)
    
    # Read datasets from fille
    if launchMonth != &#34;Yearly&#34;:
        datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath, filterByMonth=launchMonth)
    else:
        datasetStartLines, data = self._readRadioSondeDataFile(radioSondeFilePath)

    # Pick one of it&#39;s datasets
    selectedDataset = random.randint(0, len(datasetStartLines)-1)
    
    # selectedDataset is an array of strings, header is a string
    # Example header: #CAM00071119 2000 01 01 12 1117   75 ncdc-gts ncdc-gts  535475 -1141083
    header, radioSondeData = self._extractRadioSondeDataSet(datasetStartLines, data, selectedDataset)
    stationID, year, month, day, hour = self._parseRadioSondeHeader(header)

    if not self.silent:
        if self.monteCarloDataLogger != None:
            self.monteCarloDataLogger.log(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
        else:
            print(&#34;Wind data from radio sonde dataset: {}, stationID: {}, {}, {}, {}, {}&#34;.format(selectedLocation, stationID, year, month, day, hour))
    
    # Turn data from strings into a numpy array
    altitudes, windVectors = self._parseRadioSondeData(radioSondeData, locationASLAltitude)
    return altitudes, windVectors</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler"><code class="flex name class">
<span>class <span class="ident">_windRoseDataSampler</span></span>
<span>(</span><span>silent=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses wind rose data files from Iowa State University's Environmental Mesonet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class _windRoseDataSampler():
    &#39;&#39;&#39; 
        Parses wind rose data files from Iowa State University&#39;s Environmental Mesonet.
    &#39;&#39;&#39;

    def __init__(self, silent=False):
        self.silent = silent

        # TODO: Generalize extreme winds outside Medecine Hat
        self.extremeWinds = [ 25, 31, 50 ] # mph = [ 40, 50, 80 ] km/h
        self.extremeWinds = [ x * 0.44704 for x in self.extremeWinds ] # convert to m/s
        self.extremeWindProbabilities = [ 0.01, 0.004, 0 ] # Decimal, chance of being at or higher than given wind speed, based on hourly peak gust data for Medecine Hat, AB

    def sampleWindRoses(self, locationsSampled, locationWeights, launchMonth):
        # Choose a wind rose based on the location weights
        averagedWindRose = self._getAveragedWindRose( Months=[launchMonth], locations=locationsSampled, locationWeights=locationWeights )
        speedrvHist = self._createWindSpeedCDF(averagedWindRose)
        
        # Choose a wind speed
        windSpeed = speedrvHist.ppf(random.random())
        
        # Construct heading probabilities based on that wind speed, then choose a wind heading
        heading_rvHist = self._createHeadingCDF(averagedWindRose, windSpeed=windSpeed)
        windHeading = heading_rvHist.ppf(random.random())
        windDirectionVector = _convertWindHeadingToXYPlaneWindDirection(windHeading)
        meanGroundWind = windDirectionVector * windSpeed

        return meanGroundWind

    def _readWindRose(self, filePath):
        &#39;&#39;&#39;
            Currently not general, will only work with Wind Rose data from Iowa State University - Iowa Environmental Mesonet
            http://mesonet.agron.iastate.edu/sites/windrose.phtml?network=WI_ASOS&amp;station=CWA
        &#39;&#39;&#39;
        # Read data (Header = Direction,     Calm, 2.0  4.9, 5.0  6.9, 7.0  9.9,10.0 14.9,15.0 19.9,    20.0+)
        windRose = pd.read_csv(filePath, delimiter=&#34;,&#34;, comment=&#34;#&#34;)
        # Split direction column into min and max directions: ex. &#34;000-010&#34;
        directionMinMax = windRose[&#34;Direction&#34;].str.split(&#34;-&#34;, n=1, expand=True)
        windRose.drop(columns=[&#34;Direction&#34;], inplace=True)
        # Convert each of the split string data to floats
        directionMinMax = directionMinMax.astype(float)
        # Add new direction columns
        windRose[&#34;direction&#34;] = (directionMinMax[0] + directionMinMax[1]) / 2
        # Set first direction to 0 degrees instead of 5 (assumed incorrect in windrose file)
        windRose.iloc[0,-1] = 0

        nameMap = {
            &#34;     Calm&#34;: 1.0,
            &#34; 2.0  4.9&#34;: 3.5,
            &#34; 5.0  6.9&#34;: 6.0,
            &#34; 7.0  9.9&#34;: 8.5,
            &#34;10.0 14.9&#34;: 12.5,
            &#34;15.0 19.9&#34;: 17.5,
            &#34;    20.0+&#34;: 23.5
        }
        windRose.rename(mapper=nameMap, inplace=True, axis=&#39;columns&#39;)

        # Replace empty values in the first column with zeros
        windRose.replace(r&#39;^\s*$&#39;, 0.0, regex=True, inplace=True)
        windRose[1.0] = windRose[1.0].astype(float)

        return windRose

    def _getAveragedWindRose(self, Months=[&#34;May&#34;], MonthWeights=[1.0], locations=[&#34;MedecineHat&#34;], locationWeights=[1.0]):
        windRose = self._readWindRose(&#34;test/WindData/WindroseAprMedecineHat.txt&#34;)*0.0 # Initialize as zero
        for i in range(len(Months)):
            for a in range(len(locations)):
                windRoseFilePath = &#34;test/WindData/Windrose{}{}.txt&#34;.format(Months[i], locations[a])
                windRose += self._readWindRose(windRoseFilePath) * MonthWeights[i] * locationWeights[a]

        return windRose.copy()

    def _createWindSpeedCDF(self, windRose):
        &#39;&#39;&#39;Calculates wind speed CDF from a windrose (wind rose can be generated using self.readWindRose())&#39;&#39;&#39;
        # Sum over headings to get probabilities for each speed
        likelyhoodBySpeed = windRose.sum()
        likelyhoodBySpeed.drop(index=[&#34;direction&#34;], inplace=True)

        # Normalize to 0-1 probability range
        totalProb = likelyhoodBySpeed.sum()
        likelyhoodBySpeed = list(likelyhoodBySpeed / totalProb)

        # Bin boundaries
        cdfX = [ x * 0.44704 for x in [ 0, 2, 5, 7, 10, 15, 20, 23.5 ] ] # Convert to m/s from mph
        likelyhoodBySpeed[-1] -= sum(self.extremeWindProbabilities)
        cdfX += self.extremeWinds
        likelyhoodBySpeed += self.extremeWindProbabilities

        return rv_histogram((likelyhoodBySpeed, cdfX))

    def _createHeadingCDF(self, windRose, windSpeed=None):
        &#39;&#39;&#39;
            Calculates wind heading CDF from a windrose (wind rose can be generated using self.readWindRose())
            Pass in wind speed in m/s
        &#39;&#39;&#39;
        windRose = windRose.set_index(&#34;direction&#34;)
        windRose.loc[360] = windRose.loc[0]
        windRose.drop(index=[0], inplace=True)
        headings = list(windRose.index)
        headings.insert(0,0)
        
        if windSpeed == None:
            # Sum over all speeds to get overall probabilities for each heading
            likelyhoodByHeading = list(windRose.sum(axis=1))
        else:
            # Eliminate the empty first column, replace it with data from the 3.5 mph column
            windRose.iloc[:,0] = windRose.iloc[:,1]
            windRose.rename(columns={1.0:0.0}, inplace=True)

            # Convert from mph to m/s string
            windRose = windRose.rename(columns=lambda c: str(c * 0.44704))
            
            try:
                # If windSpeed exists already, use it
                likelyhoodByHeading = list(windRose[str(windSpeed)])
            except KeyError:
                #### Linearly interpolate to find wind speed probabilities at the given heading ####
                # Create new empty column at desired wind speed
                windRose[str(windSpeed)] = np.nan
                # Convert back to float names
                windRose = windRose.rename(columns=lambda c: float(c))
                # Sort the new column into position
                windRose = windRose.reindex(sorted(windRose.columns), axis=1)
                # Interpolate
                windRose = windRose.interpolate(method=&#34;index&#34;, axis=1, interpolate=True)            
                # Grab the new column as a list
                likelyhoodByHeading = list(windRose[windSpeed])

        #TODO: Need to de-rotate these headings by 5 degrees?
        return rv_histogram((likelyhoodByHeading, headings))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler.sampleWindRoses"><code class="name flex">
<span>def <span class="ident">sampleWindRoses</span></span>(<span>self, locationsSampled, locationWeights, launchMonth)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sampleWindRoses(self, locationsSampled, locationWeights, launchMonth):
    # Choose a wind rose based on the location weights
    averagedWindRose = self._getAveragedWindRose( Months=[launchMonth], locations=locationsSampled, locationWeights=locationWeights )
    speedrvHist = self._createWindSpeedCDF(averagedWindRose)
    
    # Choose a wind speed
    windSpeed = speedrvHist.ppf(random.random())
    
    # Construct heading probabilities based on that wind speed, then choose a wind heading
    heading_rvHist = self._createHeadingCDF(averagedWindRose, windSpeed=windSpeed)
    windHeading = heading_rvHist.ppf(random.random())
    windDirectionVector = _convertWindHeadingToXYPlaneWindDirection(windHeading)
    meanGroundWind = windDirectionVector * windSpeed

    return meanGroundWind</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.ENV" href="index.html">MAPLEAF.ENV</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling.meanWindModelFactory" href="#MAPLEAF.ENV.MeanWindModelling.meanWindModelFactory">meanWindModelFactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling.MeanWindModel" href="#MAPLEAF.ENV.MeanWindModelling.MeanWindModel">MeanWindModel</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling.MeanWindModel.getMeanWind" href="#MAPLEAF.ENV.MeanWindModelling.MeanWindModel.getMeanWind">getMeanWind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant">_meanWindModel_Constant</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant.getMeanWind" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Constant.getMeanWind">getMeanWind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman">_meanWindModel_Hellman</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman.getMeanWind" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_Hellman.getMeanWind">getMeanWind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile">_meanWindModel_InterpolatedProfile</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile.getMeanWind" href="#MAPLEAF.ENV.MeanWindModelling._meanWindModel_InterpolatedProfile.getMeanWind">getMeanWind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler" href="#MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler">_radioSondeDataSampler</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler.getRadioSondeWindProfile" href="#MAPLEAF.ENV.MeanWindModelling._radioSondeDataSampler.getRadioSondeWindProfile">getRadioSondeWindProfile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler" href="#MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler">_windRoseDataSampler</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler.sampleWindRoses" href="#MAPLEAF.ENV.MeanWindModelling._windRoseDataSampler.sampleWindRoses">sampleWindRoses</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>