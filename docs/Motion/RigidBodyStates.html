<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>MAPLEAF.Motion.RigidBodyStates API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.Motion.RigidBodyStates</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from MAPLEAF.Motion.CythonVector import Vector
from MAPLEAF.Motion.CythonQuaternion import Quaternion
from MAPLEAF.Motion.CythonAngularVelocity import AngularVelocity

class RigidBodyState_3DoF():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame

        Adding rigidBodyStates adds the vectors

        Multiplying an rigidBodyState by a scalar scales the vectors
            0.5 *  = half the vector length
    &#34;&#34;&#34;
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        
        return RigidBodyState_3DoF(newPos, newVel)

    def __mul__(self, scalar):
        &#39;&#39;&#39; Used to negate the rigid body state for subtractions &#39;&#39;&#39;
        scalar = float(scalar)
        newPos = self.position * scalar
        newVel = self.velocity * scalar

        return RigidBodyState_3DoF(newPos, newVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;
        #TODO: Ensure this scales properly with the version in the 6DoF IntegratbleRigidBodyState __abs__ function

        return self.position.length() + self.velocity.length()

    ### String Functions ###
    def getLogHeader(self):
        return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s)&#34;

    def __str__(self):
        &#39;&#39;&#39; Called by print &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f}&#34;.format(self.position, self.velocity)

    def __neg__(self):
        return self*-1

class RigidBodyStateDerivative_3DoF():
    def __init__(self, velocity, acceleration):
        self.velocity = velocity
        self.acceleration = acceleration

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.velocity + rigidBodyState2.velocity
        newVel = self.acceleration + rigidBodyState2.acceleration
        
        return RigidBodyStateDerivative_3DoF(newPos, newVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39; Used in: initVal + timeStep {*} slope &#39;&#39;&#39;
        timeStep = float(timeStep)
        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep

        # After multiplying by a timestep, we get a regular (integrated) rigid body state back
        return RigidBodyState_3DoF(dPos, dVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar

        return RigidBodyStateDerivative_3DoF(vel, accel)

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar

class RigidBodyState():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame
            Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket&#39;s local frame 
                (Orientation of the rocket in the global frame)
            Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame

        Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)

        Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
            0.5 *  = half the vector length, half the rotation size, directions the same

        No other operations are defined
    &#34;&#34;&#34;
    def __init__(self, position=Vector(0,0,0), velocity=Vector(0,0,0), orientation=Quaternion(1,0,0,0), angularVelocity=AngularVelocity(0,0,0)):
        self.position = position
        self.velocity = velocity
        self.orientation = orientation
        self.angularVelocity = angularVelocity
    
    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        newAngVel = self.angularVelocity + rigidBodyState2.angularVelocity
        newOrientation = rigidBodyState2.orientation * self.orientation.normalize()
        
        return RigidBodyState(newPos, newVel, newOrientation.normalize(), newAngVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: initVal + timeStep {*} slope
            Expected to always be multiplied by a scalar
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        newPos = self.position * timeStep
        newVel = self.velocity * timeStep
        newAngVel = self.angularVelocity * timeStep
        newOrientation = self.orientation.scaleRotation(timeStep)

        return RigidBodyState(newPos, newVel, newOrientation, newAngVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        positionMag = self.position.length() + self.velocity.length()
        orientationMag = abs(self.orientation.rotationAngle()) + self.angularVelocity.angVel()

        return orientationMag*100 + positionMag

    def __eq__(self, iRBS2):
        try:
            properties = [ self.position, self.velocity, self.orientation, self.angularVelocity ]
            otherProperties = [ iRBS2.position, iRBS2.velocity, iRBS2.orientation, iRBS2.angularVelocity ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### String Functions ###
    def getLogHeader(self):
        return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s) OrientationQuat0 OrientationQuat1 OrientationQuat2 OrientationQuat3 AngularVelocityX(rad/s) AngularVelocityY(rad/s) AngularVelocityZ(rad/s)&#34;

    def __str__(self):
        &#39;&#39;&#39; Called by print function &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f} {:&gt;11.7f} {:&gt;9.4f}&#34;.format(self.position, self.velocity, self.orientation, self.angularVelocity)

    ### Wrapper/Thin functions ###
    def __neg__(self):
        return RigidBodyState(self.position*-1, self.velocity*-1, self.orientation.conjugate(), self.angularVelocity*-1)

class RigidBodyStateDerivative():
    def __init__(self, velocity, acceleration, angularVelocity, angularAccel):
        self.velocity = velocity
        self.acceleration = acceleration
        self.angularVelocity = angularVelocity
        self.angularAccel = angularAccel

    def __add__(self, state2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newVel = self.velocity + state2.velocity
        newAccel = self.acceleration + state2.acceleration
        newAngVel = self.angularVelocity + state2.angularVelocity
        newAngAccel = self.angularAccel + state2.angularAccel
        
        return RigidBodyStateDerivative(newVel, newAccel, newAngVel, newAngAccel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: timeStep {*} slope
            Expected to always be multiplied by a scalar, timestep
            Returns integrated change in rigid body state over given time step
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep
        dOrientation = (self.angularVelocity * timeStep).toQuaternion()
        dOrientation.normalize()
        dAngVel = self.angularAccel * timeStep

        # After integration over a time step, get a regular rigid body state back
        return RigidBodyState(dPos, dVel, dOrientation, dAngVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar
        angVel = self.angularVelocity * invScalar
        angAccel = self.angularAccel * invScalar

        return RigidBodyStateDerivative(vel, accel, angVel, angAccel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        # positionMag = self.position.length() + self.velocity.length()

        orientationMag = self.angularVelocity.angVel() + self.angularAccel.angVel()

        return orientationMag*100

    def __eq__(self, state2):
        try:
            properties = [ self.velocity, self.acceleration, self.angularVelocity, self.angularAccel ]
            otherProperties = [ state2.velocity, state2.acceleration, state2.angularVelocity, state2.angularAccel ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState"><code class="flex name class">
<span>class <span class="ident">RigidBodyState</span></span>
<span>(</span><span>position=&lt;MAPLEAF.Motion.CythonVector.Vector object&gt;, velocity=&lt;MAPLEAF.Motion.CythonVector.Vector object&gt;, orientation=&lt;MAPLEAF.Motion.CythonQuaternion.Quaternion object&gt;, angularVelocity=&lt;MAPLEAF.Motion.CythonAngularVelocity.AngularVelocity object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
Pos/Vel are expected to be Vectors - Defined with reference to the global frame
Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket's local frame
(Orientation of the rocket in the global frame)
Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame</p>
<p>Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)</p>
<p>Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
0.5 *
= half the vector length, half the rotation size, directions the same</p>
<p>No other operations are defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyState():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame
            Orientation is expected to be a Quaternion - Defines the rotation from the global inertial reference frame to the rocket&#39;s local frame 
                (Orientation of the rocket in the global frame)
            Angular Velocity is expected to be an Angular Velocity - Defined with reference to the local frame

        Adding rigidBodyStates adds the vectors and multiplies the quaternions (which adds the rotations they represent)

        Multiplying an rigidBodyState by a scalar scales the vectors and rotation defined by the quaternions
            0.5 *  = half the vector length, half the rotation size, directions the same

        No other operations are defined
    &#34;&#34;&#34;
    def __init__(self, position=Vector(0,0,0), velocity=Vector(0,0,0), orientation=Quaternion(1,0,0,0), angularVelocity=AngularVelocity(0,0,0)):
        self.position = position
        self.velocity = velocity
        self.orientation = orientation
        self.angularVelocity = angularVelocity
    
    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        newAngVel = self.angularVelocity + rigidBodyState2.angularVelocity
        newOrientation = rigidBodyState2.orientation * self.orientation.normalize()
        
        return RigidBodyState(newPos, newVel, newOrientation.normalize(), newAngVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: initVal + timeStep {*} slope
            Expected to always be multiplied by a scalar
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        newPos = self.position * timeStep
        newVel = self.velocity * timeStep
        newAngVel = self.angularVelocity * timeStep
        newOrientation = self.orientation.scaleRotation(timeStep)

        return RigidBodyState(newPos, newVel, newOrientation, newAngVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        positionMag = self.position.length() + self.velocity.length()
        orientationMag = abs(self.orientation.rotationAngle()) + self.angularVelocity.angVel()

        return orientationMag*100 + positionMag

    def __eq__(self, iRBS2):
        try:
            properties = [ self.position, self.velocity, self.orientation, self.angularVelocity ]
            otherProperties = [ iRBS2.position, iRBS2.velocity, iRBS2.orientation, iRBS2.angularVelocity ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### String Functions ###
    def getLogHeader(self):
        return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s) OrientationQuat0 OrientationQuat1 OrientationQuat2 OrientationQuat3 AngularVelocityX(rad/s) AngularVelocityY(rad/s) AngularVelocityZ(rad/s)&#34;

    def __str__(self):
        &#39;&#39;&#39; Called by print function &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f} {:&gt;11.7f} {:&gt;9.4f}&#34;.format(self.position, self.velocity, self.orientation, self.angularVelocity)

    ### Wrapper/Thin functions ###
    def __neg__(self):
        return RigidBodyState(self.position*-1, self.velocity*-1, self.orientation.conjugate(), self.angularVelocity*-1)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s) OrientationQuat0 OrientationQuat1 OrientationQuat2 OrientationQuat3 AngularVelocityX(rad/s) AngularVelocityY(rad/s) AngularVelocityZ(rad/s)&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative"><code class="flex name class">
<span>class <span class="ident">RigidBodyStateDerivative</span></span>
<span>(</span><span>velocity, acceleration, angularVelocity, angularAccel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyStateDerivative():
    def __init__(self, velocity, acceleration, angularVelocity, angularAccel):
        self.velocity = velocity
        self.acceleration = acceleration
        self.angularVelocity = angularVelocity
        self.angularAccel = angularAccel

    def __add__(self, state2):
        &#39;&#39;&#39; Used in: initVal {+} (timeStep * slope) &#39;&#39;&#39;
        newVel = self.velocity + state2.velocity
        newAccel = self.acceleration + state2.acceleration
        newAngVel = self.angularVelocity + state2.angularVelocity
        newAngAccel = self.angularAccel + state2.angularAccel
        
        return RigidBodyStateDerivative(newVel, newAccel, newAngVel, newAngAccel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39;
            Used in: timeStep {*} slope
            Expected to always be multiplied by a scalar, timestep
            Returns integrated change in rigid body state over given time step
        &#39;&#39;&#39;
        timeStep = float(timeStep)

        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep
        dOrientation = (self.angularVelocity * timeStep).toQuaternion()
        dOrientation.normalize()
        dAngVel = self.angularAccel * timeStep

        # After integration over a time step, get a regular rigid body state back
        return RigidBodyState(dPos, dVel, dOrientation, dAngVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar
        angVel = self.angularVelocity * invScalar
        angAccel = self.angularAccel * invScalar

        return RigidBodyStateDerivative(vel, accel, angVel, angAccel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;

        # positionMag = self.position.length() + self.velocity.length()

        orientationMag = self.angularVelocity.angVel() + self.angularAccel.angVel()

        return orientationMag*100

    def __eq__(self, state2):
        try:
            properties = [ self.velocity, self.acceleration, self.angularVelocity, self.angularAccel ]
            otherProperties = [ state2.velocity, state2.acceleration, state2.angularVelocity, state2.angularAccel ]
            return all([ x == y for (x,y) in zip(properties, otherProperties) ])
        except AttributeError:
            return False

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF"><code class="flex name class">
<span>class <span class="ident">RigidBodyStateDerivative_3DoF</span></span>
<span>(</span><span>velocity, acceleration)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyStateDerivative_3DoF():
    def __init__(self, velocity, acceleration):
        self.velocity = velocity
        self.acceleration = acceleration

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.velocity + rigidBodyState2.velocity
        newVel = self.acceleration + rigidBodyState2.acceleration
        
        return RigidBodyStateDerivative_3DoF(newPos, newVel)

    def __mul__(self, timeStep):
        &#39;&#39;&#39; Used in: initVal + timeStep {*} slope &#39;&#39;&#39;
        timeStep = float(timeStep)
        dPos = self.velocity * timeStep
        dVel = self.acceleration * timeStep

        # After multiplying by a timestep, we get a regular (integrated) rigid body state back
        return RigidBodyState_3DoF(dPos, dVel)

    def __truediv__(self, invScalar):
        &#39;&#39;&#39; 
            Used in (k1 + k4) {/} 2 
            Does not &#39;integrate&#39; the result to make a rigidBodyState, returns a new rigidBodyStateDerivative
        &#39;&#39;&#39;
        invScalar = 1/float(invScalar)

        vel = self.velocity * invScalar
        accel = self.acceleration * invScalar

        return RigidBodyStateDerivative_3DoF(vel, accel)

    ### Wrapper/Thin functions ###
    def __rmul__(self, scalar):
        return self * scalar</code></pre>
</details>
</dd>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF"><code class="flex name class">
<span>class <span class="ident">RigidBodyState_3DoF</span></span>
<span>(</span><span>position, velocity)</span>
</code></dt>
<dd>
<div class="desc"><p>Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
Pos/Vel are expected to be Vectors - Defined with reference to the global frame</p>
<p>Adding rigidBodyStates adds the vectors</p>
<p>Multiplying an rigidBodyState by a scalar scales the vectors
0.5 *
= half the vector length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RigidBodyState_3DoF():
    &#34;&#34;&#34; Class created to be able to treat rigidBody states like scalars when integrating the movement of a rigid body
            Pos/Vel are expected to be Vectors - Defined with reference to the global frame

        Adding rigidBodyStates adds the vectors

        Multiplying an rigidBodyState by a scalar scales the vectors
            0.5 *  = half the vector length
    &#34;&#34;&#34;
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity

    def __add__(self, rigidBodyState2):
        &#39;&#39;&#39; Used in: initVal {+} timeStep * slope &#39;&#39;&#39;
        newPos = self.position + rigidBodyState2.position
        newVel = self.velocity + rigidBodyState2.velocity
        
        return RigidBodyState_3DoF(newPos, newVel)

    def __mul__(self, scalar):
        &#39;&#39;&#39; Used to negate the rigid body state for subtractions &#39;&#39;&#39;
        scalar = float(scalar)
        newPos = self.position * scalar
        newVel = self.velocity * scalar

        return RigidBodyState_3DoF(newPos, newVel)

    def __abs__(self):
        &#39;&#39;&#39; Used to quantify the difference between two RigidBodyStates as a scalar value during error estimation in adaptive time stepping methods &#39;&#39;&#39;
        #TODO: Ensure this scales properly with the version in the 6DoF IntegratbleRigidBodyState __abs__ function

        return self.position.length() + self.velocity.length()

    ### String Functions ###
    def getLogHeader(self):
        return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s)&#34;

    def __str__(self):
        &#39;&#39;&#39; Called by print &#39;&#39;&#39;
        return &#34; {:&gt;10.3f} {:&gt;10.4f}&#34;.format(self.position, self.velocity)

    def __neg__(self):
        return self*-1</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF.getLogHeader"><code class="name flex">
<span>def <span class="ident">getLogHeader</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLogHeader(self):
    return &#34; PositionX(m) PositionY(m) PositionZ(m) VelocityX(m/s) VelocityY(m/s) VelocityZ(m/s)&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.Motion" href="index.html">MAPLEAF.Motion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState">RigidBodyState</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState.getLogHeader" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative">RigidBodyStateDerivative</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyStateDerivative_3DoF">RigidBodyStateDerivative_3DoF</a></code></h4>
</li>
<li>
<h4><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF">RigidBodyState_3DoF</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF.getLogHeader" href="#MAPLEAF.Motion.RigidBodyStates.RigidBodyState_3DoF.getLogHeader">getLogHeader</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>