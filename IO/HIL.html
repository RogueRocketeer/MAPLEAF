<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>MAPLEAF.IO.HIL API documentation</title>
<meta name="description" content="Hardware in the loop simulation functionality.
Orientation/Position/Velocity info is passed to a hardware control system, which passes control inputs â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/IO/HIL.html">
<link rel="icon" href="https://pdoc3.github.io/pdoc/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.IO.HIL</code></h1>
</header>
<section id="section-intro">
<p>Hardware in the loop simulation functionality.
Orientation/Position/Velocity info is passed to a hardware control system, which passes control inputs back to the simulator.</p>
<p>Specific implementation - can serve as inspiration, but would have to be modified to work with other avionics systems</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Hardware in the loop simulation functionality.
Orientation/Position/Velocity info is passed to a hardware control system, which passes control inputs back to the simulator.

Specific implementation - can serve as inspiration, but would have to be modified to work with other avionics systems
&#39;&#39;&#39;

import struct
import time

import serial

from MAPLEAF.Motion.CythonQuaternion import Quaternion
from MAPLEAF.Motion.CythonVector import Vector


class packet:

    def __init__(self, address):

        self.PTByte = 0
        self.address = address
        self.data = []
        self.checkSumUpperByte = 0
        self.checkSumLowerByte = 0

    def writeData(self, writtenData):

        for i in range(len(writtenData)):

            self.data.append(writtenData[i])

    def computeCheckSum(self):

        total = ord(&#39;s&#39;) + ord(&#39;n&#39;) + ord(&#39;p&#39;) + self.PTByte + self.address

        for i in range(len(self.data)):

            total += self.data[i]

        decimalRepresentation = (int)(total/1.0)
        binaryRepresentation = decimalRepresentation.to_bytes(2,&#39;big&#39;,signed=False)

        self.checkSumUpperByte = binaryRepresentation[0]
        self.checkSumLowerByte = binaryRepresentation[1]

    def createPTByte(self, hasData, isBatch, numRegisters):

        PTByteValue = 0

        if(hasData == True):

            PTByteValue += 128

        if(isBatch == True):

            PTByteValue += 64

        PTByteValue += numRegisters*4

        self.PTByte = PTByteValue


class HILInterface:

    def __init__(self, quatUpdateRate, posUpdateRate, velUpdateRate, teensyComPort = &#34;Com20&#34;, imuComPort = &#34;Com15&#34;, teensyBaudrate = 9600, imuBaudrate = 57600):

        self.teensyComs = serial.Serial()
        self.teensyComs.port = teensyComPort
        self.teensyComs.baudrate = teensyBaudrate
        self.teensyComs.timeout = 0.001

        self.imuSpoof = serial.Serial()
        self.imuSpoof.port = imuComPort
        self.imuSpoof.baudrate = imuBaudrate
        self.imuSpoof.timeout = 0.001

        self.quatUpdatePeriod = 1 / quatUpdateRate
        self.posUpdatePeriod = 1 / posUpdateRate
        self.velUpdatePeriod = 1 / velUpdateRate


        self.startTime = time.time() #Gives milliseconds
        self.lastUpdateTime = self.startTime
        self.lastQuaternionUpdateTime = self.startTime
        self.lastPositionUpdateTime = self.startTime
        self.lastVelocityUpdateTime = self.startTime

        self.canardAngles = [0]*4

        self.teensyComs.open()
        self.imuSpoof.open()

    def sendTeensyCommands(self,command):

        self.teensyComs.write(command)

    def getCanardAngles(self):
        #for i in range(4):
            #print(self.canardAngles[i])
        return self.canardAngles

    def requestCanardAngles(self):

        self.teensyComs.write(&#39;q&#39;.encode(&#39;UTF-8&#39;))
        time.sleep(0.001)
        for i in range(4):
        
            a = self.teensyComs.readline()
            if a == b&#39;&#39;: #If there was a timeout
                self.canardAngles[i] = self.canardAngles[i] #If there was a timeout just use the alst iterations angle
                print(&#34;Serial Timeout&#34;)
            else:
                self.canardAngles[i] = float(a)

        return self.canardAngles

    def setupHIL(self,currentRigidBodyState):

        self.sendTeensyCommands(&#39;R&#39;.encode(&#39;UTF-8&#39;))

        self.sendIMUData(currentRigidBodyState,10000)

        time.sleep(2)

        self.sendTeensyCommands(&#39;L&#39;.encode(&#39;UTF-8&#39;))

        self.startTime = time.time()
        self.lastUpdateTime = self.startTime #Seconds
        self.lastQuaternionUpdateTime = self.startTime
        self.lastPositionUpdateTime = self.startTime
        self.lastVelocityUpdateTime = self.startTime

        return

    def performHIL(self, currentRigidBodyState, simTime):
        
        #Send IMU data if the update times have passed
        self.sendIMUData(currentRigidBodyState, simTime)
        
        #This is the delay waiting for the real world to catch up with the simulation
        while simTime &gt; (time.time() - self.startTime):
            #print(&#34;Stalling&#34;)
            #print(&#39;{0:.8f}&#39;.format(time.time()-self.lastUpdateTime))
            pass

        #Send IMU data if the update times have passed
        self.requestCanardAngles()

        self.lastUpdateTime = time.time()

    def sendIMUData(self, currentRigidBodyState, simTime):

        #print(&#34;Hello1&#34;)
        #print(simTime)
        #print(self.startTime)
        #print(self.lastQuaternionUpdateTime)
        #print(self.quatUpdatePeriod)

        #If the simulation time is greater than the quat update period
        if((simTime + self.startTime - self.lastQuaternionUpdateTime) &gt; self.quatUpdatePeriod):
            #print(&#34;Hello2&#34;)
            #send quaternion data
            quaternionByteArray = self.getQuaternionByteArray(currentRigidBodyState)

            myPacket = packet(109)
            myPacket.writeData(quaternionByteArray)
            myPacket.createPTByte(True, True, 3)
            self.writePacket(myPacket)
            #print(&#34;Sent&#34;)

            self.lastQuaternionUpdateTime = simTime+self.startTime

        if((simTime + self.startTime - self.lastPositionUpdateTime) &gt; self.posUpdatePeriod):

            #send position data
            positionByteArray = self.getPositionByteArray(currentRigidBodyState)

            myPacket = packet(117)
            myPacket.writeData(positionByteArray)
            myPacket.createPTByte(True, True, 4)

            self.writePacket(myPacket)

            self.lastPositionUpdateTime = simTime+self.startTime

        if((simTime+self.startTime - self.lastVelocityUpdateTime) &gt; self.velUpdatePeriod):

            #send velocity data
            velocityByteArray = self.getVelocityByteArray(currentRigidBodyState)

            myPacket = packet(121)
            myPacket.writeData(velocityByteArray)
            myPacket.createPTByte(True, True, 4)
            self.writePacket(myPacket)

            self.lastVelocityUpdateTime = simTime+self.startTime

        return

    def convertQuaternionComponent(self, quaternionComponent):

        imuDecimalRepresentation = (int)(quaternionComponent*29789.09091)
        imuBinaryRepresentation = imuDecimalRepresentation.to_bytes(2,&#39;big&#39;,signed=True)

        imuUpperByte = imuBinaryRepresentation[0]
        imuLowerByte = imuBinaryRepresentation[1]
        
        return imuUpperByte, imuLowerByte

    def convertPositionComponent(self, positionComponent):

        ba = bytearray(struct.pack(&#34;f&#34;, positionComponent))

        imuMSB = ba[3]
        imu2MSB = ba[2]
        imu2LSB = ba[1]
        imuLSB = ba[0]

        return imuMSB, imu2MSB, imu2LSB, imuLSB

    def convertVelocityComponent(self, velocityComponent):

        ba = bytearray(struct.pack(&#34;f&#34;, velocityComponent))

        imuMSB = ba[3]
        imu2MSB = ba[2]
        imu2LSB = ba[1]
        imuLSB = ba[0]

        return imuMSB, imu2MSB, imu2LSB, imuLSB

    def getQuaternionByteArray(self,currentRigidBodyState):

        convertedQuaternion = self.getConvertedQuaternion(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertQuaternionComponent(convertedQuaternion.Q[0])
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[1]))
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[2]))
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[3]))
        byteArray += ranTuple

        return byteArray

    def getPositionByteArray(self,currentRigidBodyState):

        convertedPosition = self.getConvertedPosition(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertPositionComponent(convertedPosition.X)
        byteArray += self.convertPositionComponent(convertedPosition.Y)
        byteArray += self.convertPositionComponent(convertedPosition.Z)
        byteArray += ranTuple

        return byteArray

    def getVelocityByteArray(self,currentRigidBodyState):

        convertedVelocity = self.getConvertedVelocity(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertVelocityComponent(convertedVelocity.X)
        byteArray += self.convertVelocityComponent(convertedVelocity.Y)
        byteArray += self.convertVelocityComponent(convertedVelocity.Z)
        byteArray += ranTuple

        return byteArray

    def getConvertedQuaternion(self, currentRigidBodyState):

        conversionQuaternion = Quaternion(axisOfRotation=Vector(1,0,0),angle=3.141592654)
        convertedQuaternion = currentRigidBodyState.orientation*conversionQuaternion

        return currentRigidBodyState.orientation

    def getConvertedPosition(self,currentRigidBodyState):

        convertedPosition = Vector(currentRigidBodyState.position.X,currentRigidBodyState.position.Y,-currentRigidBodyState.position.Z)

        return convertedPosition

    def getConvertedVelocity(self,currentRigidBodyState):

        convertedVelocity = Vector(currentRigidBodyState.velocity.X,currentRigidBodyState.velocity.Y,-currentRigidBodyState.velocity.Z)

        return convertedVelocity


    def writePacket(self,myPacket):

        myPacket.computeCheckSum()

        self.imuSpoof.write(&#39;s&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(&#39;n&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(&#39;p&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(bytes([myPacket.PTByte]))
        self.imuSpoof.write(bytes([myPacket.address]))
        self.imuSpoof.write(bytes(myPacket.data))
        self.imuSpoof.write(bytes([myPacket.checkSumUpperByte]))
        self.imuSpoof.write(bytes([myPacket.checkSumLowerByte]))

    def __del__(self):

        self.teensyComs.close()
        self.imuSpoof.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.IO.HIL.HILInterface"><code class="flex name class">
<span>class <span class="ident">HILInterface</span></span>
<span>(</span><span>quatUpdateRate, posUpdateRate, velUpdateRate, teensyComPort='Com20', imuComPort='Com15', teensyBaudrate=9600, imuBaudrate=57600)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HILInterface:

    def __init__(self, quatUpdateRate, posUpdateRate, velUpdateRate, teensyComPort = &#34;Com20&#34;, imuComPort = &#34;Com15&#34;, teensyBaudrate = 9600, imuBaudrate = 57600):

        self.teensyComs = serial.Serial()
        self.teensyComs.port = teensyComPort
        self.teensyComs.baudrate = teensyBaudrate
        self.teensyComs.timeout = 0.001

        self.imuSpoof = serial.Serial()
        self.imuSpoof.port = imuComPort
        self.imuSpoof.baudrate = imuBaudrate
        self.imuSpoof.timeout = 0.001

        self.quatUpdatePeriod = 1 / quatUpdateRate
        self.posUpdatePeriod = 1 / posUpdateRate
        self.velUpdatePeriod = 1 / velUpdateRate


        self.startTime = time.time() #Gives milliseconds
        self.lastUpdateTime = self.startTime
        self.lastQuaternionUpdateTime = self.startTime
        self.lastPositionUpdateTime = self.startTime
        self.lastVelocityUpdateTime = self.startTime

        self.canardAngles = [0]*4

        self.teensyComs.open()
        self.imuSpoof.open()

    def sendTeensyCommands(self,command):

        self.teensyComs.write(command)

    def getCanardAngles(self):
        #for i in range(4):
            #print(self.canardAngles[i])
        return self.canardAngles

    def requestCanardAngles(self):

        self.teensyComs.write(&#39;q&#39;.encode(&#39;UTF-8&#39;))
        time.sleep(0.001)
        for i in range(4):
        
            a = self.teensyComs.readline()
            if a == b&#39;&#39;: #If there was a timeout
                self.canardAngles[i] = self.canardAngles[i] #If there was a timeout just use the alst iterations angle
                print(&#34;Serial Timeout&#34;)
            else:
                self.canardAngles[i] = float(a)

        return self.canardAngles

    def setupHIL(self,currentRigidBodyState):

        self.sendTeensyCommands(&#39;R&#39;.encode(&#39;UTF-8&#39;))

        self.sendIMUData(currentRigidBodyState,10000)

        time.sleep(2)

        self.sendTeensyCommands(&#39;L&#39;.encode(&#39;UTF-8&#39;))

        self.startTime = time.time()
        self.lastUpdateTime = self.startTime #Seconds
        self.lastQuaternionUpdateTime = self.startTime
        self.lastPositionUpdateTime = self.startTime
        self.lastVelocityUpdateTime = self.startTime

        return

    def performHIL(self, currentRigidBodyState, simTime):
        
        #Send IMU data if the update times have passed
        self.sendIMUData(currentRigidBodyState, simTime)
        
        #This is the delay waiting for the real world to catch up with the simulation
        while simTime &gt; (time.time() - self.startTime):
            #print(&#34;Stalling&#34;)
            #print(&#39;{0:.8f}&#39;.format(time.time()-self.lastUpdateTime))
            pass

        #Send IMU data if the update times have passed
        self.requestCanardAngles()

        self.lastUpdateTime = time.time()

    def sendIMUData(self, currentRigidBodyState, simTime):

        #print(&#34;Hello1&#34;)
        #print(simTime)
        #print(self.startTime)
        #print(self.lastQuaternionUpdateTime)
        #print(self.quatUpdatePeriod)

        #If the simulation time is greater than the quat update period
        if((simTime + self.startTime - self.lastQuaternionUpdateTime) &gt; self.quatUpdatePeriod):
            #print(&#34;Hello2&#34;)
            #send quaternion data
            quaternionByteArray = self.getQuaternionByteArray(currentRigidBodyState)

            myPacket = packet(109)
            myPacket.writeData(quaternionByteArray)
            myPacket.createPTByte(True, True, 3)
            self.writePacket(myPacket)
            #print(&#34;Sent&#34;)

            self.lastQuaternionUpdateTime = simTime+self.startTime

        if((simTime + self.startTime - self.lastPositionUpdateTime) &gt; self.posUpdatePeriod):

            #send position data
            positionByteArray = self.getPositionByteArray(currentRigidBodyState)

            myPacket = packet(117)
            myPacket.writeData(positionByteArray)
            myPacket.createPTByte(True, True, 4)

            self.writePacket(myPacket)

            self.lastPositionUpdateTime = simTime+self.startTime

        if((simTime+self.startTime - self.lastVelocityUpdateTime) &gt; self.velUpdatePeriod):

            #send velocity data
            velocityByteArray = self.getVelocityByteArray(currentRigidBodyState)

            myPacket = packet(121)
            myPacket.writeData(velocityByteArray)
            myPacket.createPTByte(True, True, 4)
            self.writePacket(myPacket)

            self.lastVelocityUpdateTime = simTime+self.startTime

        return

    def convertQuaternionComponent(self, quaternionComponent):

        imuDecimalRepresentation = (int)(quaternionComponent*29789.09091)
        imuBinaryRepresentation = imuDecimalRepresentation.to_bytes(2,&#39;big&#39;,signed=True)

        imuUpperByte = imuBinaryRepresentation[0]
        imuLowerByte = imuBinaryRepresentation[1]
        
        return imuUpperByte, imuLowerByte

    def convertPositionComponent(self, positionComponent):

        ba = bytearray(struct.pack(&#34;f&#34;, positionComponent))

        imuMSB = ba[3]
        imu2MSB = ba[2]
        imu2LSB = ba[1]
        imuLSB = ba[0]

        return imuMSB, imu2MSB, imu2LSB, imuLSB

    def convertVelocityComponent(self, velocityComponent):

        ba = bytearray(struct.pack(&#34;f&#34;, velocityComponent))

        imuMSB = ba[3]
        imu2MSB = ba[2]
        imu2LSB = ba[1]
        imuLSB = ba[0]

        return imuMSB, imu2MSB, imu2LSB, imuLSB

    def getQuaternionByteArray(self,currentRigidBodyState):

        convertedQuaternion = self.getConvertedQuaternion(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertQuaternionComponent(convertedQuaternion.Q[0])
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[1]))
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[2]))
        byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[3]))
        byteArray += ranTuple

        return byteArray

    def getPositionByteArray(self,currentRigidBodyState):

        convertedPosition = self.getConvertedPosition(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertPositionComponent(convertedPosition.X)
        byteArray += self.convertPositionComponent(convertedPosition.Y)
        byteArray += self.convertPositionComponent(convertedPosition.Z)
        byteArray += ranTuple

        return byteArray

    def getVelocityByteArray(self,currentRigidBodyState):

        convertedVelocity = self.getConvertedVelocity(currentRigidBodyState)

        random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
        ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

        byteArray = self.convertVelocityComponent(convertedVelocity.X)
        byteArray += self.convertVelocityComponent(convertedVelocity.Y)
        byteArray += self.convertVelocityComponent(convertedVelocity.Z)
        byteArray += ranTuple

        return byteArray

    def getConvertedQuaternion(self, currentRigidBodyState):

        conversionQuaternion = Quaternion(axisOfRotation=Vector(1,0,0),angle=3.141592654)
        convertedQuaternion = currentRigidBodyState.orientation*conversionQuaternion

        return currentRigidBodyState.orientation

    def getConvertedPosition(self,currentRigidBodyState):

        convertedPosition = Vector(currentRigidBodyState.position.X,currentRigidBodyState.position.Y,-currentRigidBodyState.position.Z)

        return convertedPosition

    def getConvertedVelocity(self,currentRigidBodyState):

        convertedVelocity = Vector(currentRigidBodyState.velocity.X,currentRigidBodyState.velocity.Y,-currentRigidBodyState.velocity.Z)

        return convertedVelocity


    def writePacket(self,myPacket):

        myPacket.computeCheckSum()

        self.imuSpoof.write(&#39;s&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(&#39;n&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(&#39;p&#39;.encode(&#39;UTF-8&#39;))
        self.imuSpoof.write(bytes([myPacket.PTByte]))
        self.imuSpoof.write(bytes([myPacket.address]))
        self.imuSpoof.write(bytes(myPacket.data))
        self.imuSpoof.write(bytes([myPacket.checkSumUpperByte]))
        self.imuSpoof.write(bytes([myPacket.checkSumLowerByte]))

    def __del__(self):

        self.teensyComs.close()
        self.imuSpoof.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.HIL.HILInterface.convertPositionComponent"><code class="name flex">
<span>def <span class="ident">convertPositionComponent</span></span>(<span>self, positionComponent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertPositionComponent(self, positionComponent):

    ba = bytearray(struct.pack(&#34;f&#34;, positionComponent))

    imuMSB = ba[3]
    imu2MSB = ba[2]
    imu2LSB = ba[1]
    imuLSB = ba[0]

    return imuMSB, imu2MSB, imu2LSB, imuLSB</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.convertQuaternionComponent"><code class="name flex">
<span>def <span class="ident">convertQuaternionComponent</span></span>(<span>self, quaternionComponent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertQuaternionComponent(self, quaternionComponent):

    imuDecimalRepresentation = (int)(quaternionComponent*29789.09091)
    imuBinaryRepresentation = imuDecimalRepresentation.to_bytes(2,&#39;big&#39;,signed=True)

    imuUpperByte = imuBinaryRepresentation[0]
    imuLowerByte = imuBinaryRepresentation[1]
    
    return imuUpperByte, imuLowerByte</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.convertVelocityComponent"><code class="name flex">
<span>def <span class="ident">convertVelocityComponent</span></span>(<span>self, velocityComponent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertVelocityComponent(self, velocityComponent):

    ba = bytearray(struct.pack(&#34;f&#34;, velocityComponent))

    imuMSB = ba[3]
    imu2MSB = ba[2]
    imu2LSB = ba[1]
    imuLSB = ba[0]

    return imuMSB, imu2MSB, imu2LSB, imuLSB</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getCanardAngles"><code class="name flex">
<span>def <span class="ident">getCanardAngles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCanardAngles(self):
    #for i in range(4):
        #print(self.canardAngles[i])
    return self.canardAngles</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getConvertedPosition"><code class="name flex">
<span>def <span class="ident">getConvertedPosition</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getConvertedPosition(self,currentRigidBodyState):

    convertedPosition = Vector(currentRigidBodyState.position.X,currentRigidBodyState.position.Y,-currentRigidBodyState.position.Z)

    return convertedPosition</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getConvertedQuaternion"><code class="name flex">
<span>def <span class="ident">getConvertedQuaternion</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getConvertedQuaternion(self, currentRigidBodyState):

    conversionQuaternion = Quaternion(axisOfRotation=Vector(1,0,0),angle=3.141592654)
    convertedQuaternion = currentRigidBodyState.orientation*conversionQuaternion

    return currentRigidBodyState.orientation</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getConvertedVelocity"><code class="name flex">
<span>def <span class="ident">getConvertedVelocity</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getConvertedVelocity(self,currentRigidBodyState):

    convertedVelocity = Vector(currentRigidBodyState.velocity.X,currentRigidBodyState.velocity.Y,-currentRigidBodyState.velocity.Z)

    return convertedVelocity</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getPositionByteArray"><code class="name flex">
<span>def <span class="ident">getPositionByteArray</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPositionByteArray(self,currentRigidBodyState):

    convertedPosition = self.getConvertedPosition(currentRigidBodyState)

    random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
    ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

    byteArray = self.convertPositionComponent(convertedPosition.X)
    byteArray += self.convertPositionComponent(convertedPosition.Y)
    byteArray += self.convertPositionComponent(convertedPosition.Z)
    byteArray += ranTuple

    return byteArray</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getQuaternionByteArray"><code class="name flex">
<span>def <span class="ident">getQuaternionByteArray</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getQuaternionByteArray(self,currentRigidBodyState):

    convertedQuaternion = self.getConvertedQuaternion(currentRigidBodyState)

    random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
    ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

    byteArray = self.convertQuaternionComponent(convertedQuaternion.Q[0])
    byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[1]))
    byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[2]))
    byteArray += (self.convertQuaternionComponent(convertedQuaternion.Q[3]))
    byteArray += ranTuple

    return byteArray</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.getVelocityByteArray"><code class="name flex">
<span>def <span class="ident">getVelocityByteArray</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVelocityByteArray(self,currentRigidBodyState):

    convertedVelocity = self.getConvertedVelocity(currentRigidBodyState)

    random32BitTimeSpoof = (1).to_bytes(4,&#39;big&#39;,signed=True)
    ranTuple = (random32BitTimeSpoof[0], random32BitTimeSpoof[1], random32BitTimeSpoof[2], random32BitTimeSpoof[3])

    byteArray = self.convertVelocityComponent(convertedVelocity.X)
    byteArray += self.convertVelocityComponent(convertedVelocity.Y)
    byteArray += self.convertVelocityComponent(convertedVelocity.Z)
    byteArray += ranTuple

    return byteArray</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.performHIL"><code class="name flex">
<span>def <span class="ident">performHIL</span></span>(<span>self, currentRigidBodyState, simTime)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performHIL(self, currentRigidBodyState, simTime):
    
    #Send IMU data if the update times have passed
    self.sendIMUData(currentRigidBodyState, simTime)
    
    #This is the delay waiting for the real world to catch up with the simulation
    while simTime &gt; (time.time() - self.startTime):
        #print(&#34;Stalling&#34;)
        #print(&#39;{0:.8f}&#39;.format(time.time()-self.lastUpdateTime))
        pass

    #Send IMU data if the update times have passed
    self.requestCanardAngles()

    self.lastUpdateTime = time.time()</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.requestCanardAngles"><code class="name flex">
<span>def <span class="ident">requestCanardAngles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requestCanardAngles(self):

    self.teensyComs.write(&#39;q&#39;.encode(&#39;UTF-8&#39;))
    time.sleep(0.001)
    for i in range(4):
    
        a = self.teensyComs.readline()
        if a == b&#39;&#39;: #If there was a timeout
            self.canardAngles[i] = self.canardAngles[i] #If there was a timeout just use the alst iterations angle
            print(&#34;Serial Timeout&#34;)
        else:
            self.canardAngles[i] = float(a)

    return self.canardAngles</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.sendIMUData"><code class="name flex">
<span>def <span class="ident">sendIMUData</span></span>(<span>self, currentRigidBodyState, simTime)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendIMUData(self, currentRigidBodyState, simTime):

    #print(&#34;Hello1&#34;)
    #print(simTime)
    #print(self.startTime)
    #print(self.lastQuaternionUpdateTime)
    #print(self.quatUpdatePeriod)

    #If the simulation time is greater than the quat update period
    if((simTime + self.startTime - self.lastQuaternionUpdateTime) &gt; self.quatUpdatePeriod):
        #print(&#34;Hello2&#34;)
        #send quaternion data
        quaternionByteArray = self.getQuaternionByteArray(currentRigidBodyState)

        myPacket = packet(109)
        myPacket.writeData(quaternionByteArray)
        myPacket.createPTByte(True, True, 3)
        self.writePacket(myPacket)
        #print(&#34;Sent&#34;)

        self.lastQuaternionUpdateTime = simTime+self.startTime

    if((simTime + self.startTime - self.lastPositionUpdateTime) &gt; self.posUpdatePeriod):

        #send position data
        positionByteArray = self.getPositionByteArray(currentRigidBodyState)

        myPacket = packet(117)
        myPacket.writeData(positionByteArray)
        myPacket.createPTByte(True, True, 4)

        self.writePacket(myPacket)

        self.lastPositionUpdateTime = simTime+self.startTime

    if((simTime+self.startTime - self.lastVelocityUpdateTime) &gt; self.velUpdatePeriod):

        #send velocity data
        velocityByteArray = self.getVelocityByteArray(currentRigidBodyState)

        myPacket = packet(121)
        myPacket.writeData(velocityByteArray)
        myPacket.createPTByte(True, True, 4)
        self.writePacket(myPacket)

        self.lastVelocityUpdateTime = simTime+self.startTime

    return</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.sendTeensyCommands"><code class="name flex">
<span>def <span class="ident">sendTeensyCommands</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sendTeensyCommands(self,command):

    self.teensyComs.write(command)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.setupHIL"><code class="name flex">
<span>def <span class="ident">setupHIL</span></span>(<span>self, currentRigidBodyState)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setupHIL(self,currentRigidBodyState):

    self.sendTeensyCommands(&#39;R&#39;.encode(&#39;UTF-8&#39;))

    self.sendIMUData(currentRigidBodyState,10000)

    time.sleep(2)

    self.sendTeensyCommands(&#39;L&#39;.encode(&#39;UTF-8&#39;))

    self.startTime = time.time()
    self.lastUpdateTime = self.startTime #Seconds
    self.lastQuaternionUpdateTime = self.startTime
    self.lastPositionUpdateTime = self.startTime
    self.lastVelocityUpdateTime = self.startTime

    return</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.HILInterface.writePacket"><code class="name flex">
<span>def <span class="ident">writePacket</span></span>(<span>self, myPacket)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writePacket(self,myPacket):

    myPacket.computeCheckSum()

    self.imuSpoof.write(&#39;s&#39;.encode(&#39;UTF-8&#39;))
    self.imuSpoof.write(&#39;n&#39;.encode(&#39;UTF-8&#39;))
    self.imuSpoof.write(&#39;p&#39;.encode(&#39;UTF-8&#39;))
    self.imuSpoof.write(bytes([myPacket.PTByte]))
    self.imuSpoof.write(bytes([myPacket.address]))
    self.imuSpoof.write(bytes(myPacket.data))
    self.imuSpoof.write(bytes([myPacket.checkSumUpperByte]))
    self.imuSpoof.write(bytes([myPacket.checkSumLowerByte]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.IO.HIL.packet"><code class="flex name class">
<span>class <span class="ident">packet</span></span>
<span>(</span><span>address)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class packet:

    def __init__(self, address):

        self.PTByte = 0
        self.address = address
        self.data = []
        self.checkSumUpperByte = 0
        self.checkSumLowerByte = 0

    def writeData(self, writtenData):

        for i in range(len(writtenData)):

            self.data.append(writtenData[i])

    def computeCheckSum(self):

        total = ord(&#39;s&#39;) + ord(&#39;n&#39;) + ord(&#39;p&#39;) + self.PTByte + self.address

        for i in range(len(self.data)):

            total += self.data[i]

        decimalRepresentation = (int)(total/1.0)
        binaryRepresentation = decimalRepresentation.to_bytes(2,&#39;big&#39;,signed=False)

        self.checkSumUpperByte = binaryRepresentation[0]
        self.checkSumLowerByte = binaryRepresentation[1]

    def createPTByte(self, hasData, isBatch, numRegisters):

        PTByteValue = 0

        if(hasData == True):

            PTByteValue += 128

        if(isBatch == True):

            PTByteValue += 64

        PTByteValue += numRegisters*4

        self.PTByte = PTByteValue</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.HIL.packet.computeCheckSum"><code class="name flex">
<span>def <span class="ident">computeCheckSum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeCheckSum(self):

    total = ord(&#39;s&#39;) + ord(&#39;n&#39;) + ord(&#39;p&#39;) + self.PTByte + self.address

    for i in range(len(self.data)):

        total += self.data[i]

    decimalRepresentation = (int)(total/1.0)
    binaryRepresentation = decimalRepresentation.to_bytes(2,&#39;big&#39;,signed=False)

    self.checkSumUpperByte = binaryRepresentation[0]
    self.checkSumLowerByte = binaryRepresentation[1]</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.packet.createPTByte"><code class="name flex">
<span>def <span class="ident">createPTByte</span></span>(<span>self, hasData, isBatch, numRegisters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createPTByte(self, hasData, isBatch, numRegisters):

    PTByteValue = 0

    if(hasData == True):

        PTByteValue += 128

    if(isBatch == True):

        PTByteValue += 64

    PTByteValue += numRegisters*4

    self.PTByte = PTByteValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.HIL.packet.writeData"><code class="name flex">
<span>def <span class="ident">writeData</span></span>(<span>self, writtenData)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeData(self, writtenData):

    for i in range(len(writtenData)):

        self.data.append(writtenData[i])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/DraftLogo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.IO" href="index.html">MAPLEAF.IO</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.IO.HIL.HILInterface" href="#MAPLEAF.IO.HIL.HILInterface">HILInterface</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.convertPositionComponent" href="#MAPLEAF.IO.HIL.HILInterface.convertPositionComponent">convertPositionComponent</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.convertQuaternionComponent" href="#MAPLEAF.IO.HIL.HILInterface.convertQuaternionComponent">convertQuaternionComponent</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.convertVelocityComponent" href="#MAPLEAF.IO.HIL.HILInterface.convertVelocityComponent">convertVelocityComponent</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getCanardAngles" href="#MAPLEAF.IO.HIL.HILInterface.getCanardAngles">getCanardAngles</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getConvertedPosition" href="#MAPLEAF.IO.HIL.HILInterface.getConvertedPosition">getConvertedPosition</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getConvertedQuaternion" href="#MAPLEAF.IO.HIL.HILInterface.getConvertedQuaternion">getConvertedQuaternion</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getConvertedVelocity" href="#MAPLEAF.IO.HIL.HILInterface.getConvertedVelocity">getConvertedVelocity</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getPositionByteArray" href="#MAPLEAF.IO.HIL.HILInterface.getPositionByteArray">getPositionByteArray</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getQuaternionByteArray" href="#MAPLEAF.IO.HIL.HILInterface.getQuaternionByteArray">getQuaternionByteArray</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.getVelocityByteArray" href="#MAPLEAF.IO.HIL.HILInterface.getVelocityByteArray">getVelocityByteArray</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.performHIL" href="#MAPLEAF.IO.HIL.HILInterface.performHIL">performHIL</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.requestCanardAngles" href="#MAPLEAF.IO.HIL.HILInterface.requestCanardAngles">requestCanardAngles</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.sendIMUData" href="#MAPLEAF.IO.HIL.HILInterface.sendIMUData">sendIMUData</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.sendTeensyCommands" href="#MAPLEAF.IO.HIL.HILInterface.sendTeensyCommands">sendTeensyCommands</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.setupHIL" href="#MAPLEAF.IO.HIL.HILInterface.setupHIL">setupHIL</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.HILInterface.writePacket" href="#MAPLEAF.IO.HIL.HILInterface.writePacket">writePacket</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.IO.HIL.packet" href="#MAPLEAF.IO.HIL.packet">packet</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.HIL.packet.computeCheckSum" href="#MAPLEAF.IO.HIL.packet.computeCheckSum">computeCheckSum</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.packet.createPTByte" href="#MAPLEAF.IO.HIL.packet.createPTByte">createPTByte</a></code></li>
<li><code><a title="MAPLEAF.IO.HIL.packet.writeData" href="#MAPLEAF.IO.HIL.packet.writeData">writeData</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>