<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>MAPLEAF.IO API documentation</title>
<meta name="description" content="Input/Output functionality: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/IO/">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.IO</code></h1>
</header>
<section id="section-intro">
<p>Input/Output functionality:</p>
<ul>
<li>Reading/Writing Simulation Definition Files</li>
<li>Plotting/Logging results</li>
</ul>
<p>MAPLEAF.IO Relies on MAPLEAF.Motion to implement a few convenience / parsing functions.</p>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Laptop-hard-drive-exposed.jpg/1280px-Laptop-hard-drive-exposed.jpg"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Input/Output functionality:

* Reading/Writing Simulation Definition Files
* Plotting/Logging results

MAPLEAF.IO Relies on MAPLEAF.Motion to implement a few convenience / parsing functions.

.. image:: https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Laptop-hard-drive-exposed.jpg/1280px-Laptop-hard-drive-exposed.jpg
&#39;&#39;&#39;
# Make the classes in all submodules importable directly from MAPLEAF.Rocket
from .rocketFlight import *
from .simDefinition import *
from .subDictReader import *

subModules = [ rocketFlight, simDefinition, subDictReader ]

__all__ = []

for subModule in subModules:
    __all__ += subModule.__all__</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="MAPLEAF.IO.HIL" href="HIL.html">MAPLEAF.IO.HIL</a></code></dt>
<dd>
<div class="desc"><p>Hardware in the loop simulation functionality.
Orientation/Position/Velocity info is passed to a hardware control system, which passes control inputs …</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.Logging" href="Logging.html">MAPLEAF.IO.Logging</a></code></dt>
<dd>
<div class="desc"><p>Classes and functions for creating simulation logs for regular simulations (Logger) and Monte Carlo simulations (MonteCarloLogger)</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.Plotting" href="Plotting.html">MAPLEAF.IO.Plotting</a></code></dt>
<dd>
<div class="desc"><p>Functions to create plots and animations of simulations results.</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.gridConvergenceFunctions" href="gridConvergenceFunctions.html">MAPLEAF.IO.gridConvergenceFunctions</a></code></dt>
<dd>
<div class="desc"><p>Functions to analyze grid convergence of simulations</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.rocketFlight" href="rocketFlight.html">MAPLEAF.IO.rocketFlight</a></code></dt>
<dd>
<div class="desc"><p>Temporarily holds simulation results.
Used for creating flight animations.</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.simDefinition" href="simDefinition.html">MAPLEAF.IO.simDefinition</a></code></dt>
<dd>
<div class="desc"><p>Contains a class to read, write and modify simulation definition (.mapleaf) files, the master dictionary of
default values for simulation …</p></div>
</dd>
<dt><code class="name"><a title="MAPLEAF.IO.subDictReader" href="subDictReader.html">MAPLEAF.IO.subDictReader</a></code></dt>
<dd>
<div class="desc"><p>Wrapper class to read from a specific sub-dictionary in a SimDefinition.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.IO.getAbsoluteFilePath"><code class="name flex">
<span>def <span class="ident">getAbsoluteFilePath</span></span>(<span>relativePath: str, alternateRelativeLocation: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a path defined relative to the MAPLEAF repository and tries to return an absolute path for the current installation.
alternateRelativeLocation (str) location of an alternate file/folder the path could be relative to
Returns original relativePath if an absolute path is not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAbsoluteFilePath(relativePath: str, alternateRelativeLocation: str = &#34;&#34;) -&gt; str:
    &#39;&#39;&#39; 
        Takes a path defined relative to the MAPLEAF repository and tries to return an absolute path for the current installation.
        alternateRelativeLocation (str) location of an alternate file/folder the path could be relative to
        Returns original relativePath if an absolute path is not found
    &#39;&#39;&#39;
    # Check if path is relative to MAPLEAF installation location
    # This file is at MAPLEAF/IO/SimDefinition, so MAPLEAF&#39;s install directory is three levels up
    pathToMAPLEAFInstallation = Path(__file__).parent.parent.parent

    relativePath = Path(relativePath)
    absolutePath = pathToMAPLEAFInstallation / relativePath

    if absolutePath.exists():
        return str(absolutePath)
    else:
        if alternateRelativeLocation != &#34;&#34;:
            # Try alternate location
            alternateLocation = Path(alternateRelativeLocation)
            
            if alternateLocation.is_file():
                # If the alternate location provided is a file path, check if the file is in the parent directory
                absolutePath = alternateLocation.parent / relativePath
            else:
                absolutePath = alternateLocation / relativePath

            if absolutePath.exists():
                return str(absolutePath)
                
    print(&#34;WARNING: Unable to compute absolute path replacement for a path which is suspected to be relative to the MAPLEAF installation location: {}&#34;.format(relativePath))
    return relativePath</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.IO.RocketFlight"><code class="flex name class">
<span>class <span class="ident">RocketFlight</span></span>
</code></dt>
<dd>
<div class="desc"><p>Holds simulation results </p>
<p>These arrays are filled in during a flight simulation. If the rocket is not controlled, self.actuatorDefls will be set to None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RocketFlight():
    &#39;&#39;&#39; Holds simulation results &#39;&#39;&#39;

    def __init__(self):
        &#39;&#39;&#39;  These arrays are filled in during a flight simulation. If the rocket is not controlled, self.actuatorDefls will be set to None &#39;&#39;&#39;
        self.times = []
        self.rigidBodyStates = []
        self.actuatorDefls = []
        self.actuatorTargetDefls = []

        # To be filled during flight
        self.engineOffTime = None
        self.mainChuteDeployTime = None
        self.targetLocation = None

    def getFlightTime(self):
        return self.times[-1]

    def getApogee(self):
        maxAltitude = -10000000
        for state in self.rigidBodyStates:
            if state.position.Z &gt; maxAltitude:
                maxAltitude = state.position.Z
        return maxAltitude

    def getMaxSpeed(self):
        maxVel = 0
        for state in self.rigidBodyStates:
            if state.velocity.length() &gt; maxVel:
                maxVel = state.velocity.length()
        return maxVel

    def getMaxHorizontalVel(self):
        maxHorizontalVel = 0
        for state in self.rigidBodyStates:
            horizVel = sqrt(state.velocity.X**2 + state.velocity.Y**2)
            if horizVel &gt; maxHorizontalVel:
                maxHorizontalVel = horizVel
        return maxHorizontalVel

    def getLandingLocation(self):
        &#39;&#39;&#39;
            Extrapolates to z = 0
            If the simulation stopped before z = 0 is reached, the last position is returned
        &#39;&#39;&#39;

        #TODO: Handle non-flat surface to land on
        secondLastPosition = self.rigidBodyStates[-2].position
        lastPosition = self.rigidBodyStates[-1].position

        dz = lastPosition.Z - secondLastPosition.Z

        if lastPosition.Z &gt; dz*2:
            dxdz = (lastPosition.X - secondLastPosition.X) / dz
            dydz = (lastPosition.Y - secondLastPosition.Y) / dz

            dzLand = -lastPosition.Z 

            xLand = lastPosition.X + dxdz*dzLand
            yLand = lastPosition.Y + dydz*dzLand
            zLand = 0.0
            
            return Vector(xLand, yLand, zLand)
        else:
            return lastPosition</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.RocketFlight.getApogee"><code class="name flex">
<span>def <span class="ident">getApogee</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getApogee(self):
    maxAltitude = -10000000
    for state in self.rigidBodyStates:
        if state.position.Z &gt; maxAltitude:
            maxAltitude = state.position.Z
    return maxAltitude</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.RocketFlight.getFlightTime"><code class="name flex">
<span>def <span class="ident">getFlightTime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFlightTime(self):
    return self.times[-1]</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.RocketFlight.getLandingLocation"><code class="name flex">
<span>def <span class="ident">getLandingLocation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolates to z = 0
If the simulation stopped before z = 0 is reached, the last position is returned</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getLandingLocation(self):
    &#39;&#39;&#39;
        Extrapolates to z = 0
        If the simulation stopped before z = 0 is reached, the last position is returned
    &#39;&#39;&#39;

    #TODO: Handle non-flat surface to land on
    secondLastPosition = self.rigidBodyStates[-2].position
    lastPosition = self.rigidBodyStates[-1].position

    dz = lastPosition.Z - secondLastPosition.Z

    if lastPosition.Z &gt; dz*2:
        dxdz = (lastPosition.X - secondLastPosition.X) / dz
        dydz = (lastPosition.Y - secondLastPosition.Y) / dz

        dzLand = -lastPosition.Z 

        xLand = lastPosition.X + dxdz*dzLand
        yLand = lastPosition.Y + dydz*dzLand
        zLand = 0.0
        
        return Vector(xLand, yLand, zLand)
    else:
        return lastPosition</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.RocketFlight.getMaxHorizontalVel"><code class="name flex">
<span>def <span class="ident">getMaxHorizontalVel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaxHorizontalVel(self):
    maxHorizontalVel = 0
    for state in self.rigidBodyStates:
        horizVel = sqrt(state.velocity.X**2 + state.velocity.Y**2)
        if horizVel &gt; maxHorizontalVel:
            maxHorizontalVel = horizVel
    return maxHorizontalVel</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.RocketFlight.getMaxSpeed"><code class="name flex">
<span>def <span class="ident">getMaxSpeed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMaxSpeed(self):
    maxVel = 0
    for state in self.rigidBodyStates:
        if state.velocity.length() &gt; maxVel:
            maxVel = state.velocity.length()
    return maxVel</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.IO.SimDefinition"><code class="flex name class">
<span>class <span class="ident">SimDefinition</span></span>
<span>(</span><span>fileName=None, dictionary=None, disableDistributionSampling=False, silent=False, defaultDict=None, simDefParseStack=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse simulation definition files into a dictionary of string values accessible by string keys.</p>
<h2 id="inputs">Inputs</h2>
<ul>
<li>fileName: (str) path to simulation definition file</li>
<li>
<p>dictionary: (dict[str,str]) Provide a pre-parsed dictionary equivalent to a simulation definition file - OVERRIDES fileName</p>
</li>
<li>
<p>disableDistributionSampling: (bool) Turn Monte Carlo sampling of normally-distributed parameters on/off</p>
</li>
<li>silent: (bool) Console output control</li>
<li>defaultDict: (dict[str,str] provide a custom dictionary of default values. If none is provided, defaultConfigValues is used.)</li>
<li>simDefParseStack: set(str) list of sim definition files in the current parse stack. Will throw an error if any of these files need to be loaded to generate the current sim definition
# !include and !create [] from [] statements must form an acyclic graph of files to load (no circular loads)</li>
</ul>
<h2 id="example">Example</h2>
<p>The file contents:<br>
'SimControl{<br>
&nbsp;&nbsp;&nbsp;&nbsp;timeDiscretization RK4;<br>
}'<br>
Would be parsed into a single-key Python dictionary, stored in self.dict:<br>
<code>{ "SimControl.timeDiscretization": "RK4"}</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimDefinition():

    #### Parsing / Initialization ####
    def __init__(self, fileName=None, dictionary=None, disableDistributionSampling=False, silent=False, defaultDict=None, simDefParseStack=None):
        &#39;&#39;&#39;
        Parse simulation definition files into a dictionary of string values accessible by string keys.

        Inputs:
            * fileName: (str) path to simulation definition file
            * dictionary: (dict[str,str]) Provide a pre-parsed dictionary equivalent to a simulation definition file - OVERRIDES fileName
            
            * disableDistributionSampling: (bool) Turn Monte Carlo sampling of normally-distributed parameters on/off
            * silent: (bool) Console output control
            * defaultDict: (dict[str,str] provide a custom dictionary of default values. If none is provided, defaultConfigValues is used.)
            * simDefParseStack: set(str) list of sim definition files in the current parse stack. Will throw an error if any of these files need to be loaded to generate the current sim definition
                # !include and !create [] from [] statements must form an acyclic graph of files to load (no circular loads)
        
        Example:
            The file contents:  
                &#39;SimControl{  
                    &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;timeDiscretization RK4;  
                }&#39;  
            Would be parsed into a single-key Python dictionary, stored in self.dict:  
            `{ &#34;SimControl.timeDiscretization&#34;: &#34;RK4&#34;}`
        
        &#39;&#39;&#39;
        self.silent = silent
        &#39;&#39;&#39; Boolean, controls console output &#39;&#39;&#39;

        self.fileName = fileName

        self.disableDistributionSampling = disableDistributionSampling
        &#39;&#39;&#39; Boolean - controls whether parameters which have standard deviations specified are actually sampled from a normal distribution. If True, the mean value is always returned. Chief use case for disabling sampling: Checking simulation convergence as the time step / target error is decreased. &#39;&#39;&#39;

        self.defaultDict = defaultConfigValues if (defaultDict == None) else defaultDict
        &#39;&#39;&#39; Holds all of the defined default values. These will fill in for missing values in self.dict. Unless a different dictionary is specified, will hold a reference to `defaultConfigValues` &#39;&#39;&#39;
        
        self.monteCarloLogger = None 
        &#39;&#39;&#39; Filled in by  Main.runMonteCarloSimulation() if running  Monte Carlo simulation. Type: `MAPLEAF.IO.Logging.MonteCarloLogger` &#39;&#39;&#39;

        self.dict = None # type: Dict[str:str]
        &#39;&#39;&#39; Main dictionary of values, usually populated from a simulation definition file &#39;&#39;&#39;

        self.simDefParseStack = { self.fileName } if (simDefParseStack == None) else simDefParseStack
        &#39;&#39;&#39; Keeps track of which files have already been loaded in the current parse stack. If these are loaded again we&#39;re in a parsing loop &#39;&#39;&#39;

        # Parse/Assign main values dictionary
        if dictionary != None:
            self.dict = dictionary
        elif fileName != None:
            self.dict = self._parseSimDefinitionFile(fileName)
        else:
            raise ValueError(&#34;No fileName or dictionary provided to initialize the SimDefinition&#34;)

        # Initialize tracking of default values used and unaccessed keys
        self._resetUsageTrackers()

        # Check if any probabilistic keys exist
        containsProbabilisticValues = False
        for key in self.dict:
            if &#34;_stdDev&#34; == key[-7:]:
                containsProbabilisticValues = True

        # Initialize instance of random.Random for Monte Carlo sampling
        if not disableDistributionSampling:
            try:
                randomSeed = self.getValue(&#34;MonteCarlo.randomSeed&#34;)
            except KeyError:
                randomSeed = random.randrange(1000000)
            
            if not silent and containsProbabilisticValues:
                print(&#34;Monte Carlo random seed: {}&#34;.format(randomSeed))
                
            self.rng = random.Random(randomSeed)
            &#39;&#39;&#39; Instace of random.Random owned by this instance of SimDefinition. Random seed can be specified by the MonteCarlo.randomSeed parameter. Used for sampling all normal distributions for parameters that have std dev specified. &#39;&#39;&#39;

    def _loadSubSimDefinition(self, path: str):
        &#39;&#39;&#39; 
            In the parsing process, may need to load other sim definition files, use this function when doing that to detect circular references 
            path can be relative to the location of the current file, absolute, or relative to the MAPLEAF install directory
            
            Throws ValueError if circular parsing detected.
            Returns a new SimDefinition object
        &#39;&#39;&#39;
        filePath = getAbsoluteFilePath(path, str( Path(self.fileName).parent ))

        if filePath not in self.simDefParseStack:
            self.simDefParseStack.add(filePath)
            subSimDef = SimDefinition(filePath, simDefParseStack=self.simDefParseStack)
            self.simDefParseStack.remove(filePath)
            return subSimDef
        
        else:
            raise ValueError(&#34;Encountered circular reference while trying to parse SimDefinition file: {}, which references: {}, which is already in the current parse stack: {}&#34;.format(self.fileName, filePath, self.simDefParseStack))

    def _parseDictionaryContents(self, Dict, workingText, startLine: int, currDictName: str, allowKeyOverwriting=False) -&gt; int:
        &#39;&#39;&#39; 
            Parses an individual subdictionary in a simdefinition file.
            Calls itself recursively to parse further sub dictionaries.
            Saves parsed key-value pairs to Dict

            workingText should be of type list[str]

            Returns index of next line to parse
        &#39;&#39;&#39;
        i = startLine

        while i &lt; len(workingText):
            line = workingText[i].strip()
            splitLine = line.split()
            
            if splitLine[0] == &#34;!create&#34;:
                # Parse derived subdictionary
                i = self._parseDerivedDictionary(Dict, workingText, i, currDictName)

            elif splitLine[0] == &#34;!include&#34;:
                # Include contents of another sim definition file
                filePath = line[line.index(&#34; &#34;):].strip() # Handle file names with spaces
                subDef = self._loadSubSimDefinition(filePath)

                # Add keys to current sim definition, inside current dictionary
                for subDefkey in subDef.dict:
                    if currDictName == &#34;&#34;:
                        key = subDefkey
                    else:
                        key = currDictName + &#34;.&#34; + subDefkey

                    Dict[key] = subDef.dict[subDefkey]

            elif line[-1] == &#39;{&#39;:
                # Parse regular Subdictionary
                subDictName = line[:-1] # Remove whitespace and dict start bracket
                
                # Recursive call to parse subdictionary
                if currDictName == &#34;&#34;:
                    i = self._parseDictionaryContents(Dict, workingText, i+1, subDictName, allowKeyOverwriting)
                else:
                    i = self._parseDictionaryContents(Dict, workingText, i+1, currDictName + &#34;.&#34; + subDictName, allowKeyOverwriting)

            elif line == &#39;}&#39;:
                #End current dictionary - continue parsing at next line
                return i
                        
            elif len(splitLine) &gt; 1:
                # Save a space-separated key-value pair
                key = splitLine[0]
                value = &#34; &#34;.join(splitLine[1:])
                if currDictName == &#34;&#34;:
                    keyString = key
                else:
                    keyString = currDictName + &#34;.&#34; + key

                if not keyString in Dict or allowKeyOverwriting:
                    Dict[keyString] = value
                else:
                    raise ValueError(&#34;Duplicate Key: &#34; + keyString + &#34; in File: &#34; + self.fileName)
            
            else:
                # Error: Line not recognized as a dict start/end or a key/value pair
                print(simDefinitionHelpMessage)
                raise ValueError(&#34;Problem parsing line {}: {}&#34;.format(i, line))

            # Next line
            i += 1

    def _parseDerivedDictionary(self, Dict, workingText, initializationLine: int, currDictName: str) -&gt; int:
        &#39;&#39;&#39;
            Parse a &#39;derived&#39; subdictionary, defined with the !create command in .mapleaf files

            Inputs:
                workingText: (list[str]) lines of text in .mapleaf file
                initializationLine: (int) index of line defining the derived dictionary to be parsed in workingText
                currDictName: (str) name of the dictionary containing the derived dictionary to be parsed. &#34;&#34; if at root level

            Returns:
                (int): index of the last line in the derived subdictionary
        &#39;&#39;&#39;
        # workingText[initializationLine] should be something like:
            # &#39;    !create SubDictionary2 from Dictionary1.SubDictionary1{&#39;
        definitionLine = shlex.split(workingText[initializationLine])

        # Figure out complete name of new dictionary
        if currDictName == &#39;&#39;:
            derivedDictName = definitionLine[1]
        else:
            derivedDictName = currDictName + &#39;.&#39; + definitionLine[1]

        # Parent dict is last command. Remove opening curly bracket (last character), if present
        dictPath = definitionLine[-1][:-1] if (&#39;{&#39; == definitionLine[-1][-1]) else definitionLine[-1]

        #### Load Parent/Source (Sub)Dictionary ####
        if &#34;:&#34; in dictPath:
            # Importing dictionary from another file
            fileName = dictPath.split(&#34;:&#34;)[0]              
            subSimDef = self._loadSubSimDefinition(fileName)
            sourceDict = subSimDef.dict
            
            dictPath = dictPath.split(&#34;:&#34;)[1]
            keysInParentDict = subSimDef.getSubKeys(dictPath)                
        
        else:
            # Deriving from dictionary in current file
            # Get keys from parent dict
            keysInParentDict = self.getSubKeys(dictPath, Dict)
            sourceDict = Dict
        
        if len(keysInParentDict) == 0:
            raise ValueError(&#34;ERROR: Dictionary to derive from: {} is not defined before {} in {}.&#34;.format(dictPath, derivedDictName, self.fileName))
        
        # Fill out temporary dict, after applying all modifiers, add values to main Dict
        derivedDict = {}

        # Rename all the keys in the parentDict -&gt; relocate them to the new (sub)dictionary
        for parentKey in keysInParentDict:
            key = parentKey.replace(dictPath, derivedDictName)
            derivedDict[key] = sourceDict[parentKey]


        #### Apply additional commands ####
        i = initializationLine + 1
        while i &lt; len(workingText):
            line = workingText[i]
            command = shlex.split(line)

            def removeQuotes(string):
                string = string.replace(&#34;&#39;&#34;, &#34;&#34;)
                return string.replace(&#39;&#34;&#39;, &#34;&#34;)

            if command[0] == &#34;!replace&#34;:
                # Get string to replace and its replacement
                toReplace = removeQuotes(command[1])
                replaceWith = removeQuotes(command[-1])

                derivedDictAfterReplace = {}
                for key in derivedDict:
                    newKey = key.replace(toReplace, replaceWith)
                    # .pop() gets the old value and also deletes it from the dictionary
                    newValue = derivedDict[key].replace(toReplace, replaceWith)
                    derivedDictAfterReplace[newKey] = newValue

                derivedDict = derivedDictAfterReplace

            elif command[0] == &#34;!removeKeysContaining&#34;:
                stringToDelete = command[1]

                # Search for and remove any keys that contain stringToDelete
                keysToDelete = []
                for key in derivedDict:
                    if stringToDelete in key:
                        keysToDelete.append(key)

                for key in keysToDelete:
                    del derivedDict[key]                

            elif line[0] != &#34;!&#34;:
                break # Done special commands - let the regular parser handle the rest

            else:
                raise ValueError(&#34;Command: {} not implemented. Try using !replace or !removeKeysContaining&#34;.format(line.split()[0]))

            i += 1

        #### Add derivedDict values to Dict ####
        for key in derivedDict:
            # Make sure we don&#39;t clobber existing values with poorly thought-out replace commands
            if key not in Dict:
                Dict[key] = derivedDict[key]
            else:
                raise ValueError(&#34;Derived dict key {} already exists&#34;.format(key, self.fileName))

        #### Parse any regular values in derived dict ####
        return self._parseDictionaryContents(Dict, workingText, i, derivedDictName, allowKeyOverwriting=True)

    def _replaceMAPLEAFRelativeFilePathsWithAbsolutePaths(self, Dict):
        &#39;&#39;&#39; 
            Tries to detect paths relative to the MAPLEAF installation directory and replaces them with absolute paths.
            This allows MAPLEAF to work when installed from pip and being run outside its installation directory.
        &#39;&#39;&#39;
        for key in Dict:
            # Iterate over all keys, looking for file path relative to the MAPLEAF repo
            val = Dict[key]
            
            # Remove leading dot/slash
            if val[:2] == &#34;./&#34;:
                val = val[2:]

            if len(val) &gt; 8 and val[:8] == &#34;MAPLEAF/&#34;:
                # Replace the relative path with an absolute one
                Dict[key] = getAbsoluteFilePath(val)

    def _parseSimDefinitionFile(self, fileName):
        Dict = {}
        
        # Read all of the file&#39;s contents
        file = open(fileName, &#34;r+&#34;)
        workingText = file.read()
        file.close()
        
        # Remove comments
        comment = re.compile(&#34;(?&lt;!\\\)#.*&#34;) 
        workingText = re.sub(comment, &#34;&#34;, workingText) 
        
        # Remove comment escape characters
        workingText = re.sub(r&#34;\\(?=#)&#34;, &#34;&#34;, workingText) 
        
        # Remove blank lines
        workingText = [line for line in workingText.split(&#39;\n&#39;) if line.strip() != &#39;&#39;]
        
        # Start recursive parse by asking to parse the root-level dictionary
        self._parseDictionaryContents(Dict, workingText, 0, &#34;&#34;)

        # Look for file paths relative to the MAPLEAF install location, replace them with absolute paths
        self._replaceMAPLEAFRelativeFilePathsWithAbsolutePaths(Dict)

        return Dict

    #### Normal Usage ####
    #TODO: Move distribution sampling for probabilistic parameters to the parsing stage (do not re-sample if a value is requested multiple times)
    def getValue(self, key: str) -&gt; str:
        &#34;&#34;&#34;
            Input:
                Key should be a string of format &#34;DictionaryName.SubdictionaryName.Key&#34;
            Output:
                Always returns a string value
                Returns value from defaultConfigValues if key not present in current SimDefinition&#39;s dictionary

                Normal Distribution Sampling:
                    If (key + &#34;_stdDev&#34;) exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
                        Where the mean of the normal distribution is taken to be the value of &#39;key&#39; and the standard deviation of the distribution is the value of &#39;key_stdDev&#39;
                        For a vector value, a vector of standard deviations is expected
                    For repeatable sampling, set the value &#34;MonteCarlo.randomSeed&#34; in the file loaded by this class
        &#34;&#34;&#34;
        # Remove any whitespace from the key
        key = key.strip()

        ### Find string/mean value ###
        if self.dict.__contains__(key):
            stringValue = self.dict[key]

            if key in self.unaccessedFields: # Track which keys are accessed
                self.unaccessedFields.remove(key)
        elif key in self.defaultDict:
            stringValue = self.defaultDict[key]
            self.defaultValuesUsed.add(key)
        else:
            # Check if there&#39;s a class-based default value to return
            classBasedDefaultValue = self._getClassBasedDefaultValue(key)
            
            if classBasedDefaultValue != None:
                stringValue = classBasedDefaultValue
            else:
                raise KeyError(&#34;Key: &#34; + key + &#34; not found in {} or default config values&#34;.format(self.fileName))

        ### Sample from normal distribution if required ###
        if not self.disableDistributionSampling:
            ### Check if a standard deviation has been specified. If so, sample a gaussian distribution before returning the value ###
            stdDevKey = key + &#34;_stdDev&#34;

            # Scalar values
            try:
                mu = float(stringValue)            
                sigma = float(self.getValue(stdDevKey))

                sampledValue = self.rng.gauss(mu, sigma)

                logLine = &#34;Sampling scalar parameter: {}, value: {:1.3f}&#34;.format(key, sampledValue)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)


                return str(sampledValue)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to float fails
                pass

            # Vector values
            try:
                muVec = Vector(stringValue)
                sigmaVec = Vector(self.getValue(stdDevKey))

                sampledVec = Vector(*[ self.rng.gauss(mu, sigma) for mu, sigma in zip(muVec, sigmaVec)])

                logLine = &#34;Sampling vector parameter: {}, value: ({:1.3f})&#34;.format(key, sampledVec)
                if self.monteCarloLogger != None:
                    self.monteCarloLogger.log(logLine)
                elif not self.silent:
                    print(logLine)

                return str(sampledVec)
            except (KeyError, ValueError):
                # KeyError throws if stdDevKey not present
                # ValueError throws if either conversion to Vector fails
                pass

        ### Otherwise return original string value ###
        return stringValue

    def setValue(self, key: str, value) -&gt; None:
        &#39;&#39;&#39;
            Will add the entry if it&#39;s not present
        &#39;&#39;&#39;
        # The .strip() removes whitespace
        self.dict[key.strip()] = value

    def removeKey(self, key: str):
        if key in self.dict:
            return self.dict.pop(key)
        else:
            print(&#34;Warning: &#34; + key + &#34; not found, can&#39;t delete&#34;)
            return None

    def setIfAbsent(self, key: str, value):
        &#39;&#39;&#39; Sets a value, only if it doesn&#39;t currently exist in the dictionary &#39;&#39;&#39;
        if not key in self.dict:
            self.setValue(key, value)

    def writeToFile(self, fileName: str, writeHeader=True) -&gt; None:
        &#39;&#39;&#39; 
            Write a (potentially modified) sim definition to file.
            Newly written file will not contain any comments! 
        &#39;&#39;&#39;
        self.fileName = fileName

        with open(fileName, &#39;w&#39;) as file:
            # Extract the fileName from the fileName variable, which may contain other folder names
            dictName = re.sub(&#34;^.*/&#34;, &#34;&#34;, fileName)

            # Write Header
            if writeHeader:
                file.write(&#34;# MAPLEAF\n&#34;)
                file.write(&#34;# File: {}\n&#34;.format(fileName))
                file.write(&#34;# Autowritten on: &#34; + str(datetime.now()) + &#34;\n&#34;)

            # Sorting the keys before iterating through them ensures that dictionaries will be stored together
            sortedDict = sorted(self.dict.items())
            currDicts = []
            for key in sortedDict:
                key = key[0]
                dicts = key.split(&#39;.&#39;)[:-1]

                # Need to get be in the appropriate dictionary before writing the key, value pair
                if dicts != currDicts:
                    
                    #Close any uneeded dictionaries
                    dictDepth = currDicts.__len__()
                    while dictDepth &gt; 0:
                        if dictDepth &gt; dicts.__len__():
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        elif currDicts[dictDepth-1] != dicts[dictDepth-1]:
                            file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                        else:
                            break
                        
                        dictDepth = dictDepth - 1

                    openedNewDict = False

                    #Open any new dictionaries
                    while dictDepth &lt; dicts.__len__():
                        newDict = dicts[dictDepth]
                        file.write(&#34;\n&#34; + &#34;\t&#34; * dictDepth + newDict + &#34;{\n&#34;)
                        dictDepth = dictDepth + 1
                        openedNewDict = True
                    
                    if not openedNewDict:
                        # If no new dictionary was openend after closing unneeded ones, add a spacing line before writing keys/values
                        file.write(&#34;\n&#34;)

                    currDicts = dicts

                #Add the key, value
                dictDepth = currDicts.__len__()
                realKey = re.sub(&#34;^([^\.]*\.)+&#34;, &#34;&#34;, key)
                file.write( &#34;\t&#34;*dictDepth + realKey + &#34;\t&#34; + self.dict[key] + &#34;\n&#34;)

            #Close any open dictionaries
            dictDepth = currDicts.__len__()
            while dictDepth &gt; 0:
                dictDepth = dictDepth - 1
                file.write(&#34;\t&#34;*dictDepth + &#34;}\n&#34;)

    #### Introspection / Key Gymnastics ####
    def findKeysContaining(self, keyContains: List[str]) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that contain any of the strings in keyContains
            
            ## Example  
                findKeysContaining([&#34;class&#34;]) -&gt;  
                [ &#34;Rocket.class&#34;, &#34;Rocket.Sustainer.class&#34;, &#34;Rocket.Sustainer.Nosecone.class&#34;, etc... ]
        &#39;&#39;&#39;
        if not isinstance(keyContains, list):
            keyContains = [ keyContains ]
        
        matchingKeys = []
        for key in self.dict.keys():
            match = True
            for str in keyContains:
                if str not in key:
                    match = False
                    break
            
            if match:
                matchingKeys.append(key)
        
        if len(matchingKeys) &gt; 0:
            return matchingKeys
        else:
            return None

    def getSubKeys(self, key: str, Dict=None) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns a list of all keys that are children of key

            ## Example  
                getSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.position&#34;, &#34;Rocket.Sustainer.NoseCone.mass&#34;, &#34;Rocket.Sustainer.RecoverySystem.position&#34;, etc... ]
        &#39;&#39;&#39;
        #TODO: Improve speed by keeping dict sorted, then use binary search to locate first/last subkeys
        Dict = self.dict if (Dict == None) else Dict

        subKeys = []
        for currentKey in Dict.keys():
            if isSubKey(key, currentKey):
                subKeys.append(currentKey)
        
        return subKeys

    def getImmediateSubKeys(self, key: str) -&gt; List[str]:
        &#34;&#34;&#34; 
            Returns all keys that are immediate children of the parentKey (one &#39;level&#39; lower)
            
            .. note:: Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries

            ## Example:
                getImmediateSubKeys(&#34;Rocket&#34;) -&gt;  
                [ &#34;Rocket.name&#34;, &#34;Rocket.position&#34;, &#34;Rocket.velocity&#34;, etc...]
        &#34;&#34;&#34;
        results = set()
        for potentialChildKey in self.dict.keys():
            # Iterate through all keys - check if they are children of currentPath
            if isSubKey(key, potentialChildKey):
                # If so, get the part of the key that is the immediate child of currentPath
                immediateSubkey = getImmediateSubKey(key, potentialChildKey)
                
                if immediateSubkey in self.dict:
                    # If we haven&#39;t got it already, save it
                    results.add(immediateSubkey)

        return list(results)

    def getImmediateSubDicts(self, key: str) -&gt; List[str]:
        &#39;&#39;&#39;
            Returns list of names of immediate subdictionaries

            ## Example
                getImmediateSubDicts(&#34;Rocket&#34;) -&gt;
                [ &#34;Rocket.StageOne&#34;, &#34;Rocket.StageTwo&#34;, &#34;Rocket.ControlSystem&#34;, etc... ]

            .. note:: This example would not return a dictionry like: &#34;Rocket.StageOne.FinSet&#34; because it&#39;s not an immediate subdictionary of &#34;Rocket&#34;
        &#39;&#39;&#39;
        keyLevel = getKeyLevel(key)
        subKeys = self.getSubKeys(key)

        subDictionaries = set()
        for subKey in subKeys:
            subKeyLevel = getKeyLevel(subKey)
            if subKeyLevel - keyLevel &gt; 1:
                # A subkey would have 1 level higher
                # A subkey of a subdictionary would have 2 levels higher - this is what we&#39;re looking for
                subDictKey = getParentKeyAtLevel(subKey, keyLevel+1)
                subDictionaries.add(subDictKey)
        
        return list(subDictionaries)

    def _getClassBasedDefaultValue(self, key: str) -&gt; Union[str, None]:
        &#39;&#39;&#39; 
            Returns class-based default value from defaultConfigValues if it exists. Otherwise returns None 
            
            Will attempt to find class-based default values for every longer prefixes of a key:
                key = &#34;Rocket.Sustainer.canards.trailingEdge.shape&#34;
                Attempt1 = &#34;Rocket.Sustainer.canards.trailingEdge.class&#34; -&gt; Fail
                Attempt2 = &#34;Rocket.Sustainer.canards.class&#34; -&gt; FinSet -&gt; look up &#39;FinSet.trailingEdge.shape&#39; in defaultDict -&gt; if there, return it, otherwise return None
        &#39;&#39;&#39;
        splitLevel = getKeyLevel(key)

        while splitLevel &gt;= 0:
            prefix, suffix = splitKeyAtLevel(key, splitLevel)
            
            try:
                classKey = prefix + &#34;.class&#34;
                className = self.dict[classKey]                

                # As soon as we arrive at an item with a class, search terminates
                try:
                    classBasedDefaultKey = className + &#34;.&#34; + suffix
                    defaultValue = self.defaultDict[classBasedDefaultKey]

                    # Track that we&#39;ve used a default value
                    self.defaultValuesUsed.add(classBasedDefaultKey)
                    
                    # if the classKey was useful, count it as &#39;used&#39;
                    if classKey in self.unaccessedFields: 
                        self.unaccessedFields.remove(classKey)
                        
                    return defaultValue
                except KeyError:
                    return None # class-based default value not found
            
            except KeyError:
                pass # prefix.class not present

            # Move one level up the dictionary for next attempt
            splitLevel -= 1
        
        return None

    #### Usage Reporting ####
    def printUnusedKeys(self):
        &#39;&#39;&#39;
            Checks which keys in the present simulation definition have not yet been accessed.
            Prints a list of those to the console.
        &#39;&#39;&#39;
        if len(self.unaccessedFields) &gt; 0:
            print(&#34;\nWarning: The following keys were loaded from: {} but never accessed:&#34;.format(self.fileName))
            for key in sorted(self.unaccessedFields):
                value = self.dict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;&#34;)

    def printDefaultValuesUsed(self):
        &#39;&#39;&#39;
            Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.
        &#39;&#39;&#39;
        if len(self.defaultValuesUsed):
            print(&#34;\nWarning: The following default values were used in this simulation:&#34;)
            for key in sorted(self.defaultValuesUsed):
                value = self.defaultDict[key]
                print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
            print(&#34;\nIf this was not intended, override the default values by adding the above information to your simulation definition file.\n&#34;)
        
    def _resetUsageTrackers(self):
        # Create a dictionary to keep track of which attributed have been accessed (initially none)
        self.unaccessedFields = set(self.dict.keys())
        # Create a list to track which default values have been used
        self.defaultValuesUsed = set()

    #### Utilities ####
    def __str__(self):
        result = &#34;&#34;
        result += &#34;File: &#34; + self.fileName + &#34;\n&#34;

        for key, value in self.dict.items():
            result += &#34;{}: {}\n&#34;.format(key, value)

        result += &#34;\n&#34;

        return result

    def __eq__ (self, simDef2):
        try:
            if self.dict == simDef2.dict:
                return True
            else:
                return False
        except AttributeError:
            return False

    def __contains__(self, key):
        &#39;&#39;&#39; Only checks whether &#39;key&#39; was parsed from the file. Ignores default values &#39;&#39;&#39;
        return key in self.dict</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.defaultDict"><code class="name">var <span class="ident">defaultDict</span></code></dt>
<dd>
<div class="desc"><p>Holds all of the defined default values. These will fill in for missing values in self.dict. Unless a different dictionary is specified, will hold a reference to <code>defaultConfigValues</code></p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.dict"><code class="name">var <span class="ident">dict</span></code></dt>
<dd>
<div class="desc"><p>Main dictionary of values, usually populated from a simulation definition file</p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.disableDistributionSampling"><code class="name">var <span class="ident">disableDistributionSampling</span></code></dt>
<dd>
<div class="desc"><p>Boolean - controls whether parameters which have standard deviations specified are actually sampled from a normal distribution. If True, the mean value is always returned. Chief use case for disabling sampling: Checking simulation convergence as the time step / target error is decreased.</p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.monteCarloLogger"><code class="name">var <span class="ident">monteCarloLogger</span></code></dt>
<dd>
<div class="desc"><p>Filled in by
Main.runMonteCarloSimulation() if running
Monte Carlo simulation. Type: <code><a title="MAPLEAF.IO.Logging.MonteCarloLogger" href="Logging.html#MAPLEAF.IO.Logging.MonteCarloLogger">MonteCarloLogger</a></code></p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.silent"><code class="name">var <span class="ident">silent</span></code></dt>
<dd>
<div class="desc"><p>Boolean, controls console output</p></div>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.simDefParseStack"><code class="name">var <span class="ident">simDefParseStack</span></code></dt>
<dd>
<div class="desc"><p>Keeps track of which files have already been loaded in the current parse stack. If these are loaded again we're in a parsing loop</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.SimDefinition.findKeysContaining"><code class="name flex">
<span>def <span class="ident">findKeysContaining</span></span>(<span>self, keyContains: List[str]) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all keys that contain any of the strings in keyContains</p>
<h2 id="example">Example</h2>
<pre><code>findKeysContaining(["class"]) -&gt;  
[ "Rocket.class", "Rocket.Sustainer.class", "Rocket.Sustainer.Nosecone.class", etc... ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findKeysContaining(self, keyContains: List[str]) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns a list of all keys that contain any of the strings in keyContains
        
        ## Example  
            findKeysContaining([&#34;class&#34;]) -&gt;  
            [ &#34;Rocket.class&#34;, &#34;Rocket.Sustainer.class&#34;, &#34;Rocket.Sustainer.Nosecone.class&#34;, etc... ]
    &#39;&#39;&#39;
    if not isinstance(keyContains, list):
        keyContains = [ keyContains ]
    
    matchingKeys = []
    for key in self.dict.keys():
        match = True
        for str in keyContains:
            if str not in key:
                match = False
                break
        
        if match:
            matchingKeys.append(key)
    
    if len(matchingKeys) &gt; 0:
        return matchingKeys
    else:
        return None</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getImmediateSubDicts"><code class="name flex">
<span>def <span class="ident">getImmediateSubDicts</span></span>(<span>self, key: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of names of immediate subdictionaries</p>
<h2 id="example">Example</h2>
<pre><code>getImmediateSubDicts("Rocket") -&gt;
[ "Rocket.StageOne", "Rocket.StageTwo", "Rocket.ControlSystem", etc... ]
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This example would not return a dictionry like: "Rocket.StageOne.FinSet" because it's not an immediate subdictionary of "Rocket"</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubDicts(self, key: str) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns list of names of immediate subdictionaries

        ## Example
            getImmediateSubDicts(&#34;Rocket&#34;) -&gt;
            [ &#34;Rocket.StageOne&#34;, &#34;Rocket.StageTwo&#34;, &#34;Rocket.ControlSystem&#34;, etc... ]

        .. note:: This example would not return a dictionry like: &#34;Rocket.StageOne.FinSet&#34; because it&#39;s not an immediate subdictionary of &#34;Rocket&#34;
    &#39;&#39;&#39;
    keyLevel = getKeyLevel(key)
    subKeys = self.getSubKeys(key)

    subDictionaries = set()
    for subKey in subKeys:
        subKeyLevel = getKeyLevel(subKey)
        if subKeyLevel - keyLevel &gt; 1:
            # A subkey would have 1 level higher
            # A subkey of a subdictionary would have 2 levels higher - this is what we&#39;re looking for
            subDictKey = getParentKeyAtLevel(subKey, keyLevel+1)
            subDictionaries.add(subDictKey)
    
    return list(subDictionaries)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getImmediateSubKeys"><code class="name flex">
<span>def <span class="ident">getImmediateSubKeys</span></span>(<span>self, key: str) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all keys that are immediate children of the parentKey (one 'level' lower)</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries</p>
</div>
<h2 id="example">Example:</h2>
<pre><code>getImmediateSubKeys("Rocket") -&gt;  
[ "Rocket.name", "Rocket.position", "Rocket.velocity", etc...]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubKeys(self, key: str) -&gt; List[str]:
    &#34;&#34;&#34; 
        Returns all keys that are immediate children of the parentKey (one &#39;level&#39; lower)
        
        .. note:: Will not return subdictionaries, only keys that have a value associated with them. Use self.getImmediateSubDicts() to discover sub-dictionaries

        ## Example:
            getImmediateSubKeys(&#34;Rocket&#34;) -&gt;  
            [ &#34;Rocket.name&#34;, &#34;Rocket.position&#34;, &#34;Rocket.velocity&#34;, etc...]
    &#34;&#34;&#34;
    results = set()
    for potentialChildKey in self.dict.keys():
        # Iterate through all keys - check if they are children of currentPath
        if isSubKey(key, potentialChildKey):
            # If so, get the part of the key that is the immediate child of currentPath
            immediateSubkey = getImmediateSubKey(key, potentialChildKey)
            
            if immediateSubkey in self.dict:
                # If we haven&#39;t got it already, save it
                results.add(immediateSubkey)

    return list(results)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getSubKeys"><code class="name flex">
<span>def <span class="ident">getSubKeys</span></span>(<span>self, key: str, Dict=None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of all keys that are children of key</p>
<h2 id="example">Example</h2>
<pre><code>getSubKeys("Rocket") -&gt;  
[ "Rocket.position", "Rocket.Sustainer.NoseCone.mass", "Rocket.Sustainer.RecoverySystem.position", etc... ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSubKeys(self, key: str, Dict=None) -&gt; List[str]:
    &#39;&#39;&#39;
        Returns a list of all keys that are children of key

        ## Example  
            getSubKeys(&#34;Rocket&#34;) -&gt;  
            [ &#34;Rocket.position&#34;, &#34;Rocket.Sustainer.NoseCone.mass&#34;, &#34;Rocket.Sustainer.RecoverySystem.position&#34;, etc... ]
    &#39;&#39;&#39;
    #TODO: Improve speed by keeping dict sorted, then use binary search to locate first/last subkeys
    Dict = self.dict if (Dict == None) else Dict

    subKeys = []
    for currentKey in Dict.keys():
        if isSubKey(key, currentKey):
            subKeys.append(currentKey)
    
    return subKeys</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>self, key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><h2 id="input">Input</h2>
<p>Key should be a string of format "DictionaryName.SubdictionaryName.Key"</p>
<h2 id="output">Output</h2>
<p>Always returns a string value
Returns value from defaultConfigValues if key not present in current SimDefinition's dictionary</p>
<p>Normal Distribution Sampling:
If (key + "_stdDev") exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
Where the mean of the normal distribution is taken to be the value of 'key' and the standard deviation of the distribution is the value of 'key_stdDev'
For a vector value, a vector of standard deviations is expected
For repeatable sampling, set the value "MonteCarlo.randomSeed" in the file loaded by this class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getValue(self, key: str) -&gt; str:
    &#34;&#34;&#34;
        Input:
            Key should be a string of format &#34;DictionaryName.SubdictionaryName.Key&#34;
        Output:
            Always returns a string value
            Returns value from defaultConfigValues if key not present in current SimDefinition&#39;s dictionary

            Normal Distribution Sampling:
                If (key + &#34;_stdDev&#34;) exists and the value being returned is a scalar or Vector value, returns a scalar or vector sampled from a normal distribution
                    Where the mean of the normal distribution is taken to be the value of &#39;key&#39; and the standard deviation of the distribution is the value of &#39;key_stdDev&#39;
                    For a vector value, a vector of standard deviations is expected
                For repeatable sampling, set the value &#34;MonteCarlo.randomSeed&#34; in the file loaded by this class
    &#34;&#34;&#34;
    # Remove any whitespace from the key
    key = key.strip()

    ### Find string/mean value ###
    if self.dict.__contains__(key):
        stringValue = self.dict[key]

        if key in self.unaccessedFields: # Track which keys are accessed
            self.unaccessedFields.remove(key)
    elif key in self.defaultDict:
        stringValue = self.defaultDict[key]
        self.defaultValuesUsed.add(key)
    else:
        # Check if there&#39;s a class-based default value to return
        classBasedDefaultValue = self._getClassBasedDefaultValue(key)
        
        if classBasedDefaultValue != None:
            stringValue = classBasedDefaultValue
        else:
            raise KeyError(&#34;Key: &#34; + key + &#34; not found in {} or default config values&#34;.format(self.fileName))

    ### Sample from normal distribution if required ###
    if not self.disableDistributionSampling:
        ### Check if a standard deviation has been specified. If so, sample a gaussian distribution before returning the value ###
        stdDevKey = key + &#34;_stdDev&#34;

        # Scalar values
        try:
            mu = float(stringValue)            
            sigma = float(self.getValue(stdDevKey))

            sampledValue = self.rng.gauss(mu, sigma)

            logLine = &#34;Sampling scalar parameter: {}, value: {:1.3f}&#34;.format(key, sampledValue)
            if self.monteCarloLogger != None:
                self.monteCarloLogger.log(logLine)
            elif not self.silent:
                print(logLine)


            return str(sampledValue)
        except (KeyError, ValueError):
            # KeyError throws if stdDevKey not present
            # ValueError throws if either conversion to float fails
            pass

        # Vector values
        try:
            muVec = Vector(stringValue)
            sigmaVec = Vector(self.getValue(stdDevKey))

            sampledVec = Vector(*[ self.rng.gauss(mu, sigma) for mu, sigma in zip(muVec, sigmaVec)])

            logLine = &#34;Sampling vector parameter: {}, value: ({:1.3f})&#34;.format(key, sampledVec)
            if self.monteCarloLogger != None:
                self.monteCarloLogger.log(logLine)
            elif not self.silent:
                print(logLine)

            return str(sampledVec)
        except (KeyError, ValueError):
            # KeyError throws if stdDevKey not present
            # ValueError throws if either conversion to Vector fails
            pass

    ### Otherwise return original string value ###
    return stringValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.printDefaultValuesUsed"><code class="name flex">
<span>def <span class="ident">printDefaultValuesUsed</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printDefaultValuesUsed(self):
    &#39;&#39;&#39;
        Checks which default values have been used since the creation of the current instance of SimDefinition. Prints those to the console.
    &#39;&#39;&#39;
    if len(self.defaultValuesUsed):
        print(&#34;\nWarning: The following default values were used in this simulation:&#34;)
        for key in sorted(self.defaultValuesUsed):
            value = self.defaultDict[key]
            print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
        print(&#34;\nIf this was not intended, override the default values by adding the above information to your simulation definition file.\n&#34;)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.printUnusedKeys"><code class="name flex">
<span>def <span class="ident">printUnusedKeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks which keys in the present simulation definition have not yet been accessed.
Prints a list of those to the console.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printUnusedKeys(self):
    &#39;&#39;&#39;
        Checks which keys in the present simulation definition have not yet been accessed.
        Prints a list of those to the console.
    &#39;&#39;&#39;
    if len(self.unaccessedFields) &gt; 0:
        print(&#34;\nWarning: The following keys were loaded from: {} but never accessed:&#34;.format(self.fileName))
        for key in sorted(self.unaccessedFields):
            value = self.dict[key]
            print(&#34;{:&lt;45}{}&#34;.format(key+&#34;:&#34;, value))
        print(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.removeKey"><code class="name flex">
<span>def <span class="ident">removeKey</span></span>(<span>self, key: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeKey(self, key: str):
    if key in self.dict:
        return self.dict.pop(key)
    else:
        print(&#34;Warning: &#34; + key + &#34; not found, can&#39;t delete&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.setIfAbsent"><code class="name flex">
<span>def <span class="ident">setIfAbsent</span></span>(<span>self, key: str, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a value, only if it doesn't currently exist in the dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setIfAbsent(self, key: str, value):
    &#39;&#39;&#39; Sets a value, only if it doesn&#39;t currently exist in the dictionary &#39;&#39;&#39;
    if not key in self.dict:
        self.setValue(key, value)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.setValue"><code class="name flex">
<span>def <span class="ident">setValue</span></span>(<span>self, key: str, value) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Will add the entry if it's not present</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setValue(self, key: str, value) -&gt; None:
    &#39;&#39;&#39;
        Will add the entry if it&#39;s not present
    &#39;&#39;&#39;
    # The .strip() removes whitespace
    self.dict[key.strip()] = value</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SimDefinition.writeToFile"><code class="name flex">
<span>def <span class="ident">writeToFile</span></span>(<span>self, fileName: str, writeHeader=True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Write a (potentially modified) sim definition to file.
Newly written file will not contain any comments!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeToFile(self, fileName: str, writeHeader=True) -&gt; None:
    &#39;&#39;&#39; 
        Write a (potentially modified) sim definition to file.
        Newly written file will not contain any comments! 
    &#39;&#39;&#39;
    self.fileName = fileName

    with open(fileName, &#39;w&#39;) as file:
        # Extract the fileName from the fileName variable, which may contain other folder names
        dictName = re.sub(&#34;^.*/&#34;, &#34;&#34;, fileName)

        # Write Header
        if writeHeader:
            file.write(&#34;# MAPLEAF\n&#34;)
            file.write(&#34;# File: {}\n&#34;.format(fileName))
            file.write(&#34;# Autowritten on: &#34; + str(datetime.now()) + &#34;\n&#34;)

        # Sorting the keys before iterating through them ensures that dictionaries will be stored together
        sortedDict = sorted(self.dict.items())
        currDicts = []
        for key in sortedDict:
            key = key[0]
            dicts = key.split(&#39;.&#39;)[:-1]

            # Need to get be in the appropriate dictionary before writing the key, value pair
            if dicts != currDicts:
                
                #Close any uneeded dictionaries
                dictDepth = currDicts.__len__()
                while dictDepth &gt; 0:
                    if dictDepth &gt; dicts.__len__():
                        file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                    elif currDicts[dictDepth-1] != dicts[dictDepth-1]:
                        file.write(&#34;\t&#34;*(dictDepth-1) + &#34;}\n&#34;)
                    else:
                        break
                    
                    dictDepth = dictDepth - 1

                openedNewDict = False

                #Open any new dictionaries
                while dictDepth &lt; dicts.__len__():
                    newDict = dicts[dictDepth]
                    file.write(&#34;\n&#34; + &#34;\t&#34; * dictDepth + newDict + &#34;{\n&#34;)
                    dictDepth = dictDepth + 1
                    openedNewDict = True
                
                if not openedNewDict:
                    # If no new dictionary was openend after closing unneeded ones, add a spacing line before writing keys/values
                    file.write(&#34;\n&#34;)

                currDicts = dicts

            #Add the key, value
            dictDepth = currDicts.__len__()
            realKey = re.sub(&#34;^([^\.]*\.)+&#34;, &#34;&#34;, key)
            file.write( &#34;\t&#34;*dictDepth + realKey + &#34;\t&#34; + self.dict[key] + &#34;\n&#34;)

        #Close any open dictionaries
        dictDepth = currDicts.__len__()
        while dictDepth &gt; 0:
            dictDepth = dictDepth - 1
            file.write(&#34;\t&#34;*dictDepth + &#34;}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.IO.SubDictReader"><code class="flex name class">
<span>class <span class="ident">SubDictReader</span></span>
<span>(</span><span>stringPathToThisItemsSubDictionary, simDefinition)</span>
</code></dt>
<dd>
<div class="desc"><p>Example stringPathToThisItemsSubDictionary = 'Rocket.Stage1.Nosecone' if we're initializing a nosecone object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubDictReader():

    def __init__(self, stringPathToThisItemsSubDictionary, simDefinition):
        &#39;&#39;&#39;
            Example stringPathToThisItemsSubDictionary = &#39;Rocket.Stage1.Nosecone&#39; if we&#39;re initializing a nosecone object
        &#39;&#39;&#39;
        self.simDefDictPathToReadFrom = stringPathToThisItemsSubDictionary
        self.simDefinition = simDefinition

    def getString(self, key):
        &#39;&#39;&#39; 
            Pass in either relative key or absolute key:
                Ex 1 (Relative): If object subdictionary (self.simDefDictPathToReadFrom) is &#39;Rocket.Stage1.Nosecone&#39;, relative keys could be &#39;position&#39; or &#39;aspectRatio&#39;
                    These would retrieve Rocket.Stage1.Nosecone.position or Rocket.Stage1.Nosecone.aspectRatio from the sim definition
                Ex 2 (Absolute): Can also pass in full absolute key, like &#39;Rocket.Stage1.Nosecone.position&#39;, and it will retrieve that value, as long as there isn&#39;t a &#39;path collision&#39; with a relative path
        &#39;&#39;&#39;
        try:
            return self.simDefinition.getValue(self.simDefDictPathToReadFrom + &#34;.&#34; + key)
        except KeyError:
            try:
                return self.simDefinition.getValue(key)
            except KeyError:
                attemptedKey1 = self.simDefDictPathToReadFrom + &#34;.&#34; + key
                attemptedKey2 = key
                raise KeyError(&#34;{} and {} not found in {} or in default value dictionary&#34;.format(attemptedKey1, attemptedKey2, self.simDefinition.fileName))

    #### Get parsed values ####
    def getInt(self, key: str) -&gt; int:
        return int(self.getString(key))

    def getFloat(self, key: str) -&gt; float:
        return float(self.getString(key))

    def getVector(self, key: str) -&gt; Vector:
        return Vector(self.getString(key))

    def getBool(self, key: str) -&gt; bool:
        return strtobool(self.getString(key))

    #### Try get values (return specified default value if not found) ####
    def tryGetString(self, key: str, defaultValue: Union[None, str]=None):
        try:
            return self.getString(key)
        except KeyError:
            return defaultValue

    def tryGetInt(self, key: str, defaultValue: Union[None, int]=None):
        try:
            return int(self.getString(key))
        except KeyError:
            return defaultValue

    def tryGetFloat(self, key: str, defaultValue: Union[None, float]=None):
        try:
            return float(self.getString(key))
        except KeyError:
            return defaultValue

    def tryGetVector(self, key: str, defaultValue: Union[None, Vector]=None):
        try:
            return Vector(self.getString(key))
        except KeyError:
            return defaultValue

    def tryGetBool(self, key: str, defaultValue: Union[None, bool]=None):
        try:
            return strtobool(self.getString(key))
        except KeyError:
            return defaultValue

    #### Introspection ####
    def getImmediateSubDicts(self, key=None) -&gt; List[str]:
        if key == None:
            key = self.simDefDictPathToReadFrom
        else:
            absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
            result = self.simDefinition.getImmediateSubDicts(absKey)
        
            if len(result) != 0: # If no subdicts found, try other key
                return result
        
        return self.simDefinition.getImmediateSubDicts(key)

    def getSubKeys(self, key=None) -&gt; List[str]:
        if key == None:
            key = self.simDefDictPathToReadFrom
        else:
            absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
            result = self.simDefinition.getSubKeys(absKey)

            if len(result) != 0: # If nothing found, try another key
                return result

        return self.simDefinition.getSubKeys(key)

    def getImmediateSubKeys(self, key=None) -&gt; List[str]:
        if key == None:
            key = self.simDefDictPathToReadFrom
        else:
            absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
            result = self.simDefinition.getImmediateSubKeys(absKey)

            if len(result) != 0: # If nothing found, try another key
                return result

        return self.simDefinition.getImmediateSubKeys(key)

    def getDictName(self) -&gt; str:
        lastDotIndex = self.simDefDictPathToReadFrom.rfind(&#39;.&#39;)
        return self.simDefDictPathToReadFrom[lastDotIndex+1:]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.GNC.ControlSystems.RocketControlSystem" href="../GNC/ControlSystems.html#MAPLEAF.GNC.ControlSystems.RocketControlSystem">RocketControlSystem</a></li>
<li><a title="MAPLEAF.Rocket.Propulsion.TabulatedMotor" href="../Rocket/Propulsion.html#MAPLEAF.Rocket.Propulsion.TabulatedMotor">TabulatedMotor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.IO.SubDictReader.getBool"><code class="name flex">
<span>def <span class="ident">getBool</span></span>(<span>self, key: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBool(self, key: str) -&gt; bool:
    return strtobool(self.getString(key))</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getDictName"><code class="name flex">
<span>def <span class="ident">getDictName</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDictName(self) -&gt; str:
    lastDotIndex = self.simDefDictPathToReadFrom.rfind(&#39;.&#39;)
    return self.simDefDictPathToReadFrom[lastDotIndex+1:]</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getFloat"><code class="name flex">
<span>def <span class="ident">getFloat</span></span>(<span>self, key: str) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFloat(self, key: str) -&gt; float:
    return float(self.getString(key))</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getImmediateSubDicts"><code class="name flex">
<span>def <span class="ident">getImmediateSubDicts</span></span>(<span>self, key=None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubDicts(self, key=None) -&gt; List[str]:
    if key == None:
        key = self.simDefDictPathToReadFrom
    else:
        absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
        result = self.simDefinition.getImmediateSubDicts(absKey)
    
        if len(result) != 0: # If no subdicts found, try other key
            return result
    
    return self.simDefinition.getImmediateSubDicts(key)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getImmediateSubKeys"><code class="name flex">
<span>def <span class="ident">getImmediateSubKeys</span></span>(<span>self, key=None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImmediateSubKeys(self, key=None) -&gt; List[str]:
    if key == None:
        key = self.simDefDictPathToReadFrom
    else:
        absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
        result = self.simDefinition.getImmediateSubKeys(absKey)

        if len(result) != 0: # If nothing found, try another key
            return result

    return self.simDefinition.getImmediateSubKeys(key)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getInt"><code class="name flex">
<span>def <span class="ident">getInt</span></span>(<span>self, key: str) ‑> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInt(self, key: str) -&gt; int:
    return int(self.getString(key))</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getString"><code class="name flex">
<span>def <span class="ident">getString</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Pass in either relative key or absolute key:
Ex 1 (Relative): If object subdictionary (self.simDefDictPathToReadFrom) is 'Rocket.Stage1.Nosecone', relative keys could be 'position' or 'aspectRatio'
These would retrieve Rocket.Stage1.Nosecone.position or Rocket.Stage1.Nosecone.aspectRatio from the sim definition
Ex 2 (Absolute): Can also pass in full absolute key, like 'Rocket.Stage1.Nosecone.position', and it will retrieve that value, as long as there isn't a 'path collision' with a relative path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getString(self, key):
    &#39;&#39;&#39; 
        Pass in either relative key or absolute key:
            Ex 1 (Relative): If object subdictionary (self.simDefDictPathToReadFrom) is &#39;Rocket.Stage1.Nosecone&#39;, relative keys could be &#39;position&#39; or &#39;aspectRatio&#39;
                These would retrieve Rocket.Stage1.Nosecone.position or Rocket.Stage1.Nosecone.aspectRatio from the sim definition
            Ex 2 (Absolute): Can also pass in full absolute key, like &#39;Rocket.Stage1.Nosecone.position&#39;, and it will retrieve that value, as long as there isn&#39;t a &#39;path collision&#39; with a relative path
    &#39;&#39;&#39;
    try:
        return self.simDefinition.getValue(self.simDefDictPathToReadFrom + &#34;.&#34; + key)
    except KeyError:
        try:
            return self.simDefinition.getValue(key)
        except KeyError:
            attemptedKey1 = self.simDefDictPathToReadFrom + &#34;.&#34; + key
            attemptedKey2 = key
            raise KeyError(&#34;{} and {} not found in {} or in default value dictionary&#34;.format(attemptedKey1, attemptedKey2, self.simDefinition.fileName))</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getSubKeys"><code class="name flex">
<span>def <span class="ident">getSubKeys</span></span>(<span>self, key=None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSubKeys(self, key=None) -&gt; List[str]:
    if key == None:
        key = self.simDefDictPathToReadFrom
    else:
        absKey = self.simDefDictPathToReadFrom + &#34;.&#34; + key
        result = self.simDefinition.getSubKeys(absKey)

        if len(result) != 0: # If nothing found, try another key
            return result

    return self.simDefinition.getSubKeys(key)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.getVector"><code class="name flex">
<span>def <span class="ident">getVector</span></span>(<span>self, key: str) ‑> <a title="MAPLEAF.Motion.CythonVector.Vector" href="../Motion/CythonVector.html#MAPLEAF.Motion.CythonVector.Vector">Vector</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getVector(self, key: str) -&gt; Vector:
    return Vector(self.getString(key))</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.tryGetBool"><code class="name flex">
<span>def <span class="ident">tryGetBool</span></span>(<span>self, key: str, defaultValue: Union[NoneType, bool] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tryGetBool(self, key: str, defaultValue: Union[None, bool]=None):
    try:
        return strtobool(self.getString(key))
    except KeyError:
        return defaultValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.tryGetFloat"><code class="name flex">
<span>def <span class="ident">tryGetFloat</span></span>(<span>self, key: str, defaultValue: Union[NoneType, float] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tryGetFloat(self, key: str, defaultValue: Union[None, float]=None):
    try:
        return float(self.getString(key))
    except KeyError:
        return defaultValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.tryGetInt"><code class="name flex">
<span>def <span class="ident">tryGetInt</span></span>(<span>self, key: str, defaultValue: Union[NoneType, int] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tryGetInt(self, key: str, defaultValue: Union[None, int]=None):
    try:
        return int(self.getString(key))
    except KeyError:
        return defaultValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.tryGetString"><code class="name flex">
<span>def <span class="ident">tryGetString</span></span>(<span>self, key: str, defaultValue: Union[NoneType, str] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tryGetString(self, key: str, defaultValue: Union[None, str]=None):
    try:
        return self.getString(key)
    except KeyError:
        return defaultValue</code></pre>
</details>
</dd>
<dt id="MAPLEAF.IO.SubDictReader.tryGetVector"><code class="name flex">
<span>def <span class="ident">tryGetVector</span></span>(<span>self, key: str, defaultValue: Union[NoneType, <a title="MAPLEAF.Motion.CythonVector.Vector" href="../Motion/CythonVector.html#MAPLEAF.Motion.CythonVector.Vector">Vector</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tryGetVector(self, key: str, defaultValue: Union[None, Vector]=None):
    try:
        return Vector(self.getString(key))
    except KeyError:
        return defaultValue</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF" href="../index.html">MAPLEAF</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="MAPLEAF.IO.HIL" href="HIL.html">MAPLEAF.IO.HIL</a></code></li>
<li><code><a title="MAPLEAF.IO.Logging" href="Logging.html">MAPLEAF.IO.Logging</a></code></li>
<li><code><a title="MAPLEAF.IO.Plotting" href="Plotting.html">MAPLEAF.IO.Plotting</a></code></li>
<li><code><a title="MAPLEAF.IO.gridConvergenceFunctions" href="gridConvergenceFunctions.html">MAPLEAF.IO.gridConvergenceFunctions</a></code></li>
<li><code><a title="MAPLEAF.IO.rocketFlight" href="rocketFlight.html">MAPLEAF.IO.rocketFlight</a></code></li>
<li><code><a title="MAPLEAF.IO.simDefinition" href="simDefinition.html">MAPLEAF.IO.simDefinition</a></code></li>
<li><code><a title="MAPLEAF.IO.subDictReader" href="subDictReader.html">MAPLEAF.IO.subDictReader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MAPLEAF.IO.getAbsoluteFilePath" href="#MAPLEAF.IO.getAbsoluteFilePath">getAbsoluteFilePath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.IO.RocketFlight" href="#MAPLEAF.IO.RocketFlight">RocketFlight</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.RocketFlight.getApogee" href="#MAPLEAF.IO.RocketFlight.getApogee">getApogee</a></code></li>
<li><code><a title="MAPLEAF.IO.RocketFlight.getFlightTime" href="#MAPLEAF.IO.RocketFlight.getFlightTime">getFlightTime</a></code></li>
<li><code><a title="MAPLEAF.IO.RocketFlight.getLandingLocation" href="#MAPLEAF.IO.RocketFlight.getLandingLocation">getLandingLocation</a></code></li>
<li><code><a title="MAPLEAF.IO.RocketFlight.getMaxHorizontalVel" href="#MAPLEAF.IO.RocketFlight.getMaxHorizontalVel">getMaxHorizontalVel</a></code></li>
<li><code><a title="MAPLEAF.IO.RocketFlight.getMaxSpeed" href="#MAPLEAF.IO.RocketFlight.getMaxSpeed">getMaxSpeed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.IO.SimDefinition" href="#MAPLEAF.IO.SimDefinition">SimDefinition</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.SimDefinition.defaultDict" href="#MAPLEAF.IO.SimDefinition.defaultDict">defaultDict</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.dict" href="#MAPLEAF.IO.SimDefinition.dict">dict</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.disableDistributionSampling" href="#MAPLEAF.IO.SimDefinition.disableDistributionSampling">disableDistributionSampling</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.findKeysContaining" href="#MAPLEAF.IO.SimDefinition.findKeysContaining">findKeysContaining</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getImmediateSubDicts" href="#MAPLEAF.IO.SimDefinition.getImmediateSubDicts">getImmediateSubDicts</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getImmediateSubKeys" href="#MAPLEAF.IO.SimDefinition.getImmediateSubKeys">getImmediateSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getSubKeys" href="#MAPLEAF.IO.SimDefinition.getSubKeys">getSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.getValue" href="#MAPLEAF.IO.SimDefinition.getValue">getValue</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.monteCarloLogger" href="#MAPLEAF.IO.SimDefinition.monteCarloLogger">monteCarloLogger</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.printDefaultValuesUsed" href="#MAPLEAF.IO.SimDefinition.printDefaultValuesUsed">printDefaultValuesUsed</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.printUnusedKeys" href="#MAPLEAF.IO.SimDefinition.printUnusedKeys">printUnusedKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.removeKey" href="#MAPLEAF.IO.SimDefinition.removeKey">removeKey</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.setIfAbsent" href="#MAPLEAF.IO.SimDefinition.setIfAbsent">setIfAbsent</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.setValue" href="#MAPLEAF.IO.SimDefinition.setValue">setValue</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.silent" href="#MAPLEAF.IO.SimDefinition.silent">silent</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.simDefParseStack" href="#MAPLEAF.IO.SimDefinition.simDefParseStack">simDefParseStack</a></code></li>
<li><code><a title="MAPLEAF.IO.SimDefinition.writeToFile" href="#MAPLEAF.IO.SimDefinition.writeToFile">writeToFile</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.IO.SubDictReader" href="#MAPLEAF.IO.SubDictReader">SubDictReader</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.IO.SubDictReader.getBool" href="#MAPLEAF.IO.SubDictReader.getBool">getBool</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getDictName" href="#MAPLEAF.IO.SubDictReader.getDictName">getDictName</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getFloat" href="#MAPLEAF.IO.SubDictReader.getFloat">getFloat</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getImmediateSubDicts" href="#MAPLEAF.IO.SubDictReader.getImmediateSubDicts">getImmediateSubDicts</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getImmediateSubKeys" href="#MAPLEAF.IO.SubDictReader.getImmediateSubKeys">getImmediateSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getInt" href="#MAPLEAF.IO.SubDictReader.getInt">getInt</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getString" href="#MAPLEAF.IO.SubDictReader.getString">getString</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getSubKeys" href="#MAPLEAF.IO.SubDictReader.getSubKeys">getSubKeys</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.getVector" href="#MAPLEAF.IO.SubDictReader.getVector">getVector</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.tryGetBool" href="#MAPLEAF.IO.SubDictReader.tryGetBool">tryGetBool</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.tryGetFloat" href="#MAPLEAF.IO.SubDictReader.tryGetFloat">tryGetFloat</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.tryGetInt" href="#MAPLEAF.IO.SubDictReader.tryGetInt">tryGetInt</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.tryGetString" href="#MAPLEAF.IO.SubDictReader.tryGetString">tryGetString</a></code></li>
<li><code><a title="MAPLEAF.IO.SubDictReader.tryGetVector" href="#MAPLEAF.IO.SubDictReader.tryGetVector">tryGetVector</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>