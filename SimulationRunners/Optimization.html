<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>MAPLEAF.SimulationRunners.Optimization API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/SimulationRunners/Optimization.html">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.SimulationRunners.Optimization</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import importlib
from copy import deepcopy

import matplotlib.pyplot as plt
import re

from MAPLEAF.IO import SubDictReader, SimDefinition, subDictReader
from .SingleSimulations import runSimulation, Simulation, loadSimDefinition
from MAPLEAF.Utilities import evalExpression


__all__ = [ &#34;OptimizingSimRunner&#34; ]


def _computeCostFunction(simDefinition: SimDefinition, costFunctionDefinition: str):
    # Run the simulation
    stageFlights, logFilePaths = runSimulation(simDefinition=simDefinition, silent=True)

    # Evaluate the cost function
    if &#34;:&#34; in costFunctionDefinition:
        # Cost function is expected to be a custom function defined in an importable module
        modulePath, funcName = costFunctionDefinition.split(&#39;:&#39;)

        customModule = importlib.import_module(modulePath)
        customCostFunction = getattr(customModule, funcName)

        # Call the user&#39;s custom function, passing in the paths to all log files from the present run
        # User&#39;s function is expected to return a scalar value           
        return float( customCostFunction(logFilePaths) )

    else:
        # Cost function is expected to be an anonymous function defined in costFunctionDefinition
        topStageFlight = stageFlights[0]
        varVals = {
            &#34;flightTime&#34;:   topStageFlight.getFlightTime(),
            &#34;apogee&#34;:       topStageFlight.getApogee(),
            &#34;maxSpeed&#34;:     topStageFlight.getMaxSpeed(),
            &#34;maxHorizontalVel&#34;: topStageFlight.getMaxHorizontalVel(),
        }

        return evalExpression(costFunctionDefinition, varVals)


class OptimizingSimRunner():
    &#39;&#39;&#39;
        Glue code to make MAPLEAF serve as a metric/cost function calculator for particle-swarm optimization using PySwarms.
        Configurable using the top-level &#39;Optimization&#39; dictionary in .mapleaf files
    &#39;&#39;&#39;
    #### Initialization ####
    def __init__(self, simDefinitionFilePath=None, simDefinition=None, subDictReader = None, silent=False, parallel=False):
        &#39;&#39;&#39; 
            Pass in nProcesses &gt; 1 to run Optimization in parallel using [ray](https://github.com/ray-project/ray).
            At the time of this writing, Ray is not yet fully supported on Windows, so this option is intended primarily for Linux and Mac computers.
        &#39;&#39;&#39;
        self.silent = silent
        self.parallel = parallel
        if simDefinition != None or simDefinitionFilePath != None:
            simDefinition = loadSimDefinition(simDefinitionFilePath, simDefinition, silent)
            self.optimizationReader = SubDictReader(&#39;Optimization&#39;, simDefinition)

            if not silent:
                print(&#34;Particle Swarm Optimization&#34;)

            # Ensure no output is produced during each simulation (cost function evaluation)
            simDefinition.setValue(&#34;SimControl.plot&#34;, &#34;None&#34;)
            simDefinition.setValue(&#34;SimControl.RocketPlot&#34;, &#34;Off&#34;)
        else:
            if subDictReader == None:
                raise ValueError(&#39;subDictReader not initialized for a nested optimization&#39;)
            self.optimizationReader = subDictReader

        # Parse the simulation definition&#39;s Optimization dictionary, but don&#39;t run it yet
        self.costFunctionDefinition = self.optimizationReader.getString(&#34;costFunction&#34;)        
        self.varKeys, self.varNames, self.minVals, self.maxVals = self._loadIndependentVariables()
        self.dependentVars, self.dependentVarDefinitions = self._loadDependentVariables()
        self.optimizer, self.nIterations, self.showConvergence = self._createOptimizer()

    def _loadIndependentVariables(self):
        &#39;&#39;&#39; 
            Parses the independent variables section of Optimization dictionary.
            Returns four lists:

            * A list of string paths to the corresponding values in the simulation definition
            * Parameter names
            * A list of minimum parameter values
            * A list of maximum parameter values

            All lists are in corresponding order
        &#39;&#39;&#39;
        varKeys = []
        varNames = []
        minVals = []
        maxVals = []

        for key in self.optimizationReader.getSubKeys(&#34;IndependentVariables&#34;):
            # Value expected to be &#39;min &lt; key.Path &lt; max&#39;
            # Split into three parts using the &#39;&lt;&#39; characters
            strings = self.optimizationReader.getString(key).split(&#39;&lt;&#39;)

            if len(strings) != 3:
                # ERROR: too many or too few values
                raise ValueError(&#34;Parameters in the Optimization.IndependentVariables dictionary should be scalars and conform to the following format: &#39;[minValue] &lt; [path.To.Parameter] &lt; [maxValue]&#39; \
                                Problem key is {}, which has a value of {}&#34;.format(key, &#34; &#34;.join(strings)))
            
            # Remove spaces
            minVal, keyPath, maxVal = [ s.strip() for s in strings ]
            varName = key.split(&#39;.&#39;)[-1] # User&#39;s given name

            # Parse / Save
            varKeys.append(keyPath)
            varNames.append(varName)
            minVals.append(float(minVal))
            maxVals.append(float(maxVal))

        if not self.silent:
            # Output setup to console
            print(&#34;Independent Variables: &#34;)
            for i in range(len(varNames)):
                print(&#34;{} &lt; {} &lt; {}&#34;.format(minVals[i], varNames[i], maxVals[i]))
            print(&#34;&#34;)

        return varKeys, varNames, minVals, maxVals

    def _loadDependentVariables(self):
        &#39;&#39;&#39;
            Parses the dependent variables section of Optimization dictionary.
            Returns two lists:

            * A list of string paths to the corresponding values in the simulation definition
            * Dependent parameter names

            Both in corresponding order
        &#39;&#39;&#39;
        depVarNames = []
        depVarDefinitions = []

        for depVar in self.optimizationReader.getSubKeys(&#34;DependentVariables&#34;):
            # Value expected: [paramName]  [paramDefinitionString]
            depVarKey = re.sub(&#34;Optimization.*DependentVariables.&#34;, &#34;&#34;, depVar)
            depVarNames.append(depVarKey)
            depVarDefinitions.append(self.optimizationReader.getString(depVar))

        if not self.silent:
            # Output results to console
            print(&#34;Dependent variables:&#34;)
            for i in range(len(depVarNames)):
                print(&#34;{} = {}&#34;.format(depVarNames[i], depVarDefinitions[i]))
            print(&#34;&#34;)

        return depVarNames, depVarDefinitions

    def _createOptimizer(self):
        &#39;&#39;&#39; 
            Reads the Optimization.ParticleSwarm dictionary and creates a pyswarms.GlobalBestPSO object 
            Returns the Optimizer, the user&#39;s desired number of iterations, and showConvergence (bool)
        &#39;&#39;&#39;
        pathToParticleSwarmDict = self.optimizationReader.simDefDictPathToReadFrom + &#39;.ParticleSwarm&#39;
        pSwarmReader = SubDictReader(pathToParticleSwarmDict, self.optimizationReader.simDefinition)

        nParticles = pSwarmReader.tryGetInt(&#34;nParticles&#34;, defaultValue=20)
        nIterations = pSwarmReader.tryGetInt(&#34;nIterations&#34;, defaultValue=50)
        
        c1 = pSwarmReader.tryGetFloat(&#34;cognitiveParam&#34;, defaultValue=0.5)
        c2 = pSwarmReader.tryGetFloat(&#34;socialParam&#34;, defaultValue=0.6)
        w = pSwarmReader.tryGetFloat(&#34;inertiaParam&#34;, defaultValue=0.9)
        pySwarmOptions = { &#39;c1&#39;:c1, &#39;c2&#39;:c2, &#39;w&#39;:w }

        nVars = len(self.varNames)
        varBounds = (self.minVals, self.maxVals)

        from pyswarms.single import GlobalBestPSO # Import here because for most sims it&#39;s not required
        optimizer = GlobalBestPSO(nParticles, nVars, pySwarmOptions, bounds=varBounds)

        showConvergence = self.optimizationReader.tryGetBool(&#34;showConvergencePlot&#34;, defaultValue=False)

        if not self.silent:
            print(&#34;Optimization Parameters:&#34;)
            print(&#34;{} Particles&#34;.format(nParticles))
            print(&#34;{} Iterations&#34;.format(nIterations))
            print(&#34;c1 = {}, c2 = {}, w = {}\n&#34;.format(c1, c2, w))
            
            costFunctionDefinition = self.optimizationReader.getString(&#34;costFunction&#34;)
            print(&#34;Cost Function:&#34;)
            print(costFunctionDefinition + &#34;\n&#34;)

        return optimizer, nIterations, showConvergence

    #### Running the optimization ####
    def _computeCostFunctionValues_Parallel(self, trialSolutions) -&gt; float:
        &#39;&#39;&#39; Given a values the independent variable, returns the cost function value &#39;&#39;&#39;
        import ray
        _computeCostFunctionRemotely = ray.remote(_computeCostFunction)

        costFunctionValues = []
        
        nSims = len(trialSolutions)
        for i in range(nSims):
            indVarValues = trialSolutions[i]

            # Create new sim definition
            simDef = deepcopy(self.optimizationReader.simDefinition)
            
            # Update variable values
            varDict = self._updateIndependentVariableValues(simDef, indVarValues)
            self._updateDependentVariableValues(simDef, varDict)

            if self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39; in self.optimizationReader.getImmediateSubDicts():
                innerOptimizer = self._createNestedOptimization(simDef)
                cost, pos = innerOptimizer.runOptimization()
                varDict = innerOptimizer._updateIndependentVariableValues(simDef, pos)
                innerOptimizer._updateDependentVariableValues(simDef, varDict)   

            # Start the simulation and save the future returned
            costFunctionValues.append(_computeCostFunctionRemotely.remote(simDefinition=simDef, costFunctionDefinition=self.costFunctionDefinition))

        # All simulation now started, wait for and retrieve the results
        costFunctionValues = [ ray.get(value) for value in costFunctionValues ]

        return costFunctionValues

    def _computeCostFunctionValues_SingleThreaded(self, trialSolutions) -&gt; float:
        &#39;&#39;&#39; Given a values the independent variable, returns the cost function value &#39;&#39;&#39;
        costFunctionValues = []
        for indVarValues in trialSolutions:
            # Create new sim definition
            simDef = deepcopy(self.optimizationReader.simDefinition)
            
            # Update variable values
            varDict = self._updateIndependentVariableValues(simDef, indVarValues)
            self._updateDependentVariableValues(simDef, varDict)

            if self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39; in self.optimizationReader.getImmediateSubDicts():
                innerOptimizer = self._createNestedOptimization(simDef)
                cost, pos = innerOptimizer.runOptimization()
                varDict = innerOptimizer._updateIndependentVariableValues(simDef, pos)
                innerOptimizer._updateDependentVariableValues(simDef, varDict)   

            # Run the simulation and compute the cost function value, save the result
            costFunctionValues.append(_computeCostFunction(simDef, costFunctionDefinition=self.costFunctionDefinition))

        return costFunctionValues

    def _createNestedOptimization(self, simDef):
        innerOptimizationReader = SubDictReader(self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39;, simDef)
        return OptimizingSimRunner(subDictReader=innerOptimizationReader, silent=True, parallel=self.parallel)

    def _updateIndependentVariableValues(self, simDefinition, indVarValues):
        &#39;&#39;&#39; 
            Updates simDefinition with the independent variable values
            Returns a dictionary map of independent variable names mapped to their values, suitable for passing to eval
        &#39;&#39;&#39;
        # Independent variable values
        indVarValueDict = {}
        for i in range(len(indVarValues)):
            simDefinition.setValue(self.varKeys[i], str(indVarValues[i]))
            
            varName = self.varNames[i]
            indVarValueDict[varName] = indVarValues[i]

        return indVarValueDict

    def _updateDependentVariableValues(self, simDefinition, indVarValueDict):
        &#39;&#39;&#39; Set all the dependent variables defined in Optimization.DependentVariables in simDefinition. Each can be a function of the independent variable values in indVarValueDict &#39;&#39;&#39;
        
        for i in range(len(self.dependentVars)):
            # Take the definition string, split out the parts to be computed (delimited by exclamation marks)
                # &#34;(0 0 !a+b!)&#34; -&gt; [ &#34;(0 0&#34;, &#34;a+b&#34;, &#34;)&#34; ] -&gt; Need to evaluate all the odd-indexed values
            splitDepVarDef = self.dependentVarDefinitions[i].split(&#39;!&#39;)
            for j in range(1, len(splitDepVarDef), 2):
                functionValue = evalExpression(splitDepVarDef[j], indVarValueDict)
                # Overwrite the function definition with its string value
                splitDepVarDef[j] = str(functionValue)
            
            # Re-combine strings, save result
            depValue = &#34;&#34;.join(splitDepVarDef)
            simDefinition.setValue(self.dependentVars[i], depValue)

    #### Main Function ####
    def runOptimization(self):
        &#39;&#39;&#39; Run the Optimization and show convergence history &#39;&#39;&#39;
        if self.parallel:
            if self.optimizationReader.simDefDictPathToReadFrom == &#34;Optimization&#34;:
                # If this is an inner optimizaer, ray.init() will have already been called by the outer one(s)
                import ray
                ray.init()
                cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)
                ray.shutdown()
            else:
                cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)

        else:                
            cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_SingleThreaded, iters=self.nIterations)
        
        if self.showConvergence:
            print(&#34;Showing optimization convergence plot&#34;)

            # Show optimization history
            from pyswarms.utils.plotters import plot_cost_history
            plot_cost_history(self.optimizer.cost_history)
            plt.show()

        return cost, pos</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner"><code class="flex name class">
<span>class <span class="ident">OptimizingSimRunner</span></span>
<span>(</span><span>simDefinitionFilePath=None, simDefinition=None, subDictReader=None, silent=False, parallel=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Glue code to make MAPLEAF serve as a metric/cost function calculator for particle-swarm optimization using PySwarms.
Configurable using the top-level 'Optimization' dictionary in .mapleaf files</p>
<p>Pass in nProcesses &gt; 1 to run Optimization in parallel using <a href="https://github.com/ray-project/ray">ray</a>.
At the time of this writing, Ray is not yet fully supported on Windows, so this option is intended primarily for Linux and Mac computers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OptimizingSimRunner():
    &#39;&#39;&#39;
        Glue code to make MAPLEAF serve as a metric/cost function calculator for particle-swarm optimization using PySwarms.
        Configurable using the top-level &#39;Optimization&#39; dictionary in .mapleaf files
    &#39;&#39;&#39;
    #### Initialization ####
    def __init__(self, simDefinitionFilePath=None, simDefinition=None, subDictReader = None, silent=False, parallel=False):
        &#39;&#39;&#39; 
            Pass in nProcesses &gt; 1 to run Optimization in parallel using [ray](https://github.com/ray-project/ray).
            At the time of this writing, Ray is not yet fully supported on Windows, so this option is intended primarily for Linux and Mac computers.
        &#39;&#39;&#39;
        self.silent = silent
        self.parallel = parallel
        if simDefinition != None or simDefinitionFilePath != None:
            simDefinition = loadSimDefinition(simDefinitionFilePath, simDefinition, silent)
            self.optimizationReader = SubDictReader(&#39;Optimization&#39;, simDefinition)

            if not silent:
                print(&#34;Particle Swarm Optimization&#34;)

            # Ensure no output is produced during each simulation (cost function evaluation)
            simDefinition.setValue(&#34;SimControl.plot&#34;, &#34;None&#34;)
            simDefinition.setValue(&#34;SimControl.RocketPlot&#34;, &#34;Off&#34;)
        else:
            if subDictReader == None:
                raise ValueError(&#39;subDictReader not initialized for a nested optimization&#39;)
            self.optimizationReader = subDictReader

        # Parse the simulation definition&#39;s Optimization dictionary, but don&#39;t run it yet
        self.costFunctionDefinition = self.optimizationReader.getString(&#34;costFunction&#34;)        
        self.varKeys, self.varNames, self.minVals, self.maxVals = self._loadIndependentVariables()
        self.dependentVars, self.dependentVarDefinitions = self._loadDependentVariables()
        self.optimizer, self.nIterations, self.showConvergence = self._createOptimizer()

    def _loadIndependentVariables(self):
        &#39;&#39;&#39; 
            Parses the independent variables section of Optimization dictionary.
            Returns four lists:

            * A list of string paths to the corresponding values in the simulation definition
            * Parameter names
            * A list of minimum parameter values
            * A list of maximum parameter values

            All lists are in corresponding order
        &#39;&#39;&#39;
        varKeys = []
        varNames = []
        minVals = []
        maxVals = []

        for key in self.optimizationReader.getSubKeys(&#34;IndependentVariables&#34;):
            # Value expected to be &#39;min &lt; key.Path &lt; max&#39;
            # Split into three parts using the &#39;&lt;&#39; characters
            strings = self.optimizationReader.getString(key).split(&#39;&lt;&#39;)

            if len(strings) != 3:
                # ERROR: too many or too few values
                raise ValueError(&#34;Parameters in the Optimization.IndependentVariables dictionary should be scalars and conform to the following format: &#39;[minValue] &lt; [path.To.Parameter] &lt; [maxValue]&#39; \
                                Problem key is {}, which has a value of {}&#34;.format(key, &#34; &#34;.join(strings)))
            
            # Remove spaces
            minVal, keyPath, maxVal = [ s.strip() for s in strings ]
            varName = key.split(&#39;.&#39;)[-1] # User&#39;s given name

            # Parse / Save
            varKeys.append(keyPath)
            varNames.append(varName)
            minVals.append(float(minVal))
            maxVals.append(float(maxVal))

        if not self.silent:
            # Output setup to console
            print(&#34;Independent Variables: &#34;)
            for i in range(len(varNames)):
                print(&#34;{} &lt; {} &lt; {}&#34;.format(minVals[i], varNames[i], maxVals[i]))
            print(&#34;&#34;)

        return varKeys, varNames, minVals, maxVals

    def _loadDependentVariables(self):
        &#39;&#39;&#39;
            Parses the dependent variables section of Optimization dictionary.
            Returns two lists:

            * A list of string paths to the corresponding values in the simulation definition
            * Dependent parameter names

            Both in corresponding order
        &#39;&#39;&#39;
        depVarNames = []
        depVarDefinitions = []

        for depVar in self.optimizationReader.getSubKeys(&#34;DependentVariables&#34;):
            # Value expected: [paramName]  [paramDefinitionString]
            depVarKey = re.sub(&#34;Optimization.*DependentVariables.&#34;, &#34;&#34;, depVar)
            depVarNames.append(depVarKey)
            depVarDefinitions.append(self.optimizationReader.getString(depVar))

        if not self.silent:
            # Output results to console
            print(&#34;Dependent variables:&#34;)
            for i in range(len(depVarNames)):
                print(&#34;{} = {}&#34;.format(depVarNames[i], depVarDefinitions[i]))
            print(&#34;&#34;)

        return depVarNames, depVarDefinitions

    def _createOptimizer(self):
        &#39;&#39;&#39; 
            Reads the Optimization.ParticleSwarm dictionary and creates a pyswarms.GlobalBestPSO object 
            Returns the Optimizer, the user&#39;s desired number of iterations, and showConvergence (bool)
        &#39;&#39;&#39;
        pathToParticleSwarmDict = self.optimizationReader.simDefDictPathToReadFrom + &#39;.ParticleSwarm&#39;
        pSwarmReader = SubDictReader(pathToParticleSwarmDict, self.optimizationReader.simDefinition)

        nParticles = pSwarmReader.tryGetInt(&#34;nParticles&#34;, defaultValue=20)
        nIterations = pSwarmReader.tryGetInt(&#34;nIterations&#34;, defaultValue=50)
        
        c1 = pSwarmReader.tryGetFloat(&#34;cognitiveParam&#34;, defaultValue=0.5)
        c2 = pSwarmReader.tryGetFloat(&#34;socialParam&#34;, defaultValue=0.6)
        w = pSwarmReader.tryGetFloat(&#34;inertiaParam&#34;, defaultValue=0.9)
        pySwarmOptions = { &#39;c1&#39;:c1, &#39;c2&#39;:c2, &#39;w&#39;:w }

        nVars = len(self.varNames)
        varBounds = (self.minVals, self.maxVals)

        from pyswarms.single import GlobalBestPSO # Import here because for most sims it&#39;s not required
        optimizer = GlobalBestPSO(nParticles, nVars, pySwarmOptions, bounds=varBounds)

        showConvergence = self.optimizationReader.tryGetBool(&#34;showConvergencePlot&#34;, defaultValue=False)

        if not self.silent:
            print(&#34;Optimization Parameters:&#34;)
            print(&#34;{} Particles&#34;.format(nParticles))
            print(&#34;{} Iterations&#34;.format(nIterations))
            print(&#34;c1 = {}, c2 = {}, w = {}\n&#34;.format(c1, c2, w))
            
            costFunctionDefinition = self.optimizationReader.getString(&#34;costFunction&#34;)
            print(&#34;Cost Function:&#34;)
            print(costFunctionDefinition + &#34;\n&#34;)

        return optimizer, nIterations, showConvergence

    #### Running the optimization ####
    def _computeCostFunctionValues_Parallel(self, trialSolutions) -&gt; float:
        &#39;&#39;&#39; Given a values the independent variable, returns the cost function value &#39;&#39;&#39;
        import ray
        _computeCostFunctionRemotely = ray.remote(_computeCostFunction)

        costFunctionValues = []
        
        nSims = len(trialSolutions)
        for i in range(nSims):
            indVarValues = trialSolutions[i]

            # Create new sim definition
            simDef = deepcopy(self.optimizationReader.simDefinition)
            
            # Update variable values
            varDict = self._updateIndependentVariableValues(simDef, indVarValues)
            self._updateDependentVariableValues(simDef, varDict)

            if self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39; in self.optimizationReader.getImmediateSubDicts():
                innerOptimizer = self._createNestedOptimization(simDef)
                cost, pos = innerOptimizer.runOptimization()
                varDict = innerOptimizer._updateIndependentVariableValues(simDef, pos)
                innerOptimizer._updateDependentVariableValues(simDef, varDict)   

            # Start the simulation and save the future returned
            costFunctionValues.append(_computeCostFunctionRemotely.remote(simDefinition=simDef, costFunctionDefinition=self.costFunctionDefinition))

        # All simulation now started, wait for and retrieve the results
        costFunctionValues = [ ray.get(value) for value in costFunctionValues ]

        return costFunctionValues

    def _computeCostFunctionValues_SingleThreaded(self, trialSolutions) -&gt; float:
        &#39;&#39;&#39; Given a values the independent variable, returns the cost function value &#39;&#39;&#39;
        costFunctionValues = []
        for indVarValues in trialSolutions:
            # Create new sim definition
            simDef = deepcopy(self.optimizationReader.simDefinition)
            
            # Update variable values
            varDict = self._updateIndependentVariableValues(simDef, indVarValues)
            self._updateDependentVariableValues(simDef, varDict)

            if self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39; in self.optimizationReader.getImmediateSubDicts():
                innerOptimizer = self._createNestedOptimization(simDef)
                cost, pos = innerOptimizer.runOptimization()
                varDict = innerOptimizer._updateIndependentVariableValues(simDef, pos)
                innerOptimizer._updateDependentVariableValues(simDef, varDict)   

            # Run the simulation and compute the cost function value, save the result
            costFunctionValues.append(_computeCostFunction(simDef, costFunctionDefinition=self.costFunctionDefinition))

        return costFunctionValues

    def _createNestedOptimization(self, simDef):
        innerOptimizationReader = SubDictReader(self.optimizationReader.simDefDictPathToReadFrom + &#39;.InnerOptimization&#39;, simDef)
        return OptimizingSimRunner(subDictReader=innerOptimizationReader, silent=True, parallel=self.parallel)

    def _updateIndependentVariableValues(self, simDefinition, indVarValues):
        &#39;&#39;&#39; 
            Updates simDefinition with the independent variable values
            Returns a dictionary map of independent variable names mapped to their values, suitable for passing to eval
        &#39;&#39;&#39;
        # Independent variable values
        indVarValueDict = {}
        for i in range(len(indVarValues)):
            simDefinition.setValue(self.varKeys[i], str(indVarValues[i]))
            
            varName = self.varNames[i]
            indVarValueDict[varName] = indVarValues[i]

        return indVarValueDict

    def _updateDependentVariableValues(self, simDefinition, indVarValueDict):
        &#39;&#39;&#39; Set all the dependent variables defined in Optimization.DependentVariables in simDefinition. Each can be a function of the independent variable values in indVarValueDict &#39;&#39;&#39;
        
        for i in range(len(self.dependentVars)):
            # Take the definition string, split out the parts to be computed (delimited by exclamation marks)
                # &#34;(0 0 !a+b!)&#34; -&gt; [ &#34;(0 0&#34;, &#34;a+b&#34;, &#34;)&#34; ] -&gt; Need to evaluate all the odd-indexed values
            splitDepVarDef = self.dependentVarDefinitions[i].split(&#39;!&#39;)
            for j in range(1, len(splitDepVarDef), 2):
                functionValue = evalExpression(splitDepVarDef[j], indVarValueDict)
                # Overwrite the function definition with its string value
                splitDepVarDef[j] = str(functionValue)
            
            # Re-combine strings, save result
            depValue = &#34;&#34;.join(splitDepVarDef)
            simDefinition.setValue(self.dependentVars[i], depValue)

    #### Main Function ####
    def runOptimization(self):
        &#39;&#39;&#39; Run the Optimization and show convergence history &#39;&#39;&#39;
        if self.parallel:
            if self.optimizationReader.simDefDictPathToReadFrom == &#34;Optimization&#34;:
                # If this is an inner optimizaer, ray.init() will have already been called by the outer one(s)
                import ray
                ray.init()
                cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)
                ray.shutdown()
            else:
                cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)

        else:                
            cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_SingleThreaded, iters=self.nIterations)
        
        if self.showConvergence:
            print(&#34;Showing optimization convergence plot&#34;)

            # Show optimization history
            from pyswarms.utils.plotters import plot_cost_history
            plot_cost_history(self.optimizer.cost_history)
            plt.show()

        return cost, pos</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner.runOptimization"><code class="name flex">
<span>def <span class="ident">runOptimization</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the Optimization and show convergence history</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runOptimization(self):
    &#39;&#39;&#39; Run the Optimization and show convergence history &#39;&#39;&#39;
    if self.parallel:
        if self.optimizationReader.simDefDictPathToReadFrom == &#34;Optimization&#34;:
            # If this is an inner optimizaer, ray.init() will have already been called by the outer one(s)
            import ray
            ray.init()
            cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)
            ray.shutdown()
        else:
            cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_Parallel, iters=self.nIterations)

    else:                
        cost, pos = self.optimizer.optimize(self._computeCostFunctionValues_SingleThreaded, iters=self.nIterations)
    
    if self.showConvergence:
        print(&#34;Showing optimization convergence plot&#34;)

        # Show optimization history
        from pyswarms.utils.plotters import plot_cost_history
        plot_cost_history(self.optimizer.cost_history)
        plt.show()

    return cost, pos</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.SimulationRunners" href="index.html">MAPLEAF.SimulationRunners</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner" href="#MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner">OptimizingSimRunner</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner.runOptimization" href="#MAPLEAF.SimulationRunners.Optimization.OptimizingSimRunner.runOptimization">runOptimization</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>