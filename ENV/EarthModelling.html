<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>MAPLEAF.ENV.EarthModelling API documentation</title>
<meta name="description" content="These classes model the earth&#39;s gravity and perform some coordinate transformations between the global inertial frame and the ENU/launch tower frame" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:20%;max-height:5em;margin:auto;margin-bottom:.3em}</style>
<link rel="canonical" href="https://pdoc3.github.io/pdoc/doc/MAPLEAF/ENV/EarthModelling.html">
<link rel="icon" href="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MAPLEAF.ENV.EarthModelling</code></h1>
</header>
<section id="section-intro">
<p>These classes model the earth's gravity and perform some coordinate transformations between the global inertial frame and the ENU/launch tower frame</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39; These classes model the earth&#39;s gravity and perform some coordinate transformations between the global inertial frame and the ENU/launch tower frame &#39;&#39;&#39;

from abc import ABC, abstractmethod
from math import atan2, cos, degrees, pi, radians, sin, sqrt
from typing import Union

import numpy as np

from MAPLEAF.IO import getAbsoluteFilePath
from MAPLEAF.Motion import (Inertia, Quaternion, RigidBodyState,
                            RigidBodyState_3DoF, Vector)

__all__ = [ &#34;earthModelFactory&#34;, &#34;NoEarth&#34;, &#34;FlatEarth&#34;, &#34;SphericalEarth&#34;, &#34;WGS84&#34; ]

class EarthModel(ABC):
    &#39;&#39;&#39; Interface for all earth models &#39;&#39;&#39;
    # All earth models will have these default values
    rotationRate = 0

    @abstractmethod
    def getGravityForce(self, inertia: Inertia, state: Union[RigidBodyState, RigidBodyState_3DoF]) -&gt; Vector:
        &#39;&#39;&#39; Return gravity force vector in the global inertial frame &#39;&#39;&#39;
        return

    @abstractmethod
    def getInertialToENUFrameRotation(self, x: float, y: float, z: float) -&gt; Quaternion:
        &#39;&#39;&#39; 
            Return Quaternion defining the rotation from the global inertial frame 
            to the North-East-Up frame defined on the surface under the air vehicle&#39;s position
        &#39;&#39;&#39;
        return

    def getInertialToNEDFrameRotation(self, x, y, z):
        inertialToENURotation = self.getInertialToENUFrameRotation(x, y, z)
        ENUToNED = Quaternion(axisOfRotation=Vector(1,1,0), angle=pi)
        return inertialToENURotation * ENUToNED

    @abstractmethod
    def getAltitude(self, x: float, y: float, z: float) -&gt; float:
        &#39;&#39;&#39; Given the aircraft coordinates in the global inertial frame, should return the altitude above SEA level (ASL) - to be used in wind calculations &#39;&#39;&#39;
        return

    def convertIntoGlobalFrame(self, 
        launchTowerFrameState: Union[RigidBodyState, RigidBodyState_3DoF], 
        latitude: float, 
        longitude: float, 
    ) -&gt; Union[RigidBodyState, RigidBodyState_3DoF]:
        &#39;&#39;&#39; 
            Should take a RigidBodyState defined in the launch tower frame (fixed to the earth&#39;s surface), where 
            position.Z has been redefined relative to sea level (instead of ground-level), and convert it into
            the global inertial frame.
            Exception is the Angular Velocity, since it is defined in the vehicle&#39;s local frame. If the earth model is
                rotating, add the earth&#39;s angular velocity to it (after conversion into the local frame)
        &#39;&#39;&#39;
        return

def earthModelFactory(envDictReader=None) -&gt; EarthModel:
    &#39;&#39;&#39; Provide an envDictReader (`MAPLEAF.IO.SubDictReader`). If none is provided, returns a FlatEarth model &#39;&#39;&#39;
    if envDictReader == None:
        return FlatEarth()

    earthModel = envDictReader.getString(&#34;EarthModel&#34;)

    if earthModel == &#34;Flat&#34;:
        return FlatEarth()
    elif earthModel == &#34;Round&#34;:
        return SphericalEarth()
    elif earthModel == &#34;WGS84&#34;:
        return WGS84()
    elif earthModel == &#34;None&#34;:
        return NoEarth()
    else:
        raise NotImplementedError(&#34;Earth model: {} not found. Try &#39;Flat&#39;, &#39;Round&#39; or &#39;WGS84&#39;&#34;.format(earthModel))

class NoEarth(EarthModel):
    rotationRate = 0 # rad/s
    noRotation = Quaternion(1,0,0,0)
    noForce = Vector(0,0,0)

    def getGravityForce(self, inertia, state):
        return self.noForce

    def getInertialToENUFrameRotation(self, x, y, z):
        return self.noRotation

    def getAltitude(self, x, y, z):
        return z

    def convertIntoGlobalFrame(self, launchTowerFrameState, _, __):
        &#39;&#39;&#39; Launch tower frame is global inertial frame &#39;&#39;&#39;
        return launchTowerFrameState

class FlatEarth(NoEarth):
    # GM = 398600.5 # km^3/s^2 Geocentric gravitational constant (Mass of atmosphere included)
    GM = 398600.5e9 # m^3/s^2

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
        gravityDirection = Vector(0, 0, -1) # Down in the launch tower frame

        distanceFromCenterOfEarth = state.position.Z + 6371000 # Adding earth&#39;s average radius
        gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
            # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

        return gravityMagnitude * gravityDirection

class SphericalEarth(EarthModel):
    &#39;&#39;&#39; Models a non-rotating, uniform, spherical earth &#39;&#39;&#39;
    radius = 6371007.1809 # m - from NESC-RP-12-007770, Volume II
    rotationRate = 7.292115e-5 # rad/s angular velocity - from WGS84 model. Defined WRT stars (not our sun)
    # GM = 398600.5 # km^3/s^2 Geocentric gravitational constant (Mass of atmosphere included)
    GM = 3.98600436e14 # m^3/s^2- from NESC-RP-12-007770, Volume II

    def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
        &#39;&#39;&#39;
            Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
            
            Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
                the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system

            Inputs:
                lat:    (float) latitude - degrees
                lon:    (float) longitude - degrees
                height: (float) ASL (usually m)

            Returns:
                x:      (float) meters, relative to center of sphere
                y:      &#39; &#39;
                z:      &#39; &#39;
        &#39;&#39;&#39;
        lat = radians(lat)
        lon = radians(lon)

        # Adjust for rotation rate
        lon += self.rotationRate * timeOffset

        radius = self.radius + height

        x = radius * cos(lat) * cos(lon)
        y = radius * cos(lat) * sin(lon)
        z = radius * sin(lat)
        return x, y, z

    def cartesianToGeodetic(self, x, y, z, timeOffset=0):
        &#39;&#39;&#39; Convert from cartesian to lat/lon/height coordinates, where height is ASL &#39;&#39;&#39;
        p = sqrt(x*x + y*y)
        
        lon = atan2(y, x)

        # Adjust for rotation rate
        lon -= self.rotationRate * timeOffset

        lat = atan2(z, p)
        height = sqrt(x*x + y*y + z*z) - self.radius
        
        return degrees(lat), degrees(lon), height

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
        gravityDirection = -(state.position.normalize()) # Gravity pulls toward the earth&#39;s center of mass, which is the origin
        
        distanceFromCenterOfEarth = state.position.length()
        gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
            # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

        return gravityMagnitude * gravityDirection

    def getInertialToENUFrameRotation(self, x, y, z):
        &#39;&#39;&#39; Returns a Quaternion that defines the rotation b/w the global inertia frame and the local, surface-normal North-East-Up (y-x-z) frame &#39;&#39;&#39;
        # Time offset not necessary, since the x, y, z coordinates are inertial, and we are not 
            # interested in finding a particular location on the surface of the earth,
            # we are just interested in finding the surface normal under a x/y/z location. 
            # The result is independent of the earth&#39;s rotation.
        lat, lon, height = self.cartesianToGeodetic(x, y, z)

        # Rotation between inertial frame and ENU frame will be composed in two steps
        # Step 1: Rotate about inertial/initial Z-axis to Y-axis in such a way, that after rotation 2, 
            # it will be pointing North
        rot1Angle = radians(lon + 90)
        rot1 = Quaternion(axisOfRotation=Vector(0,0,1), angle=rot1Angle)
        
        # Step 2: Rotate about the local x-axis to match the latitude
        rot2Angle = radians(90 - lat)
        rot2 = Quaternion(axisOfRotation=Vector(1,0,0), angle=rot2Angle)

        # Sequentially combine rotations by multiplying them
        return rot1 * rot2

    def getAltitude(self, x, y, z):
        # Height is independent of the earth&#39;s rotation
        _, __, height = self.cartesianToGeodetic(x, y, z)
        return height

    def convertIntoGlobalFrame(self, launchTowerFrameState, lat, lon):
        ### Position ###
        height = launchTowerFrameState.position.Z # ASL altitude
        globalFramePosition = Vector(*self.geodeticToCartesian(lat, lon, height))
        
        ### Velocity ###
        # Find orientation of launch tower frame relative to global frame
        launchTowerToGlobalFrame = self.getInertialToENUFrameRotation(*globalFramePosition)

        # Rotate velocity accordingly
        rotatedVelocity = launchTowerToGlobalFrame.rotate(launchTowerFrameState.velocity)
        # Add earth&#39;s surface velocity
        earthAngVel = Vector(0, 0, self.rotationRate)
        velocityDueToEarthRotation = earthAngVel.crossProduct(globalFramePosition)
        globalFrameVelocity = rotatedVelocity + velocityDueToEarthRotation

        try:  # 6DoF Case           
            ### Orientation ###
            globalFrameOrientation = launchTowerToGlobalFrame * launchTowerFrameState.orientation

            ### Angular Velocity ###
            # Angular velocity is defined in the vehicle&#39;s local frame, so the conversion needs to go the other way
            earthAngVel_RocketFrame = globalFrameOrientation.conjugate().rotate(earthAngVel)
            localFrame_adjustedAngVel = launchTowerFrameState.angularVelocity + earthAngVel_RocketFrame

            return RigidBodyState( 
                globalFramePosition, 
                globalFrameVelocity, 
                globalFrameOrientation, 
                localFrame_adjustedAngVel
                )
        
        except AttributeError: # 3DoF Case
            return RigidBodyState_3DoF(globalFramePosition, globalFrameVelocity)             

class WGS84(SphericalEarth):
    &#39;&#39;&#39; 
        Models a rotating, ellipsoid earth, with non-uniform gravity 
        Inherits the getInertialToENUFrameRotation function from SphericalEarth, otherwise overrides everything
    &#39;&#39;&#39;
    # Set up/calculate the WGS84 Ellipsoid parameters and derived values
    a = 6378137             # m, semi-major axis
    f = 1/298.257223563     # Flattening (derived from C_20)
    b = a * (1-f)           # m, semi-minor axis = 6 356 752.314 140
    e2 = f*(2-f)            # First eccentricity squared (e^2) = 6.694 379 990 14 e-3
    eP2 = e2 / ((1-f)**2)   # Second eccentricity squared (e&#39;^2) = 6.739 496 742 28 e-3s
    eP = sqrt(eP2)          # Second eccentricity (e&#39;)

    def __init__(self):
        # Read gravity coefficients from table
        # Columns are: Degree Order C S (Where C and S are the coefficients)
        coeffPath = getAbsoluteFilePath(&#39;./MAPLEAF/ENV/sphericalHarmonicGravityCoeffs.txt&#39;)
        gravityCoeffs = np.loadtxt(coeffPath, skiprows=2)
        
        # Convert that table into nested dictionary form, to make C and S coefficients easily accessible by degree and order
        Ccoeffs = {}
        Scoeffs = {}
        for row in gravityCoeffs:
            degree, order, C, S, = row
            
            if degree not in Ccoeffs:
                # Create subdictionary for each degree if this is the first time we&#39;re encountering that degree
                Ccoeffs[degree] = {}
                Scoeffs[degree] = {}

            # Save coefficient from this row
            Ccoeffs[degree][order] = C
            Scoeffs[degree][order] = S

        # Save results
        # Now C_{2,3} is accessible as self.C[2][3], same for self.S
        self.C = Ccoeffs
        self.S = Scoeffs

    def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
        &#39;&#39;&#39;        
            Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
            
            Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
                the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system
            
            Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

            Note: In other references, it is common to set \phi = lat, \lamda = lon

            Inputs:
                lat:        (float) latitude - degrees
                lon:        (float) longitude - degrees
                height:     (float) ASL - m
                timeOffset  (float) Offset added to results based on earth&#39;s rotation rate.
                                At timeOffset=0, this inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

            Returns:
                x:      (float) meters, relative to center of ellipsoid
                y:      &#39; &#39;
                z:      &#39; &#39;
        &#39;&#39;&#39;
        lat = radians(lat)
        lon = radians(lon)

        # Adjust for earth&#39;s rate of rotation
        lon += self.rotationRate * timeOffset

        N = self.a / sqrt(1 - self.e2*sin(lat)**2)

        x = (N + height)*cos(lat)*cos(lon)
        y = (N + height)*cos(lat)*sin(lon)
        z = ((self.b**2 / self.a**2)*N + height) * sin(lat)

        return x, y, z

    def cartesianToGeodetic(self, x, y, z, timeOffset=0):
        &#39;&#39;&#39;
            Inputs in m, sec
            Convert from earth-centered inertial coordinates to WGS84 geodetic coordinates
            Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

            At timeOffset=0, the inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

            Returns latitude, longitude, height in degrees, m
        &#39;&#39;&#39;
        lon = atan2(y, x) # Longitude is easy to find

        # Adjust longitude for earth&#39;s rotation
        lon -= self.rotationRate * timeOffset

        ### Compute latitude and height normal to surface w/ Newton-Raphson method ###
        p = sqrt(x*x + y*y)
        Kold = 1/(1 - self.e2)
        Korig = Kold

        while True:
            ci = ((p*p + (1-self.e2)*z*z * Kold**2)**(1.5)) / (self.a * self.e2)
            Knew = 1 + (p*p + (1 - self.e2)*z*z * Kold**3) / (ci - p*p)
            
            # End iterations once delta per iteration &lt; 1e-10
            if abs(Knew - Kold) &lt; 1e-10:
                break

            Kold = Knew

        k = Knew

        lat = atan2(k*z, p)

        h = (1/self.e2)*(1/k - 1/Korig)*sqrt(p*p + z*z*k*k)

        return degrees(lat), degrees(lon), h

    # Re-use conversions to/from spherical coordinates from SphericalEarth
        # Useful for Spherical Harmonic Gravity model calculations, which are performed in spherical coordinates
    cartesianToSpherical = SphericalEarth.cartesianToGeodetic
    sphericalToCartesian = SphericalEarth.geodeticToCartesian

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; 
            Get gravity using the J2 model (just a single spherical harmonic coefficient accounting for the earth&#39;s oblateness) 
            Method from NESC-RP-12-00770, Volume II, pg.51, Eqn 29-31
        &#39;&#39;&#39;
        # J2 Model just uses the first spherical harmonic coefficient
        J2 = 0.00108262982
        re = self.a # Equatorial radius (Semi-major axis of ellipsoid)

        x, y, z = state.position[0], state.position[1], state.position[2]
        r = state.position.length()
        
        mu = self.GM

        # Precompute common parts of equation
        frac = (3*J2 * re*re) / (2 * r**4)
        multiplier = -mu*inertia.mass / r**3

        xForce = x * multiplier * (1 - frac*(5*z*z - r*r))
        yForce = y * multiplier * (1 - frac*(5*z*z - r*r))
        zForce = z * multiplier * (1 - frac*(5*z*z - 3*r*r))

        return Vector(xForce, yForce, zForce)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.earthModelFactory"><code class="name flex">
<span>def <span class="ident">earthModelFactory</span></span>(<span>envDictReader=None) ‑> MAPLEAF.ENV.EarthModelling.EarthModel</span>
</code></dt>
<dd>
<div class="desc"><p>Provide an envDictReader (<code><a title="MAPLEAF.IO.SubDictReader" href="../IO/index.html#MAPLEAF.IO.SubDictReader">SubDictReader</a></code>). If none is provided, returns a FlatEarth model</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def earthModelFactory(envDictReader=None) -&gt; EarthModel:
    &#39;&#39;&#39; Provide an envDictReader (`MAPLEAF.IO.SubDictReader`). If none is provided, returns a FlatEarth model &#39;&#39;&#39;
    if envDictReader == None:
        return FlatEarth()

    earthModel = envDictReader.getString(&#34;EarthModel&#34;)

    if earthModel == &#34;Flat&#34;:
        return FlatEarth()
    elif earthModel == &#34;Round&#34;:
        return SphericalEarth()
    elif earthModel == &#34;WGS84&#34;:
        return WGS84()
    elif earthModel == &#34;None&#34;:
        return NoEarth()
    else:
        raise NotImplementedError(&#34;Earth model: {} not found. Try &#39;Flat&#39;, &#39;Round&#39; or &#39;WGS84&#39;&#34;.format(earthModel))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.FlatEarth"><code class="flex name class">
<span>class <span class="ident">FlatEarth</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface for all earth models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlatEarth(NoEarth):
    # GM = 398600.5 # km^3/s^2 Geocentric gravitational constant (Mass of atmosphere included)
    GM = 398600.5e9 # m^3/s^2

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
        gravityDirection = Vector(0, 0, -1) # Down in the launch tower frame

        distanceFromCenterOfEarth = state.position.Z + 6371000 # Adding earth&#39;s average radius
        gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
            # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

        return gravityMagnitude * gravityDirection</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.EarthModelling.NoEarth" href="#MAPLEAF.ENV.EarthModelling.NoEarth">NoEarth</a></li>
<li>MAPLEAF.ENV.EarthModelling.EarthModel</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.FlatEarth.GM"><code class="name">var <span class="ident">GM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.FlatEarth.getGravityForce"><code class="name flex">
<span>def <span class="ident">getGravityForce</span></span>(<span>self, inertia, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a gravity force vector in the global frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGravityForce(self, inertia, state):
    &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
    gravityDirection = Vector(0, 0, -1) # Down in the launch tower frame

    distanceFromCenterOfEarth = state.position.Z + 6371000 # Adding earth&#39;s average radius
    gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
        # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

    return gravityMagnitude * gravityDirection</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.ENV.EarthModelling.NoEarth" href="#MAPLEAF.ENV.EarthModelling.NoEarth">NoEarth</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.convertIntoGlobalFrame" href="#MAPLEAF.ENV.EarthModelling.NoEarth.convertIntoGlobalFrame">convertIntoGlobalFrame</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.getAltitude" href="#MAPLEAF.ENV.EarthModelling.NoEarth.getAltitude">getAltitude</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.getInertialToENUFrameRotation" href="#MAPLEAF.ENV.EarthModelling.NoEarth.getInertialToENUFrameRotation">getInertialToENUFrameRotation</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth"><code class="flex name class">
<span>class <span class="ident">NoEarth</span></span>
</code></dt>
<dd>
<div class="desc"><p>Interface for all earth models</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoEarth(EarthModel):
    rotationRate = 0 # rad/s
    noRotation = Quaternion(1,0,0,0)
    noForce = Vector(0,0,0)

    def getGravityForce(self, inertia, state):
        return self.noForce

    def getInertialToENUFrameRotation(self, x, y, z):
        return self.noRotation

    def getAltitude(self, x, y, z):
        return z

    def convertIntoGlobalFrame(self, launchTowerFrameState, _, __):
        &#39;&#39;&#39; Launch tower frame is global inertial frame &#39;&#39;&#39;
        return launchTowerFrameState</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>MAPLEAF.ENV.EarthModelling.EarthModel</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.EarthModelling.FlatEarth" href="#MAPLEAF.ENV.EarthModelling.FlatEarth">FlatEarth</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.noForce"><code class="name">var <span class="ident">noForce</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.noRotation"><code class="name">var <span class="ident">noRotation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.rotationRate"><code class="name">var <span class="ident">rotationRate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.convertIntoGlobalFrame"><code class="name flex">
<span>def <span class="ident">convertIntoGlobalFrame</span></span>(<span>self, launchTowerFrameState, _, __)</span>
</code></dt>
<dd>
<div class="desc"><p>Launch tower frame is global inertial frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertIntoGlobalFrame(self, launchTowerFrameState, _, __):
    &#39;&#39;&#39; Launch tower frame is global inertial frame &#39;&#39;&#39;
    return launchTowerFrameState</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.getAltitude"><code class="name flex">
<span>def <span class="ident">getAltitude</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the aircraft coordinates in the global inertial frame, should return the altitude above SEA level (ASL) - to be used in wind calculations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAltitude(self, x, y, z):
    return z</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.getGravityForce"><code class="name flex">
<span>def <span class="ident">getGravityForce</span></span>(<span>self, inertia, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Return gravity force vector in the global inertial frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGravityForce(self, inertia, state):
    return self.noForce</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.NoEarth.getInertialToENUFrameRotation"><code class="name flex">
<span>def <span class="ident">getInertialToENUFrameRotation</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Return Quaternion defining the rotation from the global inertial frame
to the North-East-Up frame defined on the surface under the air vehicle's position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertialToENUFrameRotation(self, x, y, z):
    return self.noRotation</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth"><code class="flex name class">
<span>class <span class="ident">SphericalEarth</span></span>
</code></dt>
<dd>
<div class="desc"><p>Models a non-rotating, uniform, spherical earth</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SphericalEarth(EarthModel):
    &#39;&#39;&#39; Models a non-rotating, uniform, spherical earth &#39;&#39;&#39;
    radius = 6371007.1809 # m - from NESC-RP-12-007770, Volume II
    rotationRate = 7.292115e-5 # rad/s angular velocity - from WGS84 model. Defined WRT stars (not our sun)
    # GM = 398600.5 # km^3/s^2 Geocentric gravitational constant (Mass of atmosphere included)
    GM = 3.98600436e14 # m^3/s^2- from NESC-RP-12-007770, Volume II

    def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
        &#39;&#39;&#39;
            Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
            
            Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
                the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system

            Inputs:
                lat:    (float) latitude - degrees
                lon:    (float) longitude - degrees
                height: (float) ASL (usually m)

            Returns:
                x:      (float) meters, relative to center of sphere
                y:      &#39; &#39;
                z:      &#39; &#39;
        &#39;&#39;&#39;
        lat = radians(lat)
        lon = radians(lon)

        # Adjust for rotation rate
        lon += self.rotationRate * timeOffset

        radius = self.radius + height

        x = radius * cos(lat) * cos(lon)
        y = radius * cos(lat) * sin(lon)
        z = radius * sin(lat)
        return x, y, z

    def cartesianToGeodetic(self, x, y, z, timeOffset=0):
        &#39;&#39;&#39; Convert from cartesian to lat/lon/height coordinates, where height is ASL &#39;&#39;&#39;
        p = sqrt(x*x + y*y)
        
        lon = atan2(y, x)

        # Adjust for rotation rate
        lon -= self.rotationRate * timeOffset

        lat = atan2(z, p)
        height = sqrt(x*x + y*y + z*z) - self.radius
        
        return degrees(lat), degrees(lon), height

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
        gravityDirection = -(state.position.normalize()) # Gravity pulls toward the earth&#39;s center of mass, which is the origin
        
        distanceFromCenterOfEarth = state.position.length()
        gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
            # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

        return gravityMagnitude * gravityDirection

    def getInertialToENUFrameRotation(self, x, y, z):
        &#39;&#39;&#39; Returns a Quaternion that defines the rotation b/w the global inertia frame and the local, surface-normal North-East-Up (y-x-z) frame &#39;&#39;&#39;
        # Time offset not necessary, since the x, y, z coordinates are inertial, and we are not 
            # interested in finding a particular location on the surface of the earth,
            # we are just interested in finding the surface normal under a x/y/z location. 
            # The result is independent of the earth&#39;s rotation.
        lat, lon, height = self.cartesianToGeodetic(x, y, z)

        # Rotation between inertial frame and ENU frame will be composed in two steps
        # Step 1: Rotate about inertial/initial Z-axis to Y-axis in such a way, that after rotation 2, 
            # it will be pointing North
        rot1Angle = radians(lon + 90)
        rot1 = Quaternion(axisOfRotation=Vector(0,0,1), angle=rot1Angle)
        
        # Step 2: Rotate about the local x-axis to match the latitude
        rot2Angle = radians(90 - lat)
        rot2 = Quaternion(axisOfRotation=Vector(1,0,0), angle=rot2Angle)

        # Sequentially combine rotations by multiplying them
        return rot1 * rot2

    def getAltitude(self, x, y, z):
        # Height is independent of the earth&#39;s rotation
        _, __, height = self.cartesianToGeodetic(x, y, z)
        return height

    def convertIntoGlobalFrame(self, launchTowerFrameState, lat, lon):
        ### Position ###
        height = launchTowerFrameState.position.Z # ASL altitude
        globalFramePosition = Vector(*self.geodeticToCartesian(lat, lon, height))
        
        ### Velocity ###
        # Find orientation of launch tower frame relative to global frame
        launchTowerToGlobalFrame = self.getInertialToENUFrameRotation(*globalFramePosition)

        # Rotate velocity accordingly
        rotatedVelocity = launchTowerToGlobalFrame.rotate(launchTowerFrameState.velocity)
        # Add earth&#39;s surface velocity
        earthAngVel = Vector(0, 0, self.rotationRate)
        velocityDueToEarthRotation = earthAngVel.crossProduct(globalFramePosition)
        globalFrameVelocity = rotatedVelocity + velocityDueToEarthRotation

        try:  # 6DoF Case           
            ### Orientation ###
            globalFrameOrientation = launchTowerToGlobalFrame * launchTowerFrameState.orientation

            ### Angular Velocity ###
            # Angular velocity is defined in the vehicle&#39;s local frame, so the conversion needs to go the other way
            earthAngVel_RocketFrame = globalFrameOrientation.conjugate().rotate(earthAngVel)
            localFrame_adjustedAngVel = launchTowerFrameState.angularVelocity + earthAngVel_RocketFrame

            return RigidBodyState( 
                globalFramePosition, 
                globalFrameVelocity, 
                globalFrameOrientation, 
                localFrame_adjustedAngVel
                )
        
        except AttributeError: # 3DoF Case
            return RigidBodyState_3DoF(globalFramePosition, globalFrameVelocity)             </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>MAPLEAF.ENV.EarthModelling.EarthModel</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.EarthModelling.WGS84" href="#MAPLEAF.ENV.EarthModelling.WGS84">WGS84</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.GM"><code class="name">var <span class="ident">GM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.rotationRate"><code class="name">var <span class="ident">rotationRate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.cartesianToGeodetic"><code class="name flex">
<span>def <span class="ident">cartesianToGeodetic</span></span>(<span>self, x, y, z, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from cartesian to lat/lon/height coordinates, where height is ASL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cartesianToGeodetic(self, x, y, z, timeOffset=0):
    &#39;&#39;&#39; Convert from cartesian to lat/lon/height coordinates, where height is ASL &#39;&#39;&#39;
    p = sqrt(x*x + y*y)
    
    lon = atan2(y, x)

    # Adjust for rotation rate
    lon -= self.rotationRate * timeOffset

    lat = atan2(z, p)
    height = sqrt(x*x + y*y + z*z) - self.radius
    
    return degrees(lat), degrees(lon), height</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.convertIntoGlobalFrame"><code class="name flex">
<span>def <span class="ident">convertIntoGlobalFrame</span></span>(<span>self, launchTowerFrameState, lat, lon)</span>
</code></dt>
<dd>
<div class="desc"><p>Should take a RigidBodyState defined in the launch tower frame (fixed to the earth's surface), where
position.Z has been redefined relative to sea level (instead of ground-level), and convert it into
the global inertial frame.
Exception is the Angular Velocity, since it is defined in the vehicle's local frame. If the earth model is
rotating, add the earth's angular velocity to it (after conversion into the local frame)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convertIntoGlobalFrame(self, launchTowerFrameState, lat, lon):
    ### Position ###
    height = launchTowerFrameState.position.Z # ASL altitude
    globalFramePosition = Vector(*self.geodeticToCartesian(lat, lon, height))
    
    ### Velocity ###
    # Find orientation of launch tower frame relative to global frame
    launchTowerToGlobalFrame = self.getInertialToENUFrameRotation(*globalFramePosition)

    # Rotate velocity accordingly
    rotatedVelocity = launchTowerToGlobalFrame.rotate(launchTowerFrameState.velocity)
    # Add earth&#39;s surface velocity
    earthAngVel = Vector(0, 0, self.rotationRate)
    velocityDueToEarthRotation = earthAngVel.crossProduct(globalFramePosition)
    globalFrameVelocity = rotatedVelocity + velocityDueToEarthRotation

    try:  # 6DoF Case           
        ### Orientation ###
        globalFrameOrientation = launchTowerToGlobalFrame * launchTowerFrameState.orientation

        ### Angular Velocity ###
        # Angular velocity is defined in the vehicle&#39;s local frame, so the conversion needs to go the other way
        earthAngVel_RocketFrame = globalFrameOrientation.conjugate().rotate(earthAngVel)
        localFrame_adjustedAngVel = launchTowerFrameState.angularVelocity + earthAngVel_RocketFrame

        return RigidBodyState( 
            globalFramePosition, 
            globalFrameVelocity, 
            globalFrameOrientation, 
            localFrame_adjustedAngVel
            )
    
    except AttributeError: # 3DoF Case
        return RigidBodyState_3DoF(globalFramePosition, globalFrameVelocity)             </code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.geodeticToCartesian"><code class="name flex">
<span>def <span class="ident">geodeticToCartesian</span></span>(<span>self, lat, lon, height, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.</p>
<p>Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and
the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system</p>
<h2 id="inputs">Inputs</h2>
<p>lat:
(float) latitude - degrees
lon:
(float) longitude - degrees
height: (float) ASL (usually m)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>
<p>(float) meters, relative to center of sphere</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>' '</p>
</dd>
<dt><code>z</code></dt>
<dd>
<p>' '</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
    &#39;&#39;&#39;
        Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
        
        Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
            the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system

        Inputs:
            lat:    (float) latitude - degrees
            lon:    (float) longitude - degrees
            height: (float) ASL (usually m)

        Returns:
            x:      (float) meters, relative to center of sphere
            y:      &#39; &#39;
            z:      &#39; &#39;
    &#39;&#39;&#39;
    lat = radians(lat)
    lon = radians(lon)

    # Adjust for rotation rate
    lon += self.rotationRate * timeOffset

    radius = self.radius + height

    x = radius * cos(lat) * cos(lon)
    y = radius * cos(lat) * sin(lon)
    z = radius * sin(lat)
    return x, y, z</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.getAltitude"><code class="name flex">
<span>def <span class="ident">getAltitude</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Given the aircraft coordinates in the global inertial frame, should return the altitude above SEA level (ASL) - to be used in wind calculations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAltitude(self, x, y, z):
    # Height is independent of the earth&#39;s rotation
    _, __, height = self.cartesianToGeodetic(x, y, z)
    return height</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.getGravityForce"><code class="name flex">
<span>def <span class="ident">getGravityForce</span></span>(<span>self, inertia, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a gravity force vector in the global frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGravityForce(self, inertia, state):
    &#39;&#39;&#39; Returns a gravity force vector in the global frame &#39;&#39;&#39;
    gravityDirection = -(state.position.normalize()) # Gravity pulls toward the earth&#39;s center of mass, which is the origin
    
    distanceFromCenterOfEarth = state.position.length()
    gravityMagnitude = inertia.mass * self.GM / distanceFromCenterOfEarth**2 # Checked that this equation gives results similar to the 
        # US Standard Atmosphere - offset a bit depending on what earth radius is used. Current 6371 km gives slightly lower values that USTDA.

    return gravityMagnitude * gravityDirection</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.SphericalEarth.getInertialToENUFrameRotation"><code class="name flex">
<span>def <span class="ident">getInertialToENUFrameRotation</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Quaternion that defines the rotation b/w the global inertia frame and the local, surface-normal North-East-Up (y-x-z) frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getInertialToENUFrameRotation(self, x, y, z):
    &#39;&#39;&#39; Returns a Quaternion that defines the rotation b/w the global inertia frame and the local, surface-normal North-East-Up (y-x-z) frame &#39;&#39;&#39;
    # Time offset not necessary, since the x, y, z coordinates are inertial, and we are not 
        # interested in finding a particular location on the surface of the earth,
        # we are just interested in finding the surface normal under a x/y/z location. 
        # The result is independent of the earth&#39;s rotation.
    lat, lon, height = self.cartesianToGeodetic(x, y, z)

    # Rotation between inertial frame and ENU frame will be composed in two steps
    # Step 1: Rotate about inertial/initial Z-axis to Y-axis in such a way, that after rotation 2, 
        # it will be pointing North
    rot1Angle = radians(lon + 90)
    rot1 = Quaternion(axisOfRotation=Vector(0,0,1), angle=rot1Angle)
    
    # Step 2: Rotate about the local x-axis to match the latitude
    rot2Angle = radians(90 - lat)
    rot2 = Quaternion(axisOfRotation=Vector(1,0,0), angle=rot2Angle)

    # Sequentially combine rotations by multiplying them
    return rot1 * rot2</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84"><code class="flex name class">
<span>class <span class="ident">WGS84</span></span>
</code></dt>
<dd>
<div class="desc"><p>Models a rotating, ellipsoid earth, with non-uniform gravity
Inherits the getInertialToENUFrameRotation function from SphericalEarth, otherwise overrides everything</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WGS84(SphericalEarth):
    &#39;&#39;&#39; 
        Models a rotating, ellipsoid earth, with non-uniform gravity 
        Inherits the getInertialToENUFrameRotation function from SphericalEarth, otherwise overrides everything
    &#39;&#39;&#39;
    # Set up/calculate the WGS84 Ellipsoid parameters and derived values
    a = 6378137             # m, semi-major axis
    f = 1/298.257223563     # Flattening (derived from C_20)
    b = a * (1-f)           # m, semi-minor axis = 6 356 752.314 140
    e2 = f*(2-f)            # First eccentricity squared (e^2) = 6.694 379 990 14 e-3
    eP2 = e2 / ((1-f)**2)   # Second eccentricity squared (e&#39;^2) = 6.739 496 742 28 e-3s
    eP = sqrt(eP2)          # Second eccentricity (e&#39;)

    def __init__(self):
        # Read gravity coefficients from table
        # Columns are: Degree Order C S (Where C and S are the coefficients)
        coeffPath = getAbsoluteFilePath(&#39;./MAPLEAF/ENV/sphericalHarmonicGravityCoeffs.txt&#39;)
        gravityCoeffs = np.loadtxt(coeffPath, skiprows=2)
        
        # Convert that table into nested dictionary form, to make C and S coefficients easily accessible by degree and order
        Ccoeffs = {}
        Scoeffs = {}
        for row in gravityCoeffs:
            degree, order, C, S, = row
            
            if degree not in Ccoeffs:
                # Create subdictionary for each degree if this is the first time we&#39;re encountering that degree
                Ccoeffs[degree] = {}
                Scoeffs[degree] = {}

            # Save coefficient from this row
            Ccoeffs[degree][order] = C
            Scoeffs[degree][order] = S

        # Save results
        # Now C_{2,3} is accessible as self.C[2][3], same for self.S
        self.C = Ccoeffs
        self.S = Scoeffs

    def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
        &#39;&#39;&#39;        
            Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
            
            Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
                the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system
            
            Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

            Note: In other references, it is common to set \phi = lat, \lamda = lon

            Inputs:
                lat:        (float) latitude - degrees
                lon:        (float) longitude - degrees
                height:     (float) ASL - m
                timeOffset  (float) Offset added to results based on earth&#39;s rotation rate.
                                At timeOffset=0, this inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

            Returns:
                x:      (float) meters, relative to center of ellipsoid
                y:      &#39; &#39;
                z:      &#39; &#39;
        &#39;&#39;&#39;
        lat = radians(lat)
        lon = radians(lon)

        # Adjust for earth&#39;s rate of rotation
        lon += self.rotationRate * timeOffset

        N = self.a / sqrt(1 - self.e2*sin(lat)**2)

        x = (N + height)*cos(lat)*cos(lon)
        y = (N + height)*cos(lat)*sin(lon)
        z = ((self.b**2 / self.a**2)*N + height) * sin(lat)

        return x, y, z

    def cartesianToGeodetic(self, x, y, z, timeOffset=0):
        &#39;&#39;&#39;
            Inputs in m, sec
            Convert from earth-centered inertial coordinates to WGS84 geodetic coordinates
            Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

            At timeOffset=0, the inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

            Returns latitude, longitude, height in degrees, m
        &#39;&#39;&#39;
        lon = atan2(y, x) # Longitude is easy to find

        # Adjust longitude for earth&#39;s rotation
        lon -= self.rotationRate * timeOffset

        ### Compute latitude and height normal to surface w/ Newton-Raphson method ###
        p = sqrt(x*x + y*y)
        Kold = 1/(1 - self.e2)
        Korig = Kold

        while True:
            ci = ((p*p + (1-self.e2)*z*z * Kold**2)**(1.5)) / (self.a * self.e2)
            Knew = 1 + (p*p + (1 - self.e2)*z*z * Kold**3) / (ci - p*p)
            
            # End iterations once delta per iteration &lt; 1e-10
            if abs(Knew - Kold) &lt; 1e-10:
                break

            Kold = Knew

        k = Knew

        lat = atan2(k*z, p)

        h = (1/self.e2)*(1/k - 1/Korig)*sqrt(p*p + z*z*k*k)

        return degrees(lat), degrees(lon), h

    # Re-use conversions to/from spherical coordinates from SphericalEarth
        # Useful for Spherical Harmonic Gravity model calculations, which are performed in spherical coordinates
    cartesianToSpherical = SphericalEarth.cartesianToGeodetic
    sphericalToCartesian = SphericalEarth.geodeticToCartesian

    def getGravityForce(self, inertia, state):
        &#39;&#39;&#39; 
            Get gravity using the J2 model (just a single spherical harmonic coefficient accounting for the earth&#39;s oblateness) 
            Method from NESC-RP-12-00770, Volume II, pg.51, Eqn 29-31
        &#39;&#39;&#39;
        # J2 Model just uses the first spherical harmonic coefficient
        J2 = 0.00108262982
        re = self.a # Equatorial radius (Semi-major axis of ellipsoid)

        x, y, z = state.position[0], state.position[1], state.position[2]
        r = state.position.length()
        
        mu = self.GM

        # Precompute common parts of equation
        frac = (3*J2 * re*re) / (2 * r**4)
        multiplier = -mu*inertia.mass / r**3

        xForce = x * multiplier * (1 - frac*(5*z*z - r*r))
        yForce = y * multiplier * (1 - frac*(5*z*z - r*r))
        zForce = z * multiplier * (1 - frac*(5*z*z - 3*r*r))

        return Vector(xForce, yForce, zForce)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth">SphericalEarth</a></li>
<li>MAPLEAF.ENV.EarthModelling.EarthModel</li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.a"><code class="name">var <span class="ident">a</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.b"><code class="name">var <span class="ident">b</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.e2"><code class="name">var <span class="ident">e2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.eP"><code class="name">var <span class="ident">eP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.eP2"><code class="name">var <span class="ident">eP2</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.f"><code class="name">var <span class="ident">f</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.cartesianToGeodetic"><code class="name flex">
<span>def <span class="ident">cartesianToGeodetic</span></span>(<span>self, x, y, z, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Inputs in m, sec
Convert from earth-centered inertial coordinates to WGS84 geodetic coordinates
Method adapted from: <a href="https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates">https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates</a></p>
<p>At timeOffset=0, the inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame</p>
<p>Returns latitude, longitude, height in degrees, m</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cartesianToGeodetic(self, x, y, z, timeOffset=0):
    &#39;&#39;&#39;
        Inputs in m, sec
        Convert from earth-centered inertial coordinates to WGS84 geodetic coordinates
        Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

        At timeOffset=0, the inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

        Returns latitude, longitude, height in degrees, m
    &#39;&#39;&#39;
    lon = atan2(y, x) # Longitude is easy to find

    # Adjust longitude for earth&#39;s rotation
    lon -= self.rotationRate * timeOffset

    ### Compute latitude and height normal to surface w/ Newton-Raphson method ###
    p = sqrt(x*x + y*y)
    Kold = 1/(1 - self.e2)
    Korig = Kold

    while True:
        ci = ((p*p + (1-self.e2)*z*z * Kold**2)**(1.5)) / (self.a * self.e2)
        Knew = 1 + (p*p + (1 - self.e2)*z*z * Kold**3) / (ci - p*p)
        
        # End iterations once delta per iteration &lt; 1e-10
        if abs(Knew - Kold) &lt; 1e-10:
            break

        Kold = Knew

    k = Knew

    lat = atan2(k*z, p)

    h = (1/self.e2)*(1/k - 1/Korig)*sqrt(p*p + z*z*k*k)

    return degrees(lat), degrees(lon), h</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.cartesianToSpherical"><code class="name flex">
<span>def <span class="ident">cartesianToSpherical</span></span>(<span>self, x, y, z, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from cartesian to lat/lon/height coordinates, where height is ASL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cartesianToGeodetic(self, x, y, z, timeOffset=0):
    &#39;&#39;&#39; Convert from cartesian to lat/lon/height coordinates, where height is ASL &#39;&#39;&#39;
    p = sqrt(x*x + y*y)
    
    lon = atan2(y, x)

    # Adjust for rotation rate
    lon -= self.rotationRate * timeOffset

    lat = atan2(z, p)
    height = sqrt(x*x + y*y + z*z) - self.radius
    
    return degrees(lat), degrees(lon), height</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.geodeticToCartesian"><code class="name flex">
<span>def <span class="ident">geodeticToCartesian</span></span>(<span>self, lat, lon, height, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.</p>
<p>Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and
the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system</p>
<p>Method adapted from: <a href="https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates">https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates</a></p>
<p>Note: In other references, it is common to set \phi = lat, \lamda = lon</p>
<h2 id="inputs">Inputs</h2>
<p>lat:
(float) latitude - degrees
lon:
(float) longitude - degrees
height:
(float) ASL - m
timeOffset
(float) Offset added to results based on earth's rotation rate.
At timeOffset=0, this inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>
<p>(float) meters, relative to center of ellipsoid</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>' '</p>
</dd>
<dt><code>z</code></dt>
<dd>
<p>' '</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
    &#39;&#39;&#39;        
        Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
        
        Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
            the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system
        
        Method adapted from: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates

        Note: In other references, it is common to set \phi = lat, \lamda = lon

        Inputs:
            lat:        (float) latitude - degrees
            lon:        (float) longitude - degrees
            height:     (float) ASL - m
            timeOffset  (float) Offset added to results based on earth&#39;s rotation rate.
                            At timeOffset=0, this inertial frame is aligned with the standard earth-centered-earth-fixed (ECEF) frame

        Returns:
            x:      (float) meters, relative to center of ellipsoid
            y:      &#39; &#39;
            z:      &#39; &#39;
    &#39;&#39;&#39;
    lat = radians(lat)
    lon = radians(lon)

    # Adjust for earth&#39;s rate of rotation
    lon += self.rotationRate * timeOffset

    N = self.a / sqrt(1 - self.e2*sin(lat)**2)

    x = (N + height)*cos(lat)*cos(lon)
    y = (N + height)*cos(lat)*sin(lon)
    z = ((self.b**2 / self.a**2)*N + height) * sin(lat)

    return x, y, z</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.getGravityForce"><code class="name flex">
<span>def <span class="ident">getGravityForce</span></span>(<span>self, inertia, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Get gravity using the J2 model (just a single spherical harmonic coefficient accounting for the earth's oblateness)
Method from NESC-RP-12-00770, Volume II, pg.51, Eqn 29-31</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGravityForce(self, inertia, state):
    &#39;&#39;&#39; 
        Get gravity using the J2 model (just a single spherical harmonic coefficient accounting for the earth&#39;s oblateness) 
        Method from NESC-RP-12-00770, Volume II, pg.51, Eqn 29-31
    &#39;&#39;&#39;
    # J2 Model just uses the first spherical harmonic coefficient
    J2 = 0.00108262982
    re = self.a # Equatorial radius (Semi-major axis of ellipsoid)

    x, y, z = state.position[0], state.position[1], state.position[2]
    r = state.position.length()
    
    mu = self.GM

    # Precompute common parts of equation
    frac = (3*J2 * re*re) / (2 * r**4)
    multiplier = -mu*inertia.mass / r**3

    xForce = x * multiplier * (1 - frac*(5*z*z - r*r))
    yForce = y * multiplier * (1 - frac*(5*z*z - r*r))
    zForce = z * multiplier * (1 - frac*(5*z*z - 3*r*r))

    return Vector(xForce, yForce, zForce)</code></pre>
</details>
</dd>
<dt id="MAPLEAF.ENV.EarthModelling.WGS84.sphericalToCartesian"><code class="name flex">
<span>def <span class="ident">sphericalToCartesian</span></span>(<span>self, lat, lon, height, timeOffset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.</p>
<p>Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and
the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system</p>
<h2 id="inputs">Inputs</h2>
<p>lat:
(float) latitude - degrees
lon:
(float) longitude - degrees
height: (float) ASL (usually m)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>x</code></dt>
<dd>
<p>(float) meters, relative to center of sphere</p>
</dd>
<dt><code>y</code></dt>
<dd>
<p>' '</p>
</dd>
<dt><code>z</code></dt>
<dd>
<p>' '</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def geodeticToCartesian(self, lat, lon, height, timeOffset=0):
    &#39;&#39;&#39;
        Converts from geodetic coordinates to cartesian coordinates, assuming the surface is a sphere.
        
        Resulting Z axis goes through north pole, X axis goes through prime meridian at the equator, and 
            the Y axis is perpendicular to both in such a way as to form a right-handed coordinate system

        Inputs:
            lat:    (float) latitude - degrees
            lon:    (float) longitude - degrees
            height: (float) ASL (usually m)

        Returns:
            x:      (float) meters, relative to center of sphere
            y:      &#39; &#39;
            z:      &#39; &#39;
    &#39;&#39;&#39;
    lat = radians(lat)
    lon = radians(lon)

    # Adjust for rotation rate
    lon += self.rotationRate * timeOffset

    radius = self.radius + height

    x = radius * cos(lat) * cos(lon)
    y = radius * cos(lat) * sin(lon)
    z = radius * sin(lat)
    return x, y, z</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth">SphericalEarth</a></b></code>:
<ul class="hlist">
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.convertIntoGlobalFrame" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.convertIntoGlobalFrame">convertIntoGlobalFrame</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.getAltitude" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.getAltitude">getAltitude</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.getInertialToENUFrameRotation" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.getInertialToENUFrameRotation">getInertialToENUFrameRotation</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="MAPLEAF Home" href="https://henrystoldt.github.io/MAPLEAF/">
<img src="https://raw.githubusercontent.com/henrystoldt/MAPLEAF/master/Resources/Draft2Logo.png" alt="Logo" width=75/>
MAPLEAF
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MAPLEAF.ENV" href="index.html">MAPLEAF.ENV</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MAPLEAF.ENV.EarthModelling.earthModelFactory" href="#MAPLEAF.ENV.EarthModelling.earthModelFactory">earthModelFactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MAPLEAF.ENV.EarthModelling.FlatEarth" href="#MAPLEAF.ENV.EarthModelling.FlatEarth">FlatEarth</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.EarthModelling.FlatEarth.GM" href="#MAPLEAF.ENV.EarthModelling.FlatEarth.GM">GM</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.FlatEarth.getGravityForce" href="#MAPLEAF.ENV.EarthModelling.FlatEarth.getGravityForce">getGravityForce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth" href="#MAPLEAF.ENV.EarthModelling.NoEarth">NoEarth</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.convertIntoGlobalFrame" href="#MAPLEAF.ENV.EarthModelling.NoEarth.convertIntoGlobalFrame">convertIntoGlobalFrame</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.getAltitude" href="#MAPLEAF.ENV.EarthModelling.NoEarth.getAltitude">getAltitude</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.getGravityForce" href="#MAPLEAF.ENV.EarthModelling.NoEarth.getGravityForce">getGravityForce</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.getInertialToENUFrameRotation" href="#MAPLEAF.ENV.EarthModelling.NoEarth.getInertialToENUFrameRotation">getInertialToENUFrameRotation</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.noForce" href="#MAPLEAF.ENV.EarthModelling.NoEarth.noForce">noForce</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.noRotation" href="#MAPLEAF.ENV.EarthModelling.NoEarth.noRotation">noRotation</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.NoEarth.rotationRate" href="#MAPLEAF.ENV.EarthModelling.NoEarth.rotationRate">rotationRate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth">SphericalEarth</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.GM" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.GM">GM</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.cartesianToGeodetic" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.cartesianToGeodetic">cartesianToGeodetic</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.convertIntoGlobalFrame" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.convertIntoGlobalFrame">convertIntoGlobalFrame</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.geodeticToCartesian" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.geodeticToCartesian">geodeticToCartesian</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.getAltitude" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.getAltitude">getAltitude</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.getGravityForce" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.getGravityForce">getGravityForce</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.getInertialToENUFrameRotation" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.getInertialToENUFrameRotation">getInertialToENUFrameRotation</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.radius" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.radius">radius</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.SphericalEarth.rotationRate" href="#MAPLEAF.ENV.EarthModelling.SphericalEarth.rotationRate">rotationRate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="MAPLEAF.ENV.EarthModelling.WGS84" href="#MAPLEAF.ENV.EarthModelling.WGS84">WGS84</a></code></h4>
<ul class="">
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.a" href="#MAPLEAF.ENV.EarthModelling.WGS84.a">a</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.b" href="#MAPLEAF.ENV.EarthModelling.WGS84.b">b</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.cartesianToGeodetic" href="#MAPLEAF.ENV.EarthModelling.WGS84.cartesianToGeodetic">cartesianToGeodetic</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.cartesianToSpherical" href="#MAPLEAF.ENV.EarthModelling.WGS84.cartesianToSpherical">cartesianToSpherical</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.e2" href="#MAPLEAF.ENV.EarthModelling.WGS84.e2">e2</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.eP" href="#MAPLEAF.ENV.EarthModelling.WGS84.eP">eP</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.eP2" href="#MAPLEAF.ENV.EarthModelling.WGS84.eP2">eP2</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.f" href="#MAPLEAF.ENV.EarthModelling.WGS84.f">f</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.geodeticToCartesian" href="#MAPLEAF.ENV.EarthModelling.WGS84.geodeticToCartesian">geodeticToCartesian</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.getGravityForce" href="#MAPLEAF.ENV.EarthModelling.WGS84.getGravityForce">getGravityForce</a></code></li>
<li><code><a title="MAPLEAF.ENV.EarthModelling.WGS84.sphericalToCartesian" href="#MAPLEAF.ENV.EarthModelling.WGS84.sphericalToCartesian">sphericalToCartesian</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>